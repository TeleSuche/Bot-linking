import logging
logger = logging.getLogger(__name__)
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CallbackContext, CallbackQueryHandler, CommandHandler, MessageHandler, filters, ApplicationBuilder

from typing import Dict, Optional
from datetime import datetime, timedelta

from utils.memory_full import db
from utils.api_client import sync_validate_bot_token
from utils.menu_utils import show_main_menu
from utils.user_features import get_welcome_message
from config import config
from utils.security import SecurityManager
from handlers.subscriptions import PLANS, get_user_plan, get_plan_limits
from modepay import PaymentProcessor

# √âtats utilisateur
from enum import Enum

class UserStates(Enum):
    INITIAL = "initial"
    AWAITING_TOKEN = "awaiting_token"
    SELECTING_LANGUAGE = "selecting_language"

PDG_USER_ID = config.PDG_USER_ID

pending_deletions = {}

# D√©claration de child_bots
child_bots: Dict[str, Application] = {}

bot_stats = {
    "earnings": {
        "total": 565.00,
        "withdrawn": 16.00,
        "pending": 100.00
    },
    "users": {
        "total": 300600,
        "active": 240000,
        "inactive": 60000
    },
    "community": {
        "active_groups": 50,
        "active_channels": 75
    },
    "status": {
        "health": "üü¢",
        "monetization": "Active"
    }
}

def init_child_bot(token: str, bot_username: str) -> Optional[Application]:
    """Initialise un bot enfant de mani√®re s√©curis√©e"""
    try:
        application = (
            ApplicationBuilder()
            .token(token)
            .connect_timeout(30)
            .read_timeout(30)
            .pool_timeout(30)
            .build()
        )
        
        if "child_bots" not in application.shared_data:
            application.shared_data["child_bots"] = {}
            
        application.shared_data["child_bots"][bot_username] = application
        return application
        
    except Exception as e:
        logger.error(f"Erreur initialisation bot fils: {e}")
        return None

async def check_bot_limits(user_id: int) -> bool:
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    if plan == "free":
        trial_end_date = db.get_user_trial_end_date(user_id)
        if trial_end_date and datetime.now() < datetime.fromisoformat(trial_end_date):
            if len(user_bots) >= 10:
                return False
        else:
            if len(user_bots) >= plan_limits["bots"]:
                return False
    else:
        if len(user_bots) >= plan_limits["bots"]:
            return False
    return True

async def check_group_limits(user_id: int, new_group_id: int = 0) -> bool:
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    total_groups = sum(len(bot.get("groups", [])) for bot in user_bots)
    if new_group_id > 0:
        total_groups += 1
    
    if total_groups >= plan_limits["groups"]:
        return False
    return True

def delete_user_bot(user_id: int, bot_username: str) -> bool:
    if user_id in db.bots:
        db.bots[user_id] = [bot for bot in db.bots[user_id] 
                          if bot.get('bot_username') != bot_username]
        return True
    return False
        
def cancel_bot_deletion(user_id: int, bot_username: str):
    key = f"{user_id}:{bot_username}"
    if key in pending_deletions:
        del pending_deletions[key]
    db.cancel_bot_deletion(user_id, bot_username)
        
def save_terms_acceptance(user_id: int):
    if user_id not in db.users:
        db.users[user_id] = {}
    db.users[user_id]['terms_accepted'] = True
        
def get_user_trial_end_date(user_id: int):
    return db.users.get(user_id, {}).get('trial_end_date')

# Dictionnaire des traductions
TRANSLATIONS = {
    'fr': {
        'bot_token': "Token du bot",
        'token_not_found': "Token non trouv√©",
        'bot_not_found': "Bot non trouv√©", 
        'error_try_again': "Erreur, veuillez r√©essayer",
        'back_button': "Retour",
        'cancel': "Annuler",
        'token_invalid': "Token invalide",
        'token_validation_error': "Erreur de validation du token",
        'bot_already_exists': "Ce bot existe d√©j√†",
        'creating_bot_app': "Cr√©ation de l'application bot...",
        'start_bot_success': "Bot d√©marr√© avec succ√®s",
        'start_bot_error': "Erreur lors du d√©marrage du bot",
        'bot_saved_success': "Bot sauvegard√© avec succ√®s",
        'delete_confirmation': "Confirmation de suppression",
        'this_action_irreversible': "Cette action est irr√©versible",
        'yes_delete': "Oui, supprimer",
        'no_cancel': "Non, annuler",
        'delete_scheduled': "Suppression programm√©e",
        'deletion_cancelled': "Suppression annul√©e",
        'cancel_deletion': "Annuler la suppression",
        'bot_info_title': "Informations du bot",
        'start_child_bot': "D√©marrer le bot",
        'stop_child_bot': "Arr√™ter le bot",
        'restart_child_bot': "Red√©marrer le bot",
        'bot_settings': "Param√®tres du bot",
        'bot_analytics': "Analytiques du bot",
        'bot_logs': "Journaux du bot",
        'bot_status_online': "En ligne",
        'bot_status_offline': "Hors ligne",
        'language_selection': "S√©lection de la langue",
        'language_changed': "Langue modifi√©e avec succ√®s",
        'bot_manager_title': "Gestionnaire de bots",
        'available_commands': "Commandes disponibles",
        'change_language': "Changer la langue",
        'manage_bots': "G√©rer les bots",
        'help_command': "Aide",
        'current_features': "Fonctionnalit√©s actuelles",
        'multilingual_support': "Support multilingue",
        'bot_management': "Gestion des bots",
        'user_preferences': "Pr√©f√©rences utilisateur",
        'demo_mode': "Mode d√©mo actif",
        'welcome': "Bienvenue ! Choisissez votre langue :",
        'data_export': "Exporter les donn√©es",
        'terms_declined': "Vous devez accepter les CGU pour utiliser le service",
        'begin_button': "Commencer",
        'start_button': "D√©marrer",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'en': {
        'bot_token': "Bot token",
        'token_not_found': "Token not found",
        'bot_not_found': "Bot not found",
        'error_try_again': "Error, please try again",
        'back_button': "Back",
        'cancel': "Cancel",
        'token_invalid': "Invalid token",
        'token_validation_error': "Token validation error",
        'bot_already_exists': "This bot already exists",
        'creating_bot_app': "Creating bot application...",
        'start_bot_success': "Bot started successfully",
        'start_bot_error': "Error starting bot",
        'bot_saved_success': "Bot saved successfully",
        'delete_confirmation': "Delete confirmation",
        'this_action_irreversible': "This action is irreversible",
        'yes_delete': "Yes, delete",
        'no_cancel': "No, cancel",
        'delete_scheduled': "Deletion scheduled",
        'deletion_cancelled': "Deletion cancelled",
        'cancel_deletion': "Cancel deletion",
        'bot_info_title': "Bot information",
        'start_child_bot': "Start bot",
        'stop_child_bot': "Stop bot", 
        'restart_child_bot': "Restart bot",
        'bot_settings': "Bot settings",
        'bot_analytics': "Bot analytics",
        'bot_logs': "Bot logs",
        'bot_status_online': "Online",
        'bot_status_offline': "Offline",
        'language_selection': "Language selection",
        'language_changed': "Language changed successfully",
        'bot_manager_title': "Bot Manager",
        'available_commands': "Available commands",
        'change_language': "Change language",
        'manage_bots': "Manage bots",
        'help_command': "Help",
        'current_features': "Current features",
        'multilingual_support': "Multilingual support",
        'bot_management': "Bot management",
        'user_preferences': "User preferences",
        'demo_mode': "Demo mode active",
        'welcome': "Welcome! Choose your language:",
        'data_export': "Export data",
        'terms_declined': "You must accept TOS to use the service",
        'begin_button': "Begin",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'es': {
        "bot_token": "Token del bot",
        "token_not_found": "Token no encontrado",
        "bot_not_found": "Bot no encontrado",
        "error_try_again": "Error, int√©ntelo de nuevo",
        "back": "Volver",
        "cancel": "Cancelar",
        "token_invalid": "Token inv√°lido",
        "token_validation_error": "Error de validaci√≥n del token",
        "bot_already_exists": "Este bot ya existe",
        "creating_bot_app": "Creando la aplicaci√≥n del bot...",
        "start_bot_success": "Bot iniciado con √©xito",
        "start_bot_error": "Error al iniciar el bot",
        "bot_saved_success": "Bot guardado con √©xito",
        "delete_confirmation": "Confirmaci√≥n de eliminaci√≥n",
        "this_action_irreversible": "Esta acci√≥n es irreversible",
        "yes_delete": "S√≠, eliminar",
        "no_cancel": "No, cancelar",
        "delete_scheduled": "Eliminaci√≥n programada",
        "deletion_cancelled": "Eliminaci√≥n cancelada",
        "cancel_deletion": "Cancelar eliminaci√≥n",
        "bot_info_title": "Informaci√≥n del bot",
        "start_child_bot": "Iniciar el bot",
        "stop_child_bot": "Detener el bot",
        "restart_child_bot": "Reiniciar el bot",
        "bot_settings": "Configuraciones del bot",
        "bot_analytics": "Anal√≠ticas del bot",
        "bot_logs": "Registros del bot",
        "bot_status_online": "En l√≠nea",
        "bot_status_offline": "Desconectado",
        "language_selection": "Selecci√≥n de idioma",
        "language_changed": "Idioma cambiado con √©xito",
        "bot_manager_title": "Administrador de bots",
        "available_commands": "Comandos disponibles",
        "change_language": "Cambiar idioma",
        "manage_bots": "Gestionar bots",
        "help_command": "Ayuda",
        "current_features": "Caracter√≠sticas actuales",
        "multilingual_support": "Soporte multiling√ºe",
        "bot_management": "Gesti√≥n de bots",
        "user_preferences": "Preferencias del usuario",
        "demo_mode": "Modo demo activo",
        "welcome": "¬°Bienvenido! Elige tu idioma:",
        "data_export": "Exportar datos",
        "terms_declined": "Debes aceptar los t√©rminos de servicio para usar el servicio",
        "begin_button": "Comenzar",
        "start_button": "Iniciar",
        "token_format": "Formato: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'de': {
        "bot_token": "Bot-Token",
        "token_not_found": "Token nicht gefunden",
        "bot_not_found": "Bot nicht gefunden",
        "error_try_again": "Fehler, bitte erneut versuchen",
        "back": "Zur√ºck",
        "cancel": "Abbrechen",
        "token_invalid": "Ung√ºltiger Token",
        "token_validation_error": "Token-Validierungsfehler",
        "bot_already_exists": "Dieser Bot existiert bereits",
        "creating_bot_app": "Bot-Anwendung wird erstellt...",
        "start_bot_success": "Bot erfolgreich gestartet",
        "start_bot_error": "Fehler beim Starten des Bots",
        "bot_saved_success": "Bot erfolgreich gespeichert",
        "delete_confirmation": "L√∂schbest√§tigung",
        "this_action_irreversible": "Diese Aktion ist nicht r√ºckg√§ngig zu machen",
        "yes_delete": "Ja, l√∂schen",
        "no_cancel": "Nein, abbrechen",
        "delete_scheduled": "L√∂schung geplant",
        "deletion_cancelled": "L√∂schung abgebrochen",
        "cancel_deletion": "L√∂schung abbrechen",
        "bot_info_title": "Bot-Informationen",
        "start_child_bot": "Bot starten",
        "stop_child_bot": "Bot stoppen",
        "restart_child_bot": "Bot neu starten",
        "bot_settings": "Bot-Einstellungen",
        "bot_analytics": "Bot-Analysen",
        "bot_logs": "Bot-Protokolle",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Sprachauswahl",
        "language_changed": "Sprache erfolgreich ge√§ndert",
        "bot_manager_title": "Bot-Manager",
        "available_commands": "Verf√ºgbare Befehle",
        "change_language": "Sprache √§ndern",
        "manage_bots": "Bots verwalten",
        "help_command": "Hilfe",
        "current_features": "Aktuelle Funktionen",
        "multilingual_support": "Mehrsprachige Unterst√ºtzung",
        "bot_management": "Bot-Verwaltung",
        "user_preferences": "Benutzereinstellungen",
        "demo_mode": "Demo-Modus aktiv",
        "welcome": "Willkommen! Bitte w√§hlen Sie Ihre Sprache:",
        "data_export": "Daten exportieren",
        "terms_declined": "Sie m√ºssen die Nutzungsbedingungen akzeptieren, um den Service zu nutzen",
        "begin_button": "Beginnen",
        "start_button": "Starten",
        "token_format": "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'zh': {
        "bot_token": "Êú∫Âô®‰∫∫‰ª§Áâå",
        "token_not_found": "Êú™ÊâæÂà∞‰ª§Áâå",
        "bot_not_found": "Êú™ÊâæÂà∞Êú∫Âô®‰∫∫",
        "error_try_again": "ÂèëÁîüÈîôËØØÔºåËØ∑ÈáçËØï",
        "back": "ËøîÂõû",
        "cancel": "ÂèñÊ∂à",
        "token_invalid": "‰ª§ÁâåÊó†Êïà",
        "token_validation_error": "‰ª§ÁâåÈ™åËØÅÈîôËØØ",
        "bot_already_exists": "ËØ•Êú∫Âô®‰∫∫Â∑≤Â≠òÂú®",
        "creating_bot_app": "Ê≠£Âú®ÂàõÂª∫Êú∫Âô®‰∫∫Â∫îÁî®...",
        "start_bot_success": "Êú∫Âô®‰∫∫ÂêØÂä®ÊàêÂäü",
        "start_bot_error": "ÂêØÂä®Êú∫Âô®‰∫∫Êó∂Âá∫Èîô",
        "bot_saved_success": "Êú∫Âô®‰∫∫‰øùÂ≠òÊàêÂäü",
        "delete_confirmation": "Âà†Èô§Á°ÆËÆ§",
        "this_action_irreversible": "Ê≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ",
        "yes_delete": "ÊòØÁöÑÔºåÂà†Èô§",
        "no_cancel": "‰∏çÔºåÂèñÊ∂à",
        "delete_scheduled": "Â∑≤ÂÆâÊéíÂà†Èô§",
        "deletion_cancelled": "Âà†Èô§Â∑≤ÂèñÊ∂à",
        "cancel_deletion": "ÂèñÊ∂àÂà†Èô§",
        "bot_info_title": "Êú∫Âô®‰∫∫‰ø°ÊÅØ",
        "start_child_bot": "ÂêØÂä®Êú∫Âô®‰∫∫",
        "stop_child_bot": "ÂÅúÊ≠¢Êú∫Âô®‰∫∫",
        "restart_child_bot": "ÈáçÂêØÊú∫Âô®‰∫∫",
        "bot_settings": "Êú∫Âô®‰∫∫ËÆæÁΩÆ",
        "bot_analytics": "Êú∫Âô®‰∫∫ÂàÜÊûê",
        "bot_logs": "Êú∫Âô®‰∫∫Êó•Âøó",
        "bot_status_online": "Âú®Á∫ø",
        "bot_status_offline": "Á¶ªÁ∫ø",
        "language_selection": "ÈÄâÊã©ËØ≠Ë®Ä",
        "language_changed": "ËØ≠Ë®ÄÊõ¥ÊîπÊàêÂäü",
        "bot_manager_title": "Êú∫Âô®‰∫∫ÁÆ°ÁêÜÂô®",
        "available_commands": "ÂèØÁî®ÂëΩ‰ª§",
        "change_language": "Êõ¥ÊîπËØ≠Ë®Ä",
        "manage_bots": "ÁÆ°ÁêÜÊú∫Âô®‰∫∫",
        "help_command": "Â∏ÆÂä©",
        "current_features": "ÂΩìÂâçÂäüËÉΩ",
        "multilingual_support": "Â§öËØ≠Ë®ÄÊîØÊåÅ",
        "bot_management": "Êú∫Âô®‰∫∫ÁÆ°ÁêÜ",
        "user_preferences": "Áî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ",
        "demo_mode": "ÊºîÁ§∫Ê®°ÂºèÂ∑≤ÊøÄÊ¥ª",
        "welcome": "Ê¨¢ËøéÔºÅËØ∑ÈÄâÊã©ÊÇ®ÁöÑËØ≠Ë®ÄÔºö",
        "data_export": "ÂØºÂá∫Êï∞ÊçÆ",
        "terms_declined": "ÊÇ®ÂøÖÈ°ªÊé•ÂèóÊúçÂä°Êù°Ê¨æÊâçËÉΩ‰ΩøÁî®ËØ•ÊúçÂä°",
        "begin_button": "ÂºÄÂßã",
        "start_button": "ÂêØÂä®",
        "token_format": "Ê†ºÂºè: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'hi': {
        "bot_token": "‡§¨‡•â‡§ü ‡§ü‡•ã‡§ï‡§®",
        "token_not_found": "‡§ü‡•ã‡§ï‡§® ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ",
        "bot_not_found": "‡§¨‡•â‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ",
        "error_try_again": "‡§§‡•ç‡§∞‡•Å‡§ü‡§ø, ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç",
        "back": "‡§µ‡§æ‡§™‡§∏",
        "cancel": "‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
        "token_invalid": "‡§Ö‡§µ‡•à‡§ß ‡§ü‡•ã‡§ï‡§®",
        "token_validation_error": "‡§ü‡•ã‡§ï‡§® ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§® ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
        "bot_already_exists": "‡§Ø‡§π ‡§¨‡•â‡§ü ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à",
        "creating_bot_app": "‡§¨‡•â‡§ü ‡§ê‡§™ ‡§¨‡§®‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...",
        "start_bot_success": "‡§¨‡•â‡§ü ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü",
        "start_bot_error": "‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
        "bot_saved_success": "‡§¨‡•â‡§ü ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∏‡§π‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ",
        "delete_confirmation": "‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø",
        "this_action_irreversible": "‡§Ø‡§π ‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§Ö‡§™‡§∞‡§ø‡§µ‡§∞‡•ç‡§§‡§®‡•Ä‡§Ø ‡§π‡•à",
        "yes_delete": "‡§π‡§æ‡§Å, ‡§π‡§ü‡§æ‡§è‡§Ç",
        "no_cancel": "‡§®‡§π‡•Ä‡§Ç, ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
        "delete_scheduled": "‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§¨‡§®‡§æ‡§à ‡§ó‡§à ‡§π‡•à",
        "deletion_cancelled": "‡§π‡§ü‡§æ‡§®‡§æ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ",
        "cancel_deletion": "‡§π‡§ü‡§æ‡§®‡§æ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
        "bot_info_title": "‡§¨‡•â‡§ü ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä",
        "start_child_bot": "‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
        "stop_child_bot": "‡§¨‡•â‡§ü ‡§∞‡•ã‡§ï‡•á‡§Ç",
        "restart_child_bot": "‡§¨‡•â‡§ü ‡§™‡•Å‡§®‡§É ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
        "bot_settings": "‡§¨‡•â‡§ü ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏",
        "bot_analytics": "‡§¨‡•â‡§ü ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "bot_logs": "‡§¨‡•â‡§ü ‡§≤‡•â‡§ó‡•ç‡§∏",
        "bot_status_online": "‡§ë‡§®‡§≤‡§æ‡§á‡§®",
        "bot_status_offline": "‡§ë‡§´‡§≤‡§æ‡§á‡§®",
        "language_selection": "‡§≠‡§æ‡§∑‡§æ ‡§ö‡§Ø‡§®",
        "language_changed": "‡§≠‡§æ‡§∑‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§¶‡§≤‡•Ä ‡§ó‡§à",
        "bot_manager_title": "‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§ï",
        "available_commands": "‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏",
        "change_language": "‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤‡•á‡§Ç",
        "manage_bots": "‡§¨‡•â‡§ü‡•ç‡§∏ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§® ‡§ï‡§∞‡•á‡§Ç",
        "help_command": "‡§∏‡§π‡§æ‡§Ø‡§§‡§æ",
        "current_features": "‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ‡§è‡§Å",
        "multilingual_support": "‡§¨‡§π‡•Å‡§≠‡§æ‡§∑‡•Ä‡§Ø ‡§∏‡§Æ‡§∞‡•ç‡§•‡§®",
        "bot_management": "‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®",
        "user_preferences": "‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§™‡•ç‡§∞‡§æ‡§•‡§Æ‡§ø‡§ï‡§§‡§æ‡§è‡§Å",
        "demo_mode": "‡§°‡•á‡§Æ‡•ã ‡§Æ‡•ã‡§° ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•à",
        "welcome": "‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ‡§Ö‡§™‡§®‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "data_export": "‡§°‡•á‡§ü‡§æ ‡§®‡§ø‡§∞‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§∞‡•á‡§Ç"
    },
    'ja': {
        "bot_token": "„Éú„ÉÉ„Éà„Éà„Éº„ÇØ„É≥",
        "token_not_found": "„Éà„Éº„ÇØ„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        "bot_not_found": "„Éú„ÉÉ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        "error_try_again": "„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        "back": "Êàª„Çã",
        "cancel": "„Ç≠„É£„É≥„Çª„É´",
        "token_invalid": "ÁÑ°Âäπ„Å™„Éà„Éº„ÇØ„É≥",
        "token_validation_error": "„Éà„Éº„ÇØ„É≥„ÅÆÊ§úË®º„Ç®„É©„Éº",
        "bot_already_exists": "„Åì„ÅÆ„Éú„ÉÉ„Éà„ÅØ„Åô„Åß„Å´Â≠òÂú®„Åó„Åæ„Åô",
        "creating_bot_app": "„Éú„ÉÉ„Éà„Ç¢„Éó„É™„Çí‰ΩúÊàê‰∏≠...",
        "start_bot_success": "„Éú„ÉÉ„Éà„ÅÆËµ∑Âãï„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü",
        "start_bot_error": "„Éú„ÉÉ„Éà„ÅÆËµ∑Âãï‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
        "bot_saved_success": "„Éú„ÉÉ„Éà„ÇíÊ≠£Â∏∏„Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü",
        "delete_confirmation": "ÂâäÈô§„ÅÆÁ¢∫Ë™ç",
        "this_action_irreversible": "„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì",
        "yes_delete": "„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åô„Çã",
        "no_cancel": "„ÅÑ„ÅÑ„Åà„ÄÅ„Ç≠„É£„É≥„Çª„É´„Åô„Çã",
        "delete_scheduled": "ÂâäÈô§„Åå‰∫àÂÆö„Åï„Çå„Åæ„Åó„Åü",
        "deletion_cancelled": "ÂâäÈô§„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
        "cancel_deletion": "ÂâäÈô§„Çí„Ç≠„É£„É≥„Çª„É´„Åô„Çã",
        "bot_info_title": "„Éú„ÉÉ„Éà„ÅÆÊÉÖÂ†±",
        "start_child_bot": "„Éú„ÉÉ„Éà„ÇíËµ∑Âãï",
        "stop_child_bot": "„Éú„ÉÉ„Éà„ÇíÂÅúÊ≠¢",
        "restart_child_bot": "„Éú„ÉÉ„Éà„ÇíÂÜçËµ∑Âãï",
        "bot_settings": "„Éú„ÉÉ„Éà„ÅÆË®≠ÂÆö",
        "bot_analytics": "„Éú„ÉÉ„Éà„ÅÆÂàÜÊûê",
        "bot_logs": "„Éú„ÉÉ„Éà„É≠„Ç∞",
        "bot_status_online": "„Ç™„É≥„É©„Ç§„É≥",
        "bot_status_offline": "„Ç™„Éï„É©„Ç§„É≥",
        "language_selection": "Ë®ÄË™ûÈÅ∏Êäû",
        "language_changed": "Ë®ÄË™û„ÅåÊ≠£Â∏∏„Å´Â§âÊõ¥„Åï„Çå„Åæ„Åó„Åü",
        "bot_manager_title": "„Éú„ÉÉ„Éà„Éû„Éç„Éº„Ç∏„É£„Éº",
        "available_commands": "Âà©Áî®ÂèØËÉΩ„Å™„Ç≥„Éû„É≥„Éâ",
        "change_language": "Ë®ÄË™û„ÇíÂ§âÊõ¥„Åô„Çã",
        "manage_bots": "„Éú„ÉÉ„Éà„ÇíÁÆ°ÁêÜ„Åô„Çã",
        "help_command": "„Éò„É´„Éó",
        "current_features": "ÁèæÂú®„ÅÆÊ©üËÉΩ",
        "multilingual_support": "Â§öË®ÄË™ûÂØæÂøú",
        "bot_management": "„Éú„ÉÉ„ÉàÁÆ°ÁêÜ",
        "user_preferences": "„É¶„Éº„Ç∂„ÉºË®≠ÂÆö",
        "demo_mode": "„Éá„É¢„É¢„Éº„Éâ„ÅåÊúâÂäπ„Åß„Åô",
        "welcome": "„Çà„ÅÜ„Åì„ÅùÔºÅË®ÄË™û„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö",
        "data_export": "„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã"
    },
    'ko': {
        "bot_token": "Î¥á ÌÜ†ÌÅ∞",
        "token_not_found": "ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
        "bot_not_found": "Î¥áÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
        "error_try_again": "Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî",
        "back": "Îí§Î°ú",
        "cancel": "Ï∑®ÏÜå",
        "token_invalid": "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞",
        "token_validation_error": "ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïò§Î•ò",
        "bot_already_exists": "Ïù¥ Î¥áÏùÄ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§",
        "creating_bot_app": "Î¥á Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÉùÏÑ± Ï§ë...",
        "start_bot_success": "Î¥áÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§",
        "start_bot_error": "Î¥á ÏãúÏûë Ï§ë Ïò§Î•ò Î∞úÏÉù",
        "bot_saved_success": "Î¥áÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§",
        "delete_confirmation": "ÏÇ≠Ï†ú ÌôïÏù∏",
        "this_action_irreversible": "Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§",
        "yes_delete": "Ïòà, ÏÇ≠Ï†úÌï©ÎãàÎã§",
        "no_cancel": "ÏïÑÎãàÏöî, Ï∑®ÏÜåÌï©ÎãàÎã§",
        "delete_scheduled": "ÏÇ≠Ï†ú ÏòàÏ†ïÎê®",
        "deletion_cancelled": "ÏÇ≠Ï†úÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§",
        "cancel_deletion": "ÏÇ≠Ï†ú Ï∑®ÏÜå",
        "bot_info_title": "Î¥á Ï†ïÎ≥¥",
        "start_child_bot": "Î¥á ÏãúÏûë",
        "stop_child_bot": "Î¥á Ï†ïÏßÄ",
        "restart_child_bot": "Î¥á Ïû¨ÏãúÏûë",
        "bot_settings": "Î¥á ÏÑ§Ï†ï",
        "bot_analytics": "Î¥á Î∂ÑÏÑù",
        "bot_logs": "Î¥á Î°úÍ∑∏",
        "bot_status_online": "Ïò®ÎùºÏù∏",
        "bot_status_offline": "Ïò§ÌîÑÎùºÏù∏",
        "language_selection": "Ïñ∏Ïñ¥ ÏÑ†ÌÉù",
        "language_changed": "Ïñ∏Ïñ¥Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§",
        "bot_manager_title": "Î¥á Í¥ÄÎ¶¨Ïûê",
        "available_commands": "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™ÖÎ†πÏñ¥",
        "change_language": "Ïñ∏Ïñ¥ Î≥ÄÍ≤Ω",
        "manage_bots": "Î¥á Í¥ÄÎ¶¨",
        "help_command": "ÎèÑÏõÄÎßê",
        "current_features": "ÌòÑÏû¨ Í∏∞Îä•",
        "multilingual_support": "Îã§Íµ≠Ïñ¥ ÏßÄÏõê",
        "bot_management": "Î¥á Í¥ÄÎ¶¨",
        "user_preferences": "ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï",
        "demo_mode": "Îç∞Î™® Î™®Îìú ÌôúÏÑ±ÌôîÎê®",
        "welcome": "ÌôòÏòÅÌï©ÎãàÎã§! Ïñ∏Ïñ¥Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî:",
        "data_export": "Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞"
    },
    'th': {
        "bot_token": "‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ï",
        "token_not_found": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô",
        "bot_not_found": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏≠‡∏ï",
        "error_try_again": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
        "back": "‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö",
        "cancel": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
        "token_invalid": "‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        "token_validation_error": "‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô",
        "bot_already_exists": "‡∏ö‡∏≠‡∏ï‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß",
        "creating_bot_app": "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏≠‡∏õ‡∏ö‡∏≠‡∏ï...",
        "start_bot_success": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        "start_bot_error": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï",
        "bot_saved_success": "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ö‡∏≠‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        "delete_confirmation": "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö",
        "this_action_irreversible": "‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ",
        "yes_delete": "‡πÉ‡∏ä‡πà ‡∏•‡∏ö‡πÄ‡∏•‡∏¢",
        "no_cancel": "‡πÑ‡∏°‡πà ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
        "delete_scheduled": "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏ö‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß",
        "deletion_cancelled": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÅ‡∏•‡πâ‡∏ß",
        "cancel_deletion": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏ö",
        "bot_info_title": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏≠‡∏ï",
        "start_child_bot": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï",
        "stop_child_bot": "‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏≠‡∏ï",
        "restart_child_bot": "‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡∏ö‡∏≠‡∏ï",
        "bot_settings": "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ö‡∏≠‡∏ï",
        "bot_analytics": "‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ö‡∏≠‡∏ï",
        "bot_logs": "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ö‡∏≠‡∏ï",
        "bot_status_online": "‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå",
        "bot_status_offline": "‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå",
        "language_selection": "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤",
        "language_changed": "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß",
        "bot_manager_title": "‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
        "available_commands": "‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
        "change_language": "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤",
        "manage_bots": "‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
        "help_command": "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠",
        "current_features": "‡∏Ñ‡∏∏‡∏ì‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô",
        "multilingual_support": "‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏©‡∏≤",
        "bot_management": "‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
        "user_preferences": "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ",
        "demo_mode": "‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏≤‡∏ò‡∏¥‡∏ï‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
        "welcome": "‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö! ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤:",
        "data_export": "‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•"
    },
    'ru': {
        "bot_token": "–¢–æ–∫–µ–Ω –±–æ—Ç–∞",
        "token_not_found": "–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω",
        "bot_not_found": "–ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
        "error_try_again": "–û—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑",
        "back": "–ù–∞–∑–∞–¥",
        "cancel": "–û—Ç–º–µ–Ω–∞",
        "token_invalid": "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ç–æ–∫–µ–Ω",
        "token_validation_error": "–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞",
        "bot_already_exists": "–ë–æ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç",
        "creating_bot_app": "–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –±–æ—Ç–∞...",
        "start_bot_success": "–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω",
        "start_bot_error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞",
        "bot_saved_success": "–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω",
        "delete_confirmation": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è",
        "this_action_irreversible": "–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ",
        "yes_delete": "–î–∞, —É–¥–∞–ª–∏—Ç—å",
        "no_cancel": "–ù–µ—Ç, –æ—Ç–º–µ–Ω–∞",
        "delete_scheduled": "–£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ",
        "deletion_cancelled": "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ",
        "cancel_deletion": "–û—Ç–º–µ–Ω–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ",
        "bot_info_title": "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ",
        "start_child_bot": "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞",
        "stop_child_bot": "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞",
        "restart_child_bot": "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞",
        "bot_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞",
        "bot_analytics": "–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –±–æ—Ç–∞",
        "bot_logs": "–õ–æ–≥–∏ –±–æ—Ç–∞",
        "bot_status_online": "–û–Ω–ª–∞–π–Ω",
        "bot_status_offline": "–û—Ñ—Ñ–ª–∞–π–Ω",
        "language_selection": "–í—ã–±–æ—Ä —è–∑—ã–∫–∞",
        "language_changed": "–Ø–∑—ã–∫ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω",
        "bot_manager_title": "–ú–µ–Ω–µ–¥–∂–µ—Ä –±–æ—Ç–æ–≤",
        "available_commands": "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã",
        "change_language": "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",
        "manage_bots": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏",
        "help_command": "–ü–æ–º–æ—â—å",
        "current_features": "–¢–µ–∫—É—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏",
        "multilingual_support": "–ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞",
        "bot_management": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–º",
        "user_preferences": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        "demo_mode": "–î–µ–º–æ-—Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω",
        "welcome": "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        "data_export": "–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"
    },
    'pt': {
        "bot_token": "Token do bot",
        "token_not_found": "Token n√£o encontrado",
        "bot_not_found": "Bot n√£o encontrado",
        "error_try_again": "Erro, tente novamente",
        "back": "Voltar",
        "cancel": "Cancelar",
        "token_invalid": "Token inv√°lido",
        "token_validation_error": "Erro de valida√ß√£o do token",
        "bot_already_exists": "Este bot j√° existe",
        "creating_bot_app": "Criando aplicativo do bot...",
        "start_bot_success": "Bot iniciado com sucesso",
        "start_bot_error": "Erro ao iniciar o bot",
        "bot_saved_success": "Bot salvo com sucesso",
        "delete_confirmation": "Confirma√ß√£o de exclus√£o",
        "this_action_irreversible": "Esta a√ß√£o √© irrevers√≠vel",
        "yes_delete": "Sim, excluir",
        "no_cancel": "N√£o, cancelar",
        "delete_scheduled": "Exclus√£o agendada",
        "deletion_cancelled": "Exclus√£o cancelada",
        "cancel_deletion": "Cancelar exclus√£o",
        "bot_info_title": "Informa√ß√µes do bot",
        "start_child_bot": "Iniciar bot",
        "stop_child_bot": "Parar bot",
        "restart_child_bot": "Reiniciar bot",
        "bot_settings": "Configura√ß√µes do bot",
        "bot_analytics": "An√°lises do bot",
        "bot_logs": "Registros do bot",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Sele√ß√£o de idioma",
        "language_changed": "Idioma alterado com sucesso",
        "bot_manager_title": "Gerenciador de bots",
        "available_commands": "Comandos dispon√≠veis",
        "change_language": "Alterar idioma",
        "manage_bots": "Gerenciar bots",
        "help_command": "Ajuda",
        "current_features": "Recursos atuais",
        "multilingual_support": "Suporte multil√≠ngue",
        "bot_management": "Gest√£o de bots",
        "user_preferences": "Prefer√™ncias do usu√°rio",
        "demo_mode": "Modo demonstra√ß√£o ativado",
        "welcome": "Bem-vindo! Escolha seu idioma:",
        "data_export": "Exportar dados"
    },
    'it': {
        "bot_token": "Token del bot",
        "token_not_found": "Token non trovato",
        "bot_not_found": "Bot non trovato",
        "error_try_again": "Errore, riprova",
        "back": "Indietro",
        "cancel": "Annulla",
        "token_invalid": "Token non valido",
        "token_validation_error": "Errore di convalida del token",
        "bot_already_exists": "Questo bot esiste gi√†",
        "creating_bot_app": "Creazione dell'app del bot...",
        "start_bot_success": "Bot avviato con successo",
        "start_bot_error": "Errore durante l'avvio del bot",
        "bot_saved_success": "Bot salvato con successo",
        "delete_confirmation": "Conferma eliminazione",
        "this_action_irreversible": "Questa azione √® irreversibile",
        "yes_delete": "S√¨, elimina",
        "no_cancel": "No, annulla",
        "delete_scheduled": "Eliminazione programmata",
        "deletion_cancelled": "Eliminazione annullata",
        "cancel_deletion": "Annulla eliminazione",
        "bot_info_title": "Informazioni del bot",
        "start_child_bot": "Avvia bot",
        "stop_child_bot": "Ferma bot",
        "restart_child_bot": "Riavvia bot",
        "bot_settings": "Impostazioni del bot",
        "bot_analytics": "Analisi del bot",
        "bot_logs": "Log del bot",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Selezione della lingua",
        "language_changed": "Lingua modificata con successo",
        "bot_manager_title": "Gestore dei bot",
        "available_commands": "Comandi disponibili",
        "change_language": "Cambia lingua",
        "manage_bots": "Gestisci i bot",
        "help_command": "Aiuto",
        "current_features": "Funzionalit√† attuali",
        "multilingual_support": "Supporto multilingue",
        "bot_management": "Gestione bot",
        "user_preferences": "Preferenze utente",
        "demo_mode": "Modalit√† demo attiva",
        "welcome": "Benvenuto! Scegli la tua lingua:",
        "data_export": "Esporta dati"
    },
    'ar': {
        "bot_token": "ÿ±ŸÖÿ≤ ÿßŸÑÿ®Ÿàÿ™",
        "token_not_found": "ÿßŸÑÿ±ŸÖÿ≤ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ",
        "bot_not_found": "ÿßŸÑÿ®Ÿàÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ",
        "error_try_again": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ",
        "back": "ÿ±ÿ¨Ÿàÿπ",
        "cancel": "ÿ•ŸÑÿ∫ÿßÿ°",
        "token_invalid": "ÿ±ŸÖÿ≤ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠",
        "token_validation_error": "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ±ŸÖÿ≤",
        "bot_already_exists": "Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ",
        "creating_bot_app": "ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ®Ÿàÿ™...",
        "start_bot_success": "ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠",
        "start_bot_error": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™",
        "bot_saved_success": "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠",
        "delete_confirmation": "ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ",
        "this_action_irreversible": "Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜŸá",
        "yes_delete": "ŸÜÿπŸÖÿå ÿßÿ≠ÿ∞ŸÅ",
        "no_cancel": "ŸÑÿßÿå ÿ•ŸÑÿ∫ÿßÿ°",
        "delete_scheduled": "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ŸÖŸàÿπÿØ ÿßŸÑÿ≠ÿ∞ŸÅ",
        "deletion_cancelled": "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∞ŸÅ",
        "cancel_deletion": "ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∞ŸÅ",
        "bot_info_title": "ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
        "start_child_bot": "ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™",
        "stop_child_bot": "ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ®Ÿàÿ™",
        "restart_child_bot": "ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™",
        "bot_settings": "ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
        "bot_analytics": "ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
        "bot_logs": "ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
        "bot_status_online": "ŸÖÿ™ÿµŸÑ",
        "bot_status_offline": "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ",
        "language_selection": "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿ∫ÿ©",
        "language_changed": "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ© ÿ®ŸÜÿ¨ÿßÿ≠",
        "bot_manager_title": "ŸÖÿØŸäÿ± ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
        "available_commands": "ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©",
        "change_language": "ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ©",
        "manage_bots": "ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
        "help_command": "ŸÖÿ≥ÿßÿπÿØÿ©",
        "current_features": "ÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©",
        "multilingual_support": "ÿØÿπŸÖ ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÑÿ∫ÿßÿ™",
        "bot_management": "ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
        "user_preferences": "ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ",
        "demo_mode": "Ÿàÿ∂ÿπ ÿßŸÑÿπÿ±ÿ∂ ŸÖŸÅÿπŸÑ",
        "welcome": "ŸÖÿ±ÿ≠ÿ®Ÿãÿß! Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÑÿ∫ÿ™ŸÉ:",
        "data_export": "ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"
    },
    'tr': {
        "bot_token": "Bot belirteci",
        "token_not_found": "Belirte√ß bulunamadƒ±",
        "bot_not_found": "Bot bulunamadƒ±",
        "error_try_again": "Hata olu≈ütu, l√ºtfen tekrar deneyin",
        "back": "Geri",
        "cancel": "ƒ∞ptal",
        "token_invalid": "Ge√ßersiz belirte√ß",
        "token_validation_error": "Belirte√ß doƒürulama hatasƒ±",
        "bot_already_exists": "Bu bot zaten mevcut",
        "creating_bot_app": "Bot uygulamasƒ± olu≈üturuluyor...",
        "start_bot_success": "Bot ba≈üarƒ±yla ba≈ülatƒ±ldƒ±",
        "start_bot_error": "Bot ba≈ülatƒ±lƒ±rken hata olu≈ütu",
        "bot_saved_success": "Bot ba≈üarƒ±yla kaydedildi",
        "delete_confirmation": "Silme onayƒ±",
        "this_action_irreversible": "Bu i≈ülem geri alƒ±namaz",
        "yes_delete": "Evet, sil",
        "no_cancel": "Hayƒ±r, iptal et",
        "delete_scheduled": "Silme zamanlandƒ±",
        "deletion_cancelled": "Silme i≈ülemi iptal edildi",
        "cancel_deletion": "Silme i≈ülemini iptal et",
        "bot_info_title": "Bot bilgileri",
        "start_child_bot": "Botu ba≈ülat",
        "stop_child_bot": "Botu durdur",
        "restart_child_bot": "Botu yeniden ba≈ülat",
        "bot_settings": "Bot ayarlarƒ±",
        "bot_analytics": "Bot analizleri",
        "bot_logs": "Bot g√ºnl√ºkleri",
        "bot_status_online": "√áevrimi√ßi",
        "bot_status_offline": "√áevrimdƒ±≈üƒ±",
        "language_selection": "Dil se√ßimi",
        "language_changed": "Dil ba≈üarƒ±yla deƒüi≈ütirildi",
        "bot_manager_title": "Bot y√∂neticisi",
        "available_commands": "Mevcut komutlar",
        "change_language": "Dili deƒüi≈ütir",
        "manage_bots": "Botlarƒ± y√∂net",
        "help_command": "Yardƒ±m",
        "current_features": "Mevcut √∂zellikler",
        "multilingual_support": "√áoklu dil desteƒüi",
        "bot_management": "Bot y√∂netimi",
        "user_preferences": "Kullanƒ±cƒ± tercihleri",
        "demo_mode": "Demo modu etkin",
        "welcome": "Ho≈ü geldiniz! L√ºtfen dilinizi se√ßin:",
        "data_export": "Verileri dƒ±≈üa aktar",
        "terms_declined": "Hizmeti kullanmak i√ßin Hizmet ≈ûartlarƒ±nƒ± kabul etmelisiniz",
        "begin_button": "Ba≈üla",
        "start_button": "Ba≈ülat",
        "token_format": "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'pl': {
        'bot_token': "Token bota",
        'token_not_found': "Token nie znaleziony",
        'bot_not_found': "Bot nie znaleziony",
        'error_try_again': "B≈ÇƒÖd, spr√≥buj ponownie",
        'back_button': "Wstecz",
        'cancel': "Anuluj",
        'token_invalid': "Nieprawid≈Çowy token",
        'welcome': "Witamy! Wybierz sw√≥j jƒôzyk:",
        'terms_declined': "Musisz zaakceptowaƒá Regulamin, aby korzystaƒá z us≈Çugi",
        'begin_button': "Rozpocznij",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'nl': {
        'bot_token': "Bot token",
        'token_not_found': "Token niet gevonden",
        'bot_not_found': "Bot niet gevonden",
        'error_try_again': "Fout, probeer opnieuw",
        'back_button': "Terug",
        'cancel': "Annuleren",
        'token_invalid': "Ongeldig token",
        'welcome': "Welkom! Kies je taal:",
        'terms_declined': "Je moet de Servicevoorwaarden accepteren om de service te gebruiken",
        'begin_button': "Begin",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'sv': {
        'bot_token': "Bot token",
        'token_not_found': "Token hittades inte",
        'bot_not_found': "Bot hittades inte",
        'error_try_again': "Fel, f√∂rs√∂k igen",
        'back_button': "Tillbaka",
        'cancel': "Avbryt",
        'token_invalid': "Ogiltigt token",
        'welcome': "V√§lkommen! V√§lj ditt spr√•k:",
        'terms_declined': "Du m√•ste acceptera Anv√§ndarvillkoren f√∂r att anv√§nda tj√§nsten",
        'begin_button': "B√∂rja",
        'start_button': "Starta",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'no': {
        'bot_token': "Bot token",
        'token_not_found': "Token ikke funnet",
        'bot_not_found': "Bot ikke funnet",
        'error_try_again': "Feil, vennligst pr√∏v igjen",
        'back_button': "Tilbake",
        'cancel': "Avbryt",
        'token_invalid': "Ugyldig token",
        'welcome': "Velkommen! Velg ditt spr√•k:",
        'terms_declined': "Du m√• akseptere Tjenestevilk√•rene for √• bruke tjenesten",
        'begin_button': "Begynn",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'da': {
        'bot_token': "Bot token",
        'token_not_found': "Token ikke fundet",
        'bot_not_found': "Bot ikke fundet",
        'error_try_again': "Fejl, pr√∏v venligst igen",
        'back_button': "Tilbage",
        'cancel': "Annuller",
        'token_invalid': "Ugyldigt token",
        'welcome': "Velkommen! V√¶lg dit sprog:",
        'terms_declined': "Du skal acceptere Servicevilk√•rene for at bruge tjenesten",
        'begin_button': "Begynd",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'fi': {
        'bot_token': "Bot token",
        'token_not_found': "Tokenia ei l√∂ytynyt",
        'bot_not_found': "Bottia ei l√∂ytynyt",
        'error_try_again': "Virhe, yrit√§ uudelleen",
        'back_button': "Takaisin",
        'cancel': "Peruuta",
        'token_invalid': "Virheellinen token",
        'welcome': "Tervetuloa! Valitse kielesi:",
        'terms_declined': "Sinun t√§ytyy hyv√§ksy√§ K√§ytt√∂ehdot k√§ytt√§√§ksesi palvelua",
        'begin_button': "Aloita",
        'start_button': "K√§ynnist√§",
        'token_format': "Muoto: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'he': {
        'bot_token': "◊ò◊ï◊ß◊ü ◊ë◊ï◊ò",
        'token_not_found': "◊ò◊ï◊ß◊ü ◊ú◊ê ◊†◊û◊¶◊ê",
        'bot_not_found': "◊ë◊ï◊ò ◊ú◊ê ◊†◊û◊¶◊ê",
        'error_try_again': "◊©◊í◊ô◊ê◊î, ◊†◊°◊î ◊©◊ï◊ë",
        'back_button': "◊ó◊ñ◊ï◊®",
        'cancel': "◊ë◊ô◊ò◊ï◊ú",
        'token_invalid': "◊ò◊ï◊ß◊ü ◊ú◊ê ◊™◊ß◊ô◊ü",
        'welcome': "◊ë◊®◊ï◊õ◊ô◊ù ◊î◊ë◊ê◊ô◊ù! ◊ë◊ó◊® ◊ê◊™ ◊î◊©◊§◊î ◊©◊ú◊ö:",
        'terms_declined': "◊¢◊ú◊ô◊ö ◊ú◊ß◊ë◊ú ◊ê◊™ ◊™◊†◊ê◊ô ◊î◊©◊ô◊®◊ï◊™ ◊õ◊ì◊ô ◊ú◊î◊©◊™◊û◊© ◊ë◊©◊ô◊®◊ï◊™",
        'begin_button': "◊î◊™◊ó◊ú",
        'start_button': "◊î◊§◊¢◊ú",
        'token_format': "◊§◊ï◊®◊û◊ò: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'cs': {
        'bot_token': "Bot token",
        'token_not_found': "Token nebyl nalezen",
        'bot_not_found': "Bot nebyl nalezen",
        'error_try_again': "Chyba, zkuste to znovu",
        'back_button': "Zpƒõt",
        'cancel': "Zru≈°it",
        'token_invalid': "Neplatn√Ω token",
        'welcome': "V√≠tejte! Vyberte sv≈Øj jazyk:",
        'terms_declined': "Mus√≠te p≈ôijmout Podm√≠nky slu≈æby, abyste mohli slu≈æbu pou≈æ√≠vat",
        'begin_button': "Zaƒç√≠t",
        'start_button': "Start",
        'token_format': "Form√°t: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'sk': {
        'bot_token': "Bot token",
        'token_not_found': "Token sa nena≈°iel",
        'bot_not_found': "Bot sa nena≈°iel",
        'error_try_again': "Chyba, sk√∫ste znova",
        'back_button': "Sp√§≈•",
        'cancel': "Zru≈°i≈•",
        'token_invalid': "Neplatn√Ω token",
        'welcome': "Vitajte! Vyberte si svoj jazyk:",
        'terms_declined': "Mus√≠te prija≈• Podmienky slu≈æby, aby ste mohli slu≈æbu pou≈æ√≠va≈•",
        'begin_button': "Zaƒça≈•",
        'start_button': "≈†tart",
        'token_format': "Form√°t: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'hu': {
        'bot_token': "Bot token",
        'token_not_found': "A token nem tal√°lhat√≥",
        'bot_not_found': "A bot nem tal√°lhat√≥",
        'error_try_again': "Hiba, k√©rlek pr√≥b√°ld √∫jra",
        'back_button': "Vissza",
        'cancel': "M√©gse",
        'token_invalid': "√ârv√©nytelen token",
        'welcome': "√údv√∂z√∂lj√ºk! V√°laszd ki a nyelved:",
        'terms_declined': "El kell fogadnod a Szolg√°ltat√°si Felt√©teleket a szolg√°ltat√°s haszn√°lat√°hoz",
        'begin_button': "Kezd√©s",
        'start_button': "Ind√≠t√°s",
        'token_format': "Form√°tum: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'ro': {
        'bot_token': "Token bot",
        'token_not_found': "Token-ul nu a fost gƒÉsit",
        'bot_not_found': "Bot-ul nu a fost gƒÉsit",
        'error_try_again': "Eroare, √ÆncearcƒÉ din nou",
        'back_button': "√énapoi",
        'cancel': "AnuleazƒÉ",
        'token_invalid': "Token invalid",
        'welcome': "Bun venit! Alege limba ta:",
        'terms_declined': "Trebuie sƒÉ accep»õi Termenii de Serviciu pentru a folosi serviciul",
        'begin_button': "√éncepe",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'bg': {
        'bot_token': "–¢–æ–∫–µ–Ω –Ω–∞ –±–æ—Ç–∞",
        'token_not_found': "–¢–æ–∫–µ–Ω—ä—Ç –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω",
        'bot_not_found': "–ë–æ—Ç—ä—Ç –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω",
        'error_try_again': "–ì—Ä–µ—à–∫–∞, –º–æ–ª—è –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ",
        'back_button': "–ù–∞–∑–∞–¥",
        'cancel': "–û—Ç–∫–∞–∑",
        'token_invalid': "–ù–µ–≤–∞–ª–∏–¥–µ–Ω —Ç–æ–∫–µ–Ω",
        'welcome': "–î–æ–±—Ä–µ –¥–æ—à–ª–∏! –ò–∑–±–µ—Ä–µ—Ç–µ –≤–∞—à–∏—è –µ–∑–∏–∫:",
        'terms_declined': "–¢—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–∏–µ–º–µ—Ç–µ –£—Å–ª–æ–≤–∏—è—Ç–∞ –∑–∞ –æ–±—Å–ª—É–∂–≤–∞–Ω–µ, –∑–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç–µ —É—Å–ª—É–≥–∞—Ç–∞",
        'begin_button': "–ó–∞–ø–æ—á–Ω–∏",
        'start_button': "–°—Ç–∞—Ä—Ç",
        'token_format': "–§–æ—Ä–º–∞—Ç: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'hr': {
        'bot_token': "Bot token",
        'token_not_found': "Token nije pronaƒëen",
        'bot_not_found': "Bot nije pronaƒëen",
        'error_try_again': "Gre≈°ka, molimo poku≈°ajte ponovo",
        'back_button': "Nazad",
        'cancel': "Otka≈æi",
        'token_invalid': "Neva≈æeƒái token",
        'welcome': "Dobrodo≈°li! Odaberite va≈° jezik:",
        'terms_declined': "Morate prihvatiti Uslove kori≈°ƒáenja da biste koristili uslugu",
        'begin_button': "Poƒçni",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'sl': {
        'bot_token': "Bot ≈æeton",
        'token_not_found': "≈Ωeton ni najden",
        'bot_not_found': "Bot ni najden",
        'error_try_again': "Napaka, poskusite znova",
        'back_button': "Nazaj",
        'cancel': "Prekliƒçi",
        'token_invalid': "Neveljaven ≈æeton",
        'welcome': "Dobrodo≈°li! Izberite svoj jezik:",
        'terms_declined': "Sprejeti morate Pogoje storitve, da lahko uporabljate storitev",
        'begin_button': "Zaƒçni",
        'start_button': "Zaƒçetek",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'uk': {
        'bot_token': "–¢–æ–∫–µ–Ω –±–æ—Ç–∞",
        'token_not_found': "–¢–æ–∫–µ–Ω –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
        'bot_not_found': "–ë–æ—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
        'error_try_again': "–ü–æ–º–∏–ª–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑",
        'back_button': "–ù–∞–∑–∞–¥",
        'cancel': "–°–∫–∞—Å—É–≤–∞—Ç–∏",
        'token_invalid': "–ù–µ–¥—ñ–π—Å–Ω–∏–π —Ç–æ–∫–µ–Ω",
        'welcome': "–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ! –û–±–µ—Ä—ñ—Ç—å –≤–∞—à—É –º–æ–≤—É:",
        'terms_declined': "–í–∏ –ø–æ–≤–∏–Ω–Ω—ñ –ø—Ä–∏–π–Ω—è—Ç–∏ –£–º–æ–≤–∏ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è, —â–æ–± –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Å–µ—Ä–≤—ñ—Å",
        'begin_button': "–ü–æ—á–∞—Ç–∏",
        'start_button': "–°—Ç–∞—Ä—Ç",
        'token_format': "–§–æ—Ä–º–∞—Ç: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'vi': {
        'bot_token': "Token bot",
        'token_not_found': "Kh√¥ng t√¨m th·∫•y token",
        'bot_not_found': "Kh√¥ng t√¨m th·∫•y bot",
        'error_try_again': "L·ªói, vui l√≤ng th·ª≠ l·∫°i",
        'back_button': "Quay l·∫°i",
        'cancel': "H·ªßy",
        'token_invalid': "Token kh√¥ng h·ª£p l·ªá",
        'welcome': "Ch√†o m·ª´ng! Ch·ªçn ng√¥n ng·ªØ c·ªßa b·∫°n:",
        'terms_declined': "B·∫°n ph·∫£i ch·∫•p nh·∫≠n ƒêi·ªÅu kho·∫£n D·ªãch v·ª• ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•",
        'begin_button': "B·∫Øt ƒë·∫ßu",
        'start_button': "Kh·ªüi ƒë·ªông",
        'token_format': "ƒê·ªãnh d·∫°ng: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'id': {
        'bot_token': "Token bot",
        'token_not_found': "Token tidak ditemukan",
        'bot_not_found': "Bot tidak ditemukan",
        'error_try_again': "Error, silakan coba lagi",
        'back_button': "Kembali",
        'cancel': "Batal",
        'token_invalid': "Token tidak valid",
        'welcome': "Selamat datang! Pilih bahasa Anda:",
        'terms_declined': "Anda harus menerima Syarat Layanan untuk menggunakan layanan",
        'begin_button': "Mulai",
        'start_button': "Start",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    'ms': {
        'bot_token': "Token bot",
        'token_not_found': "Token tidak dijumpai",
        'bot_not_found': "Bot tidak dijumpai",
        'error_try_again': "Ralat, sila cuba lagi",
        'back_button': "Kembali",
        'cancel': "Batal",
        'token_invalid': "Token tidak sah",
        'welcome': "Selamat datang! Pilih bahasa anda:",
        'terms_declined': "Anda mesti menerima Syarat Perkhidmatan untuk menggunakan perkhidmatan",
        'begin_button': "Mula",
        'start_button': "Mula",
        'token_format': "Format: 1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    }
}

# Liste des 28 langues support√©es dans l'ordre de la grille 7x4
SUPPORTED_LANGUAGES = [
    ('üá´üá∑', 'fr', 'Fran√ßais'),
    ('üá¨üáß', 'en', 'English'),
    ('üá™üá∏', 'es', 'Espa√±ol'),
    ('üá©üá™', 'de', 'Deutsch'),
    ('üá®üá≥', 'zh', 'ÁÆÄ‰Ωì‰∏≠Êñá'),
    ('üá∑üá∫', 'ru', '–†—É—Å—Å–∫–∏–π'),
    ('üáµüáπ', 'pt', 'Portugu√™s'),
    ('üáÆüáπ', 'it', 'Italiano'),
    ('üá¶üá∑', 'ar', 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©'),
    ('üáπüá∑', 'tr', 'T√ºrk√ße'),
    ('üáØüáµ', 'ja', 'Êó•Êú¨Ë™û'),
    ('üá∞üá∑', 'ko', 'ÌïúÍµ≠Ïñ¥'),
    ('üáπüá≠', 'th', '‡πÑ‡∏ó‡∏¢'),
    ('üáÆüá≥', 'hi', '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä'),
    ('üáªüá≥', 'vi', 'Ti·∫øng Vi·ªát'),
    ('üáµüá±', 'pl', 'Polski'),
    ('üá≥üá±', 'nl', 'Nederlands'),
    ('üá∏üá™', 'sv', 'Svenska'),
    ('üá≥üá¥', 'no', 'Norsk'),
    ('üá©üá∞', 'da', 'Dansk'),
    ('üá´üáÆ', 'fi', 'Suomi'),
    ('üáÆüá±', 'he', '◊¢◊ë◊®◊ô◊™'),
    ('üá®üáø', 'cs', 'ƒåe≈°tina'),
    ('üá∏üá∞', 'sk', 'Slovenƒçina'),
    ('üá≠üá∫', 'hu', 'Magyar'),
    ('üá∑üá¥', 'ro', 'Rom√¢nƒÉ'),
    ('üáßüá¨', 'bg', '–ë—ä–ª–≥–∞—Ä—Å–∫–∏'),
    ('üá≠üá∑', 'hr', 'Hrvatski')
]

def create_language_selection_keyboard():
    """Cr√©e la grille 7x4 boutons pour la s√©lection des 28 langues"""
    keyboard = []
    languages = SUPPORTED_LANGUAGES
    
    # Cr√©er la grille 7 rang√©es x 4 colonnes = 28 boutons
    for row in range(7):
        row_buttons = []
        for col in range(4):
            index = row * 4 + col
            if index < len(languages):
                flag, code, name = languages[index]
                button_text = f"{flag} {name}"
                callback_data = f"set_language:{code}"
                row_buttons.append(InlineKeyboardButton(button_text, callback_data=callback_data))
        if row_buttons:
            keyboard.append(row_buttons)
    
    return InlineKeyboardMarkup(keyboard)

async def show_language_selection(update: Update):
    """Affiche la s√©lection de langue avec grille 7x4 boutons pour 28 langues"""
    try:
        keyboard = create_language_selection_keyboard()
        
        welcome_text = ("üåç Bienvenue ! Choisissez votre langue\n"
                       "üåç Welcome! Choose your language\n"
                       "üåç ¬°Bienvenido! Elige tu idioma\n"
                       "üåç Willkommen! W√§hlen Sie Ihre Sprache")
        
        if update.message:
            await update.message.reply_text(welcome_text, reply_markup=keyboard)
        elif update.callback_query:
            await update.callback_query.edit_message_text(welcome_text, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Erreur dans show_language_selection: {e}")
        return None

# Classe principale pour la gestion des bots
class BotLinkingManager:
    @staticmethod
    async def set_language_callback(update: Update, context: CallbackContext):
        """Gestionnaire pour la s√©lection de langue depuis la grille 7x4"""
        query = update.callback_query
        await query.answer()
        lang_code = query.data.split(":")[1]
        user_id = query.from_user.id
        
        try:
            # Sauvegarder la langue s√©lectionn√©e
            db.set_user_language(user_id, lang_code)
            
            # Mapping des noms de langues pour les 28 langues
            lang_names = {
                'fr': "Fran√ßais", 'en': "English", 'es': "Espa√±ol", 'de': "Deutsch",
                'zh': "ÁÆÄ‰Ωì‰∏≠Êñá", 'ru': "–†—É—Å—Å–∫–∏–π", 'pt': "Portugu√™s", 'it': "Italiano", 
                'ar': "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", 'tr': "T√ºrk√ße", 'ja': "Êó•Êú¨Ë™û", 'ko': "ÌïúÍµ≠Ïñ¥",
                'th': "‡πÑ‡∏ó‡∏¢", 'hi': "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", 'vi': "Ti·∫øng Vi·ªát", 'pl': "Polski",
                'nl': "Nederlands", 'sv': "Svenska", 'no': "Norsk", 'da': "Dansk",
                'fi': "Suomi", 'he': "◊¢◊ë◊®◊ô◊™", 'cs': "ƒåe≈°tina", 'sk': "Slovenƒçina",
                'hu': "Magyar", 'ro': "Rom√¢nƒÉ", 'bg': "–ë—ä–ª–≥–∞—Ä—Å–∫–∏", 'hr': "Hrvatski"
            }
                
            lang_name = lang_names.get(lang_code, lang_code)
            confirmation = f"{get_text(lang_code, 'language_changed')} ({lang_name})"
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    f"‚úÖ {get_text(lang_code, 'begin_button')}",
                    callback_data="terms_accepted"
                )]
            ])
            
            await query.edit_message_text(confirmation, reply_markup=keyboard)
        except Exception as e:
            logger.error(f"Erreur dans set_language_callback: {e}")
            await query.edit_message_text("‚ùå Erreur de changement de langue")

    @staticmethod
    async def handle_main_start(update: Update, context: CallbackContext):
        try:
            user_id = update.effective_user.id
            
            if db.is_new_user(user_id):
                db.users[user_id] = {
                    'state': UserStates.INITIAL.value,
                    'language': 'fr',
                    'trial_end_date': (datetime.now() + timedelta(days=14)).isoformat()
                }
                db.save_to_disk('users', {str(user_id): db.users[user_id]})
                await show_language_selection(update)
            else:
                await show_main_menu(update, context)
        except Exception as e:
            logger.error(f"Erreur dans handle_main_start: {e} [ERR_BLM_004]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de l'initialisation. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_004)")

# Configuration termin√©e pour les 28 langues
        "start_bot_error": "B≈ÇƒÖd podczas uruchamiania bota",
        "bot_saved_success": "Bot zosta≈Ç pomy≈õlnie zapisany",
        "delete_confirmation": "Potwierdzenie usuniƒôcia",
        "this_action_irreversible": "Tej operacji nie mo≈ºna cofnƒÖƒá",
        "yes_delete": "Tak, usu≈Ñ",
        "no_cancel": "Nie, anuluj",
        "delete_scheduled": "Usuniƒôcie zaplanowane",
        "deletion_cancelled": "Usuniƒôcie anulowane",
        "cancel_deletion": "Anuluj usuniƒôcie",
        "bot_info_title": "Informacje o bocie",
        "start_child_bot": "Uruchom bota",
        "stop_child_bot": "Zatrzymaj bota",
        "restart_child_bot": "Uruchom ponownie bota",
        "bot_settings": "Ustawienia bota",
        "bot_analytics": "Analizy bota",
        "bot_logs": "Logi bota",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Wyb√≥r jƒôzyka",
        "language_changed": "Jƒôzyk zosta≈Ç pomy≈õlnie zmieniony",
        "bot_manager_title": "Mened≈ºer bot√≥w",
        "available_commands": "Dostƒôpne polecenia",
        "change_language": "Zmie≈Ñ jƒôzyk",
        "manage_bots": "ZarzƒÖdzaj botami",
        "help_command": "Pomoc",
        "current_features": "Obecne funkcje",
        "multilingual_support": "Obs≈Çuga wielu jƒôzyk√≥w",
        "bot_management": "ZarzƒÖdzanie botami",
        "user_preferences": "Preferencje u≈ºytkownika",
        "demo_mode": "Tryb demonstracyjny aktywny",
        "welcome": "Witaj! Wybierz sw√≥j jƒôzyk:",
        "data_export": "Eksport danych"
    },
    'nl': {
        "bot_token": "Bot-token",
        "token_not_found": "Token niet gevonden",
        "bot_not_found": "Bot niet gevonden",
        "error_try_again": "Fout, probeer het opnieuw",
        "back": "Terug",
        "cancel": "Annuleren",
        "token_invalid": "Ongeldig token",
        "token_validation_error": "Fout bij tokenvalidatie",
        "bot_already_exists": "Deze bot bestaat al",
        "creating_bot_app": "Bot-app wordt aangemaakt...",
        "start_bot_success": "Bot succesvol gestart",
        "start_bot_error": "Fout bij het starten van de bot",
        "bot_saved_success": "Bot succesvol opgeslagen",
        "delete_confirmation": "Verwijderbevestiging",
        "this_action_irreversible": "Deze actie is onomkeerbaar",
        "yes_delete": "Ja, verwijderen",
        "no_cancel": "Nee, annuleren",
        "delete_scheduled": "Verwijdering gepland",
        "deletion_cancelled": "Verwijdering geannuleerd",
        "cancel_deletion": "Verwijdering annuleren",
        "bot_info_title": "Botinformatie",
        "start_child_bot": "Start bot",
        "stop_child_bot": "Stop bot",
        "restart_child_bot": "Herstart bot",
        "bot_settings": "Botinstellingen",
        "bot_analytics": "Botanalyse",
        "bot_logs": "Botlogboeken",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Taalkeuze",
        "language_changed": "Taal succesvol gewijzigd",
        "bot_manager_title": "Botbeheerder",
        "available_commands": "Beschikbare commando's",
        "change_language": "Taal wijzigen",
        "manage_bots": "Beheer bots",
        "help_command": "Help",
        "current_features": "Huidige functies",
        "multilingual_support": "Meertalige ondersteuning",
        "bot_management": "Botbeheer",
        "user_preferences": "Gebruikersvoorkeuren",
        "demo_mode": "Demomodus actief",
        "welcome": "Welkom! Kies je taal:",
        "data_export": "Gegevens exporteren"
    },
    'sv': {
        "bot_token": "Bot-token",
        "token_not_found": "Token hittades inte",
        "bot_not_found": "Bot hittades inte",
        "error_try_again": "Fel, f√∂rs√∂k igen",
        "back": "Tillbaka",
        "cancel": "Avbryt",
        "token_invalid": "Ogiltig token",
        "token_validation_error": "Tokenverifieringsfel",
        "bot_already_exists": "Denna bot finns redan",
        "creating_bot_app": "Skapar bot-applikation...",
        "start_bot_success": "Bot startades framg√•ngsrikt",
        "start_bot_error": "Fel vid start av bot",
        "bot_saved_success": "Bot sparades framg√•ngsrikt",
        "delete_confirmation": "Bekr√§fta borttagning",
        "this_action_irreversible": "Denna √•tg√§rd kan inte √•ngras",
        "yes_delete": "Ja, ta bort",
        "no_cancel": "Nej, avbryt",
        "delete_scheduled": "Borttagning planerad",
        "deletion_cancelled": "Borttagning avbr√∂ts",
        "cancel_deletion": "Avbryt borttagning",
        "bot_info_title": "Botinformation",
        "start_child_bot": "Starta bot",
        "stop_child_bot": "Stoppa bot",
        "restart_child_bot": "Starta om bot",
        "bot_settings": "Botinst√§llningar",
        "bot_analytics": "Botanalys",
        "bot_logs": "Botloggar",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Spr√•kval",
        "language_changed": "Spr√•k har √§ndrats",
        "bot_manager_title": "Bothanterare",
        "available_commands": "Tillg√§ngliga kommandon",
        "change_language": "Byt spr√•k",
        "manage_bots": "Hantera bottar",
        "help_command": "Hj√§lp",
        "current_features": "Nuvarande funktioner",
        "multilingual_support": "Flerspr√•kigt st√∂d",
        "bot_management": "Botadministration",
        "user_preferences": "Anv√§ndarinst√§llningar",
        "demo_mode": "Demol√§ge aktivt",
        "welcome": "V√§lkommen! V√§lj ditt spr√•k:",
        "data_export": "Exportera data"
    },
    'uk': {
        "bot_token": "–¢–æ–∫–µ–Ω –±–æ—Ç–∞",
        "token_not_found": "–¢–æ–∫–µ–Ω –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
        "bot_not_found": "–ë–æ—Ç–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
        "error_try_again": "–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑",
        "back": "–ù–∞–∑–∞–¥",
        "cancel": "–°–∫–∞—Å—É–≤–∞—Ç–∏",
        "token_invalid": "–ù–µ–¥—ñ–π—Å–Ω–∏–π —Ç–æ–∫–µ–Ω",
        "token_validation_error": "–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó —Ç–æ–∫–µ–Ω–∞",
        "bot_already_exists": "–¶–µ–π –±–æ—Ç –≤–∂–µ —ñ—Å–Ω—É—î",
        "creating_bot_app": "–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞—Å—Ç–æ—Å—É–Ω–∫—É –¥–ª—è –±–æ—Ç–∞...",
        "start_bot_success": "–ë–æ—Ç —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ",
        "start_bot_error": "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –±–æ—Ç–∞",
        "bot_saved_success": "–ë–æ—Ç–∞ —É—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ",
        "delete_confirmation": "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è",
        "this_action_irreversible": "–¶—é –¥—ñ—é –Ω–µ–º–æ–∂–ª–∏–≤–æ —Å–∫–∞—Å—É–≤–∞—Ç–∏",
        "yes_delete": "–¢–∞–∫, –≤–∏–¥–∞–ª–∏—Ç–∏",
        "no_cancel": "–ù—ñ, —Å–∫–∞—Å—É–≤–∞—Ç–∏",
        "delete_scheduled": "–í–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ",
        "deletion_cancelled": "–í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ",
        "cancel_deletion": "–°–∫–∞—Å—É–≤–∞—Ç–∏ –≤–∏–¥–∞–ª–µ–Ω–Ω—è",
        "bot_info_title": "–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –±–æ—Ç–∞",
        "start_child_bot": "–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –±–æ—Ç–∞",
        "stop_child_bot": "–ó—É–ø–∏–Ω–∏—Ç–∏ –±–æ—Ç–∞",
        "restart_child_bot": "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–∏ –±–æ—Ç–∞",
        "bot_settings": "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–æ—Ç–∞",
        "bot_analytics": "–ê–Ω–∞–ª—ñ—Ç–∏–∫–∞ –±–æ—Ç–∞",
        "bot_logs": "–õ–æ–≥–∏ –±–æ—Ç–∞",
        "bot_status_online": "–û–Ω–ª–∞–π–Ω",
        "bot_status_offline": "–û—Ñ–ª–∞–π–Ω",
        "language_selection": "–í–∏–±—ñ—Ä –º–æ–≤–∏",
        "language_changed": "–ú–æ–≤—É —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–æ",
        "bot_manager_title": "–ú–µ–Ω–µ–¥–∂–µ—Ä –±–æ—Ç—ñ–≤",
        "available_commands": "–î–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–∞–Ω–¥–∏",
        "change_language": "–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É",
        "manage_bots": "–ö–µ—Ä—É–≤–∞—Ç–∏ –±–æ—Ç–∞–º–∏",
        "help_command": "–î–æ–ø–æ–º–æ–≥–∞",
        "current_features": "–ü–æ—Ç–æ—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó",
        "multilingual_support": "–ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –±–∞–≥–∞—Ç–æ–º–æ–≤–Ω–æ—Å—Ç—ñ",
        "bot_management": "–ö–µ—Ä—É–≤–∞–Ω–Ω—è –±–æ—Ç–æ–º",
        "user_preferences": "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞",
        "demo_mode": "–î–µ–º–æ-—Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–Ω–∏–π",
        "welcome": "–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ! –û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É:",
        "data_export": "–ï–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–∏—Ö"
    },
    'sw': {
        "bot_token": "Tokeni ya bot",
        "token_not_found": "Tokeni haijapatikana",
        "bot_not_found": "Bot haijapatikana",
        "error_try_again": "Hitilafu imetokea, tafadhali jaribu tena",
        "back": "Rudi nyuma",
        "cancel": "Ghairi",
        "token_invalid": "Tokeni si sahihi",
        "token_validation_error": "Hitilafu ya uthibitishaji wa tokeni",
        "bot_already_exists": "Bot hii tayari ipo",
        "creating_bot_app": "Inaunda programu ya bot...",
        "start_bot_success": "Bot imeanza kwa mafanikio",
        "start_bot_error": "Hitilafu ilipotokea wakati wa kuanza bot",
        "bot_saved_success": "Bot imehifadhiwa kwa mafanikio",
        "delete_confirmation": "Uthibitisho wa kufuta",
        "this_action_irreversible": "Hatua hii haiwezi kubatilishwa",
        "yes_delete": "Ndio, futa",
        "no_cancel": "Hapana, ghairi",
        "delete_scheduled": "Kufuta kumewekwa ratiba",
        "deletion_cancelled": "Kufuta kumefutwa",
        "cancel_deletion": "Ghairi kufuta",
        "bot_info_title": "Maelezo ya bot",
        "start_child_bot": "Anzisha bot",
        "stop_child_bot": "Simamisha bot",
        "restart_child_bot": "Anzisha upya bot",
        "bot_settings": "Mipangilio ya bot",
        "bot_analytics": "Takwimu za bot",
        "bot_logs": "Rekodi za bot",
        "bot_status_online": "Mtandaoni",
        "bot_status_offline": "Nje ya mtandao",
        "language_selection": "Chagua lugha",
        "language_changed": "Lugha imebadilishwa kwa mafanikio",
        "bot_manager_title": "Meneja wa bot",
        "available_commands": "Amri zinazopatikana",
        "change_language": "Badilisha lugha",
        "manage_bots": "Simamia bot",
        "help_command": "Msaada",
        "current_features": "Vipengele vya sasa",
        "multilingual_support": "Msaada wa lugha nyingi",
        "bot_management": "Usimamizi wa bot",
        "user_preferences": "Mapendeleo ya mtumiaji",
        "demo_mode": "Hali ya majaribio imewashwa",
        "welcome": "Karibu! Tafadhali chagua lugha yako:",
        "data_export": "Hamisha data"
    },
    'he': {
        "bot_token": "◊ê◊°◊ô◊û◊ï◊ü ◊î◊ë◊ï◊ò",
        "token_not_found": "◊î◊ê◊°◊ô◊û◊ï◊ü ◊ú◊ê ◊†◊û◊¶◊ê",
        "bot_not_found": "◊î◊ë◊ï◊ò ◊ú◊ê ◊†◊û◊¶◊ê",
        "error_try_again": "◊©◊í◊ô◊ê◊î, ◊†◊°◊î ◊©◊ï◊ë",
        "back": "◊ó◊ñ◊®◊î",
        "cancel": "◊ë◊ô◊ò◊ï◊ú",
        "token_invalid": "◊ê◊°◊ô◊û◊ï◊ü ◊©◊í◊ï◊ô",
        "token_validation_error": "◊©◊í◊ô◊ê◊î ◊ë◊ê◊ô◊û◊ï◊™ ◊î◊ê◊°◊ô◊û◊ï◊ü",
        "bot_already_exists": "◊î◊ë◊ï◊ò ◊õ◊ë◊® ◊ß◊ô◊ô◊ù",
        "creating_bot_app": "◊ô◊ï◊¶◊® ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™ ◊ë◊ï◊ò...",
        "start_bot_success": "◊î◊ë◊ï◊ò ◊î◊ï◊§◊¢◊ú ◊ë◊î◊¶◊ú◊ó◊î",
        "start_bot_error": "◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊î◊§◊¢◊ú◊™ ◊î◊ë◊ï◊ò",
        "bot_saved_success": "◊î◊ë◊ï◊ò ◊†◊©◊û◊® ◊ë◊î◊¶◊ú◊ó◊î",
        "delete_confirmation": "◊ê◊ô◊©◊ï◊® ◊û◊ó◊ô◊ß◊î",
        "this_action_irreversible": "◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊ê◊ô◊†◊î ◊î◊§◊ô◊õ◊î",
        "yes_delete": "◊õ◊ü, ◊û◊ó◊ß",
        "no_cancel": "◊ú◊ê, ◊ë◊ò◊ú",
        "delete_scheduled": "◊î◊û◊ó◊ô◊ß◊î ◊™◊ï◊ñ◊û◊†◊î",
        "deletion_cancelled": "◊î◊û◊ó◊ô◊ß◊î ◊ë◊ï◊ò◊ú◊î",
        "cancel_deletion": "◊ë◊ò◊ú ◊û◊ó◊ô◊ß◊î",
        "bot_info_title": "◊û◊ô◊ì◊¢ ◊¢◊ú ◊î◊ë◊ï◊ò",
        "start_child_bot": "◊î◊§◊¢◊ú◊™ ◊î◊ë◊ï◊ò",
        "stop_child_bot": "◊î◊§◊°◊ß◊™ ◊î◊ë◊ï◊ò",
        "restart_child_bot": "◊ê◊™◊ó◊ï◊ú ◊î◊ë◊ï◊ò",
        "bot_settings": "◊î◊í◊ì◊®◊ï◊™ ◊î◊ë◊ï◊ò",
        "bot_analytics": "◊†◊ô◊™◊ï◊ó ◊†◊™◊ï◊†◊ô ◊î◊ë◊ï◊ò",
        "bot_logs": "◊ô◊ï◊û◊†◊ô ◊î◊ë◊ï◊ò",
        "bot_status_online": "◊û◊ß◊ï◊ï◊ü",
        "bot_status_offline": "◊ú◊ê ◊û◊ß◊ï◊ï◊ü",
        "language_selection": "◊ë◊ó◊ô◊®◊™ ◊©◊§◊î",
        "language_changed": "◊î◊©◊§◊î ◊©◊ï◊†◊™◊î ◊ë◊î◊¶◊ú◊ó◊î",
        "bot_manager_title": "◊û◊†◊î◊ú ◊î◊ë◊ï◊ò◊ô◊ù",
        "available_commands": "◊§◊ß◊ï◊ì◊ï◊™ ◊ñ◊û◊ô◊†◊ï◊™",
        "change_language": "◊©◊†◊î ◊©◊§◊î",
        "manage_bots": "◊†◊ô◊î◊ï◊ú ◊ë◊ï◊ò◊ô◊ù",
        "help_command": "◊¢◊ñ◊®◊î",
        "current_features": "◊§◊ô◊¶◊≥◊®◊ô◊ù ◊†◊ï◊õ◊ó◊ô◊ô◊ù",
        "multilingual_support": "◊™◊û◊ô◊õ◊î ◊®◊ë÷æ◊ú◊©◊ï◊†◊ô◊™",
        "bot_management": "◊†◊ô◊î◊ï◊ú ◊ë◊ï◊ò◊ô◊ù",
        "user_preferences": "◊î◊¢◊ì◊§◊ï◊™ ◊û◊©◊™◊û◊©",
        "demo_mode": "◊û◊¶◊ë ◊î◊ì◊í◊û◊î ◊§◊¢◊ô◊ú",
        "welcome": "◊ë◊®◊ï◊ö ◊î◊ë◊ê! ◊ê◊†◊ê ◊ë◊ó◊® ◊©◊§◊î:",
        "data_export": "◊ô◊ô◊¶◊ï◊ê ◊†◊™◊ï◊†◊ô◊ù"
    },
    'ro': {
        "bot_token": "Tokenul botului",
        "token_not_found": "Tokenul nu a fost gƒÉsit",
        "bot_not_found": "Botul nu a fost gƒÉsit",
        "error_try_again": "Eroare, te rog √ÆncearcƒÉ din nou",
        "back": "√énapoi",
        "cancel": "AnuleazƒÉ",
        "token_invalid": "Token invalid",
        "token_validation_error": "Eroare la validarea tokenului",
        "bot_already_exists": "Acest bot existƒÉ deja",
        "creating_bot_app": "Se creeazƒÉ aplica»õia botului...",
        "start_bot_success": "Botul a fost pornit cu succes",
        "start_bot_error": "Eroare la pornirea botului",
        "bot_saved_success": "Botul a fost salvat cu succes",
        "delete_confirmation": "Confirmare »ôtergere",
        "this_action_irreversible": "AceastƒÉ ac»õiune este ireversibilƒÉ",
        "yes_delete": "Da, »ôterge",
        "no_cancel": "Nu, anuleazƒÉ",
        "delete_scheduled": "»òtergerea a fost programatƒÉ",
        "deletion_cancelled": "»òtergerea a fost anulatƒÉ",
        "cancel_deletion": "AnuleazƒÉ »ôtergerea",
        "bot_info_title": "Informa»õii despre bot",
        "start_child_bot": "Porne»ôte botul",
        "stop_child_bot": "Opre»ôte botul",
        "restart_child_bot": "Reporne»ôte botul",
        "bot_settings": "SetƒÉri bot",
        "bot_analytics": "Analize bot",
        "bot_logs": "Jurnale bot",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Selectare limbƒÉ",
        "language_changed": "Limba a fost schimbatƒÉ cu succes",
        "bot_manager_title": "Managerul de boturi",
        "available_commands": "Comenzi disponibile",
        "change_language": "SchimbƒÉ limba",
        "manage_bots": "GestioneazƒÉ boturile",
        "help_command": "Ajutor",
        "current_features": "Func»õionalitƒÉ»õi curente",
        "multilingual_support": "Suport multilingv",
        "bot_management": "Administrare boturi",
        "user_preferences": "Preferin»õe utilizator",
        "demo_mode": "Mod demo activat",
        "welcome": "Bine ai venit! Alege limba:",
        "data_export": "ExportƒÉ datele"
    },
    'fa': {
        "bot_token": "ÿ™Ÿà⁄©ŸÜ ÿ±ÿ®ÿßÿ™",
        "token_not_found": "ÿ™Ÿà⁄©ŸÜ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ",
        "bot_not_found": "ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ",
        "error_try_again": "ÿÆÿ∑ÿßÿå ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ",
        "back": "ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
        "cancel": "ŸÑÿ∫Ÿà",
        "token_invalid": "ÿ™Ÿà⁄©ŸÜ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™",
        "token_validation_error": "ÿÆÿ∑ÿß ÿØÿ± ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿ™Ÿà⁄©ŸÜ",
        "bot_already_exists": "ÿß€åŸÜ ÿ±ÿ®ÿßÿ™ ŸÇÿ®ŸÑÿßŸã Ÿàÿ¨ŸàÿØ ÿØÿßÿ±ÿØ",
        "creating_bot_app": "ÿØÿ± ÿ≠ÿßŸÑ ÿ≥ÿßÿÆÿ™ ÿßŸæŸÑ€å⁄©€åÿ¥ŸÜ ÿ±ÿ®ÿßÿ™...",
        "start_bot_success": "ÿ±ÿ®ÿßÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ¥ÿØ",
        "start_bot_error": "ÿÆÿ∑ÿß ÿØÿ± ŸáŸÜ⁄ØÿßŸÖ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ±ÿ®ÿßÿ™",
        "bot_saved_success": "ÿ±ÿ®ÿßÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ",
        "delete_confirmation": "ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ",
        "this_action_irreversible": "ÿß€åŸÜ ÿπŸÖŸÑ€åÿßÿ™ ŸÇÿßÿ®ŸÑ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ŸÜ€åÿ≥ÿ™",
        "yes_delete": "ÿ®ŸÑŸáÿå ÿ≠ÿ∞ŸÅ ÿ¥ŸàÿØ",
        "no_cancel": "ÿÆ€åÿ±ÿå ŸÑÿ∫Ÿà ÿ¥ŸàÿØ",
        "delete_scheduled": "ÿ≠ÿ∞ŸÅ ÿ≤ŸÖÿßŸÜ‚Äåÿ®ŸÜÿØ€å ÿ¥ÿØŸá ÿßÿ≥ÿ™",
        "deletion_cancelled": "ÿ≠ÿ∞ŸÅ ŸÑÿ∫Ÿà ÿ¥ÿØ",
        "cancel_deletion": "ŸÑÿ∫Ÿà ÿ≠ÿ∞ŸÅ",
        "bot_info_title": "ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
        "start_child_bot": "ÿ¥ÿ±Ÿàÿπ ÿ±ÿ®ÿßÿ™",
        "stop_child_bot": "ÿ™ŸàŸÇŸÅ ÿ±ÿ®ÿßÿ™",
        "restart_child_bot": "ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÖÿ¨ÿØÿØ ÿ±ÿ®ÿßÿ™",
        "bot_settings": "ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
        "bot_analytics": "ÿ™ÿ≠ŸÑ€åŸÑ‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™",
        "bot_logs": "⁄Øÿ≤ÿßÿ±ÿ¥‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™",
        "bot_status_online": "ÿ¢ŸÜŸÑÿß€åŸÜ",
        "bot_status_offline": "ÿ¢ŸÅŸÑÿß€åŸÜ",
        "language_selection": "ÿßŸÜÿ™ÿÆÿßÿ® ÿ≤ÿ®ÿßŸÜ",
        "language_changed": "ÿ≤ÿ®ÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ",
        "bot_manager_title": "ŸÖÿØ€åÿ± ÿ±ÿ®ÿßÿ™",
        "available_commands": "ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá",
        "change_language": "ÿ™ÿ∫ŸäŸäÿ± ÿ≤ÿ®ÿßŸÜ",
        "manage_bots": "ŸÖÿØŸäÿ±Ÿäÿ™ ÿ±ÿ®ÿßÿ™‚ÄåŸáÿß",
        "help_command": "ÿ±ÿßŸáŸÜŸÖÿß",
        "current_features": "ŸàŸä⁄ò⁄Ø€å‚ÄåŸáÿß€å ŸÅÿπŸÑ€å",
        "multilingual_support": "Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ⁄ÜŸÜÿØÿ≤ÿ®ÿßŸÜŸá",
        "bot_management": "ŸÖÿØŸäÿ±Ÿäÿ™ ÿ±ÿ®ÿßÿ™",
        "user_preferences": "ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±",
        "demo_mode": "ÿ≠ÿßŸÑÿ™ ÿØŸÖŸà ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™",
        "welcome": "ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ! ŸÑÿ∑ŸÅÿßŸã ÿ≤ÿ®ÿßŸÜ ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
        "data_export": "ÿÆÿ±Ÿàÿ¨€å ⁄Øÿ±ŸÅÿ™ŸÜ ÿßÿ≤ ÿØÿßÿØŸá‚ÄåŸáÿß"
    },
    'ms': {
        "bot_token": "Token bot",
        "token_not_found": "Token tidak dijumpai",
        "bot_not_found": "Bot tidak dijumpai",
        "error_try_again": "Ralat berlaku, sila cuba lagi",
        "back": "Kembali",
        "cancel": "Batal",
        "token_invalid": "Token tidak sah",
        "token_validation_error": "Ralat pengesahan token",
        "bot_already_exists": "Bot ini sudah wujud",
        "creating_bot_app": "Sedang mencipta aplikasi bot...",
        "start_bot_success": "Bot berjaya dimulakan",
        "start_bot_error": "Ralat semasa memulakan bot",
        "bot_saved_success": "Bot berjaya disimpan",
        "delete_confirmation": "Pengesahan penghapusan",
        "this_action_irreversible": "Tindakan ini tidak boleh diundurkan",
        "yes_delete": "Ya, padam",
        "no_cancel": "Tidak, batal",
        "delete_scheduled": "Penghapusan telah dijadualkan",
        "deletion_cancelled": "Penghapusan telah dibatalkan",
        "cancel_deletion": "Batal penghapusan",
        "bot_info_title": "Maklumat bot",
        "start_child_bot": "Mulakan bot",
        "stop_child_bot": "Hentikan bot",
        "restart_child_bot": "Mulakan semula bot",
        "bot_settings": "Tetapan bot",
        "bot_analytics": "Analitik bot",
        "bot_logs": "Log bot",
        "bot_status_online": "Dalam talian",
        "bot_status_offline": "Luar talian",
        "language_selection": "Pemilihan bahasa",
        "language_changed": "Bahasa telah berjaya ditukar",
        "bot_manager_title": "Pengurus bot",
        "available_commands": "Arahan yang tersedia",
        "change_language": "Tukar bahasa",
        "manage_bots": "Urus bot",
        "help_command": "Bantuan",
        "current_features": "Ciri-ciri semasa",
        "multilingual_support": "Sokongan berbilang bahasa",
        "bot_management": "Pengurusan bot",
        "user_preferences": "Keutamaan pengguna",
        "demo_mode": "Mod demo diaktifkan",
        "welcome": "Selamat datang! Sila pilih bahasa anda:",
        "data_export": "Eksport data"
    },
    'id': {
        "bot_token": "Token bot",
        "token_not_found": "Token tidak ditemukan",
        "bot_not_found": "Bot tidak ditemukan",
        "error_try_again": "Terjadi kesalahan, silakan coba lagi",
        "back": "Kembali",
        "cancel": "Batalkan",
        "token_invalid": "Token tidak valid",
        "token_validation_error": "Kesalahan validasi token",
        "bot_already_exists": "Bot ini sudah ada",
        "creating_bot_app": "Membuat aplikasi bot...",
        "start_bot_success": "Bot berhasil dijalankan",
        "start_bot_error": "Kesalahan saat menjalankan bot",
        "bot_saved_success": "Bot berhasil disimpan",
        "delete_confirmation": "Konfirmasi penghapusan",
        "this_action_irreversible": "Tindakan ini tidak dapat dibatalkan",
        "yes_delete": "Ya, hapus",
        "no_cancel": "Tidak, batalkan",
        "delete_scheduled": "Penghapusan dijadwalkan",
        "deletion_cancelled": "Penghapusan dibatalkan",
        "cancel_deletion": "Batalkan penghapusan",
        "bot_info_title": "Informasi bot",
        "start_child_bot": "Jalankan bot",
        "stop_child_bot": "Hentikan bot",
        "restart_child_bot": "Mulai ulang bot",
        "bot_settings": "Pengaturan bot",
        "bot_analytics": "Analitik bot",
        "bot_logs": "Log bot",
        "bot_status_online": "Online",
        "bot_status_offline": "Offline",
        "language_selection": "Pemilihan bahasa",
        "language_changed": "Bahasa berhasil diubah",
        "bot_manager_title": "Manajer bot",
        "available_commands": "Perintah yang tersedia",
        "change_language": "Ubah bahasa",
        "manage_bots": "Kelola bot",
        "help_command": "Bantuan",
        "current_features": "Fitur saat ini",
        "multilingual_support": "Dukungan multibahasa",
        "bot_management": "Manajemen bot",
        "user_preferences": "Preferensi pengguna",
        "demo_mode": "Mode demo aktif",
        "welcome": "Selamat datang! Silakan pilih bahasa Anda:",
        "data_export": "Ekspor data"
    }
    
}

def get_text(lang: str, key: str) -> str:
    lang_data = TRANSLATIONS.get(lang, TRANSLATIONS['fr'])
    return lang_data.get(key, key)

async def handle_pdg_token_input(update: Update, context: CallbackContext, application):
    try:
        return application
    except Exception as e:
        logger.error(f"Erreur dans handle_pdg_token_input: {e} [ERR_BLM_037]", exc_info=True)
        await update.message.reply_text(
            "‚ùå Erreur lors de la configuration du Bot PDG. "
            "Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_037)"
        )


async def show_language_options(update: Update, context: CallbackContext):
        """Affiche le menu de s√©lection de langue avec 28 options"""
        try:
            # R√©cup√©ration de l'utilisateur et de sa langue
            if update.message:
                user_id = update.message.from_user.id
                lang = db.get_user_language(user_id) or 'fr'
            else:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                lang = db.get_user_language(user_id) or 'fr'

            text = get_text(lang, 'language_selection')
            
            # Dictionnaire complet des 28 langues avec emojis
            lang_names = {
                'fr': "üá´üá∑ Fran√ßais",
                'en': "üá¨üáß English",
                'es': "üá™üá∏ Espa√±ol",
                'de': "üá©üá™ Deutsch",
                'zh': "üá®üá≥ ‰∏≠Êñá",
                'hi': "üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä",
                'ja': "üáØüáµ Êó•Êú¨Ë™û",
                'ko': "üá∞üá∑ ÌïúÍµ≠Ïñ¥",
                'th': "üáπüá≠ ‡πÑ‡∏ó‡∏¢",
                'ru': "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
                'pt': "üáµüáπ Portugu√™s",
                'it': "üáÆüáπ Italiano",
                'ar': "üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
                'tr': "üáπüá∑ T√ºrk√ße",
                'vi': "üáªüá≥ Ti·∫øng Vi·ªát",
                'pl': "üáµüá± Polski",
                'nl': "üá≥üá± Nederlands",
                'sv': "üá∏üá™ Svenska",
                'uk': "üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
                'sw': "üá∞üá™ Kiswahili",
                'he': "üáÆüá± ◊¢◊ë◊®◊ô◊™",
                'ro': "üá∑üá¥ Rom√¢nƒÉ",
                'fa': "üáÆüá∑ ŸÅÿßÿ±ÿ≥€å",
                'ms': "üá≤üáæ Bahasa Melayu",
                'id': "üáÆüá© Bahasa Indonesia",
                'cs': "üá®üáø ƒåe≈°tina",
                'da': "üá©üá∞ Dansk",
                'fi': "üá´üáÆ Suomi",
                'hu': "üá≠üá∫ Magyar"
            }

            # Cr√©ation des boutons par groupe de 3
            buttons = []
            row = []
            
            for code, label in lang_names.items():
                row.append(InlineKeyboardButton(label, callback_data=f"setlang_{code}"))
                if len(row) == 3:  # 3 boutons par ligne
                    buttons.append(row)
                    row = []
            
            # Ajouter la derni√®re ligne si incompl√®te
            if row:
                buttons.append(row)

            # Bouton de retour
            buttons.append([
                InlineKeyboardButton(
                    get_text(lang, 'back_button'), 
                    callback_data="back_to_main"
                )
            ])

            markup = InlineKeyboardMarkup(buttons)

            # Envoi du message
            if update.message:
                await update.message.reply_text(text, reply_markup=markup, parse_mode="HTML")
            else:
                await query.edit_message_text(text, reply_markup=markup, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans show_language_options: {e} [ERR_LANG_OPT]", exc_info=True)
            error_msg = get_text(lang, 'error_try_again') if 'lang' in locals() else "An error occurred"
            if update.message:
                await update.message.reply_text(f"‚ùå {error_msg}")
            elif 'query' in locals():
                await query.edit_message_text(f"‚ùå {error_msg}")

    @staticmethod
    async def set_language_callback(update: Update, context: CallbackContext):
        try:
            query = update.callback_query
            await query.answer()
            lang_code = query.data.split("_")[1]
            user_id = query.from_user.id
            
            db.set_user_language(user_id, lang_code)
            
            lang_names = {
                'fr': "Fran√ßais",
                'en': "English",
                'es': "Espa√±ol", 
                'de': "Deutsch",
                'zh': "‰∏≠Êñá",
                'hi': "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä",
                'ja': "Êó•Êú¨Ë™û",
                'ko': "ÌïúÍµ≠Ïñ¥",
                'th': "‡πÑ‡∏ó‡∏¢",
                'ru': "–†—É—Å—Å–∫–∏–π",
                'pt': "Portugu√™s",
                'it': "Italiano",
                'ar': "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
                'tr': "T√ºrk√ße",
                'vi': "Ti·∫øng Vi·ªát",
                'pl': "Polski",
                'nl': "Nederlands",
                'sv': "Svenska",
                'uk': "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
                'sw': "Kiswahili",
                'he': "◊¢◊ë◊®◊ô◊™",
                'ro': "Rom√¢nƒÉ",
                'fa': "ŸÅÿßÿ±ÿ≥€å",
                'ms': "Bahasa Melayu",
                'id': "Bahasa Indonesia",
                'cs': "ƒåe≈°tina",
                'da': "Dansk",
                'fi': "Suomi",
                'hu': "Magyar"
            }
                
            lang_name = lang_names.get(lang_code, lang_code)
            confirmation = f"{get_text(lang_code, 'language_changed')} ({lang_name})"
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    f"‚úÖ {get_text(lang_code, 'begin_button')}",
                    callback_data="terms_accepted"
                )]
            ])
            
            await query.edit_message_text(confirmation, reply_markup=keyboard)
        except Exception as e:
            logger.error(f"Error in set_language_callback: {e}")
            await query.edit_message_text("‚ùå Language change error")

    # Fonction terms_declined ajout√©e
    @staticmethod
    async def terms_declined(update: Update, context: CallbackContext):
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        text = get_text(lang, 'terms_declined')
        await query.edit_message_text(text)

    @staticmethod
    async def accept_terms(update: Update, context: CallbackContext):
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            if lang == 'fr':
                terms_text = (
                    "üìú <b>Conditions d'utilisation</b>\n\n"
                    "1. Confidentialit√© : Vos donn√©es sont crypt√©es\n"
                    "2. Utilisation : Interdiction de spam\n"
                    "3. S√©curit√© : Ne partagez pas vos tokens\n\n"
                    "En continuant, vous acceptez nos conditions."
                )
            else:
                terms_text = (
                    "üìú <b>Terms of Service</b>\n\n"
                    "1. Privacy: Your data is encrypted\n"
                    "2. Usage: No spamming allowed\n"
                    "3. Security: Don't share your tokens\n\n"
                    "By continuing, you accept our terms."
                )
        
            keyboard = [
                [InlineKeyboardButton("‚úÖ J'accepte" if lang == 'fr' else "‚úÖ I Accept", 
                                    callback_data="terms_accepted")],
                [InlineKeyboardButton("‚ùå Refuser" if lang == 'fr' else "‚ùå Decline", 
                                    callback_data="terms_declined")]
            ]
            
            await query.edit_message_text(terms_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
        except Exception as e:
            logger.error(f"Erreur dans accept_terms: {e} [ERR_BLM_007]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_007)")

    @staticmethod
    async def terms_accepted(update: Update, context: CallbackContext):
        try:
            query = update.callback_query
            await query.answer()
            db.save_terms_acceptance(query.from_user.id)
            await show_main_menu(update, context)
        except Exception as e:
            logger.error(f"Erreur dans terms_accepted: {e} [ERR_BLM_008]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_008)")

    @staticmethod
    async def start_bot_creation(update: Update, context: CallbackContext):
        try:
            if update.message:
                user_id = update.message.from_user.id
                lang = db.get_user_language(user_id) or 'fr'
            else:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                lang = db.get_user_language(user_id) or 'fr'
            
            if lang == 'fr':
                text = "ü§ñ Cr√©ation de votre bot personnel\n\nAvez-vous d√©j√† un bot Telegram existant ?"
            else:
                text = "ü§ñ Creating your bot assistant\n\nDo you already have an existing Telegram bot?"
            
            if update.message:
                await update.message.reply_text(text, reply_markup=KeyboardManager.bot_creation_options(lang))
            else:
                await query.edit_message_text(text, reply_markup=KeyboardManager.bot_creation_options(lang))
        except Exception as e:
            logger.error(f"Erreur dans start_bot_creation: {e} [ERR_BLM_009]", exc_info=True)
            if update.callback_query:
                await update.callback_query.message.reply_text("‚ùå Erreur lors du d√©marrage. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_009)")
            else:
                await update.message.reply_text("‚ùå Erreur lors du d√©marrage. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_009)")

    @staticmethod
    async def handle_has_token_yes(update: Update, context: CallbackContext):
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'

            if lang == 'fr':
                security_advice = (
                    "üîê Conseil de s√©curit√© :\n"
                    "1. Ne partagez jamais votre token publiquement\n"
                    "2. Utilisez /revoke dans @BotFather si compromis\n"
                    "3. Notre syst√®me le chiffrera automatiquement"
                )
                prompt = "Parfait ! Veuillez m'envoyer votre token :"
            else:
                security_advice = (
                    "üîê Security advice:\n"
                    "1. Never share your token publicly\n"
                    "2. Use /revoke in @BotFather if compromised\n"
                    "3. Our system will encrypt it automatically"
                )
                prompt = "Perfect! Please send me your token:"
                
            await query.edit_message_text(f"‚úÖ {prompt}\n\n{security_advice}", parse_mode="Markdown")
            context.user_data["awaiting_token"] = True
        except Exception as e:
            logger.error(f"Erreur dans handle_has_token_yes: {e} [ERR_BLM_010]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_010)")

    @staticmethod
    async def handle_has_token_no(update: Update, context: CallbackContext):
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'

            if lang == 'fr':
                creation_guide = (
                    "‚öôÔ∏è Cr√©ation de votre premier bot :\n\n"
                    "1. Ouvrez @BotFather\n"
                    "2. Envoyez /newbot\n"
                    "3. Suivez les instructions\n"
                    "4. Copiez le token g√©n√©r√©\n\n"
                    "‚ö†Ô∏è Consignes de s√©curit√© :\n"
                    "- Ne partagez JAMAIS ce token\n"
                    "- Changez-le imm√©diatement si compromis\n"
                    "- Notre syst√®me le chiffrera automatiquement\n\n"
                )
            else:
                creation_guide = (
                    "‚öôÔ∏è Creating your first bot:\n\n"
                    "1. Open @BotFather\n"
                    "2. Send /newbot\n"
                    "3. Follow the instructions\n"
                    "4. Copy the generated token\n\n"
                    "‚ö†Ô∏è Security guidelines:\n"
                    "- NEVER share this token\n"
                    "- Change it immediately if compromised\n"
                    "- Our system will encrypt it automatically\n\n"
                )

            await query.edit_message_text(creation_guide, parse_mode="Markdown")
            context.user_data["awaiting_token"] = True
        except Exception as e:
            logger.error(f"Erreur dans handle_has_token_no: {e} [ERR_BLM_011]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_011)")

    @staticmethod
    async def handle_token_input(update: Update, context: CallbackContext):
        if not context.user_data.get("awaiting_token"):
            return

        try:
            token = update.message.text.strip()
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'

            bot_data = sync_validate_bot_token(token)
            if not bot_data:
                error_msg = "‚ùå Token invalide. Veuillez v√©rifier et r√©essayer." if lang == 'fr' else "‚ùå Invalid token. Please try again."
                await update.message.reply_text(error_msg)
                return

            bot_username = bot_data.get("username")
            bot_name = bot_data.get("first_name")
            
            bot_link = f"https://t.me/{bot_username}"
            creation_time = datetime.now().isoformat()
            db.save_user_bot(user_id, token, bot_username, bot_name, creation_time)

            try:
                child_app = init_child_bot(token, bot_username)
                if child_app:
                    from utils.user_features import setup_user_bot_handlers
                    await setup_user_bot_handlers(child_app)                    
                    import asyncio
                    await child_app.initialize()
                    await child_app.start()
                    asyncio.create_task(child_app.updater.start_polling())
            
                if lang == 'fr':
                    success_text = (
                        f"‚úÖ Bot @{bot_username} connect√© avec succ√®s !\n\n"
                        f"Vous pouvez maintenant utiliser votre bot : {bot_link}\n\n"
                        f"N'oubliez pas de consulter votre plan pour les limites et fonctionnalit√©s : /planinfo"
                    )
                else:
                    success_text = (
                        f"‚úÖ Bot @{bot_username} successfully connected!\n\n"
                        f"You can now use your bot: {bot_link}\n\n"
                        f"Don't forget to check your plan for limits and features: /planinfo"
                    )
                
                keyboard = InlineKeyboardMarkup([
                    [
                        InlineKeyboardButton("ü§ñ Aller √† votre bot" if lang == 'fr' else "ü§ñ Go to your bot", url=bot_link),
                        InlineKeyboardButton("üìä Mon plan" if lang == 'fr' else "üìä My plan", callback_data="show_plan_info")
                    ]
                ])

                await update.message.reply_text(success_text, reply_markup=keyboard, parse_mode="HTML")
                context.user_data["awaiting_token"] = False

            except Exception as e:
                logger.error(f"Erreur lors du lancement du bot enfant: {e}")
                await update.message.reply_text(f"‚ùå Erreur lors du lancement du bot enfant: {e}")

        except Exception as e:
            logger.error(f"ERREUR: {str(e)}", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors du traitement")
            context.user_data["awaiting_token"] = False

    # ... (continuer avec les autres m√©thodes en suivant le m√™me mod√®le)
    
    @staticmethod
    async def log_violation(vtype: str, user_id: int, plan: str, context: CallbackContext):
        """Journalise les violations de limites"""
        try:
            pdg = db.pdg_config
            if not pdg or not pdg.get("is_active"):
                return
                
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_text = f"[{vtype}] {now} ‚Äî <code>{user_id}</code> d√©passement ({plan})"
            if pdg:
                # Ensure the main bot sends the message to the PDG owner
                await context.bot.send_message(pdg["owner"], log_text, parse_mode="HTML")
                if pdg.get("log_channel"):
                    # Ensure the main bot sends the message to the log channel
                    await context.bot.send_message(pdg["log_channel"], log_text, parse_mode="HTML")
                    db.setdefault("log_archive", []).append({
                        "type": vtype,
                        "timestamp": now,
                        "user_id": user_id,
                        "plan": plan
                    })
        except Exception as e:
            logger.error(f"Erreur dans log_violation: {e} [ERR_BLM_016]", exc_info=True)

    @staticmethod
    async def handle_services(update: Update, context: CallbackContext):
        """G√®re le bouton üõ†Ô∏è Services et la commande /services"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            else:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            if lang == 'fr':
                text = "üõ†Ô∏è <b>Services disponibles</b> :"
            else:
                text = "üõ†Ô∏è <b>Available Services</b>:"
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ü§ñ Mes bots cr√©√©s ü§ñ", callback_data="my_bots")],
                [InlineKeyboardButton("üîç Recherche avanc√©e", callback_data="services_search")],
                [InlineKeyboardButton("‚ù§Ô∏è Groupe de rencontre üë©‚Äç‚ù§Ô∏è‚Äçüë®", callback_data="services_meetup")],
                [InlineKeyboardButton("üîÑ Change format fichier üìÅ", callback_data="services_format")],
                [InlineKeyboardButton("üìù Texte vers voixüéôÔ∏è", callback_data="services_tts")],
                [InlineKeyboardButton("üéôÔ∏è Voix vers texte üìù", callback_data="services_stt")],
                [InlineKeyboardButton("üì¢ Cr√©er un post üì¢", callback_data="services_post")],
                [InlineKeyboardButton("üìä Cr√©√© un sondage üìä", callback_data="services_poll")],
                [InlineKeyboardButton("üîó Cr√©e un lien court üîó", callback_data="services_shortlink")],
                [InlineKeyboardButton("üöÄ Cr√©√© une publicit√© üöÄ", callback_data="services_ads")],
                [InlineKeyboardButton("ü§ë Investissement intelligent ü§ë", callback_data="services_investment")],
                [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
            ])
            
            if update.message:
                await update.message.reply_text(text, parse_mode="HTML", reply_markup=keyboard)
            else:
                await query.edit_message_text(text, parse_mode="HTML", reply_markup=keyboard)
                
        except Exception as e:
            logger.error(f"Erreur dans handle_services: {e} [ERR_BLM_017]", exc_info=True)
            if update.callback_query:
                await update.callback_query.message.reply_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_017)")
            else:
                await update.message.reply_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_017)")

    @staticmethod
    async def handle_service_submenu(update: Update, context: CallbackContext):
        """G√®re les sous-menus des services"""
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        
        if lang == 'fr':
            text = "üöß Fonctionnalit√© en cours de construction"
        else:
            text = "üöß Feature under construction"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîô Retour" if lang == 'fr' else "üîô Back", callback_data="back_to_services")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)

    @staticmethod
    async def handle_back_to_services(update: Update, context: CallbackContext):
        """Retour au menu des services"""
        query = update.callback_query
        await query.answer()
        await BotLinkingManager.handle_services(update, context)

    @staticmethod
    async def handle_help_command(update: Update, context: CallbackContext):
        """G√®re le bouton 'Aide'"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            else:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'

            if lang == 'fr':
                help_text = (
                "üÜò <b>Aide TeleSucheBot</b>\n\n"
                "<b>Fonctionnalit√©s principales :</b>\n"
                "‚Ä¢ ‚öôÔ∏è Cloner votre bot : Cr√©ez votre propre assistant\n"
                "‚Ä¢ ü§ù Communaut√© : Rejoignez nos canaux et groupes\n"
                "‚Ä¢ üõ†Ô∏è Services : Acc√©dez √† nos outils avanc√©s\n\n"
                "<b>Support technique :</b>\n"
                "üëâ @TeleSucheSupport\n"
                "üì¨ support@telesuche.com\n\n"
                "<b>Documentation :</b>\n"
                "üåê https://docs.telesuche.com"
            )
            else:
                help_text = (
                "üÜò <b>TeleSucheBot Help</b>\n\n"
                "<b>Main features:</b>\n"
                "‚Ä¢ ‚öôÔ∏è Clone your bot: Create your personal assistant\n"
                "‚Ä¢ ü§ù Community: Join our channels and groups\n"
                "‚Ä¢ üõ†Ô∏è Services: Access our advanced tools\n\n"
                "<b>Technical support:</b>\n"
                "üëâ @TeleSucheSupport\n"
                "üì¨ support@telesuche.com\n\n"
                "<b>Documentation :</b>\n"
                "üåê https://docs.telesuche.com"
            )
            
            if update.message:
                await update.message.reply_text(help_text, parse_mode="HTML")
            else:
                await query.edit_message_text(
                help_text,
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîô Retour" if lang == 'fr' else "üîô Back", callback_data='back_to_main')]
                ])
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_help_command: {e}", exc_info=True)

    @staticmethod
    async def handle_upgrade_plan(update: Update, context: CallbackContext):
        """Affiche les options de mise √† niveau"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            if lang == 'fr':
                text = "üíé <b>Choisissez un plan</b>\n\n"
            else:
                text = "üíé <b>Choose a plan</b>\n\n"
            
            keyboard = []
            for plan_id, plan_data in PLANS.items():
                features_text = "\n".join([f"‚Ä¢ {f}" for f in plan_data["features"]])
                text += (
                    f"{plan_data['label']} ({plan_data['price']})\n"
                    f"{features_text}\n\n"
                )
                keyboard.append([
                    InlineKeyboardButton(
                        f"{plan_data['label']} - {plan_data['price']}",
                        callback_data=f"plan_details:{plan_id}"
                    )
                ])
            
            keyboard.append([
                InlineKeyboardButton("üîô Retour", callback_data="back_to_main")
            ])

            await query.edit_message_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML"
            )
            
        except Exception as e:
            logger.error(f"Erreur dans handle_upgrade_plan: {e} [ERR_BLM_018]", exc_info=True)
            if lang == 'fr':
                error_msg = "‚ùå Erreur d'affichage des plans. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_018)"
            else:
                error_msg = "‚ùå Error displaying plans. Contact support (@TeleSucheSupport) if the problem persists. (ERR_BLM_018)"
            await query.edit_message_text(error_msg)

    @staticmethod
    async def handle_confirm_upgrade(update: Update, context: CallbackContext):
        """Confirmation finale de l'upgrade"""
        try:
            query = update.callback_query
        await query.answer()
        plan_id = query.data.split(":")[1]
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'

        # Ici vous devriez int√©grer votre logique de paiement
        # Pour l'exemple, nous supposons que le paiement est valid√©
        payment_processor = PaymentProcessor()
        # Supposons que le plan a un prix et une devise associ√©s dans PLANS
        plan_price = PLANS[plan_id].get("price_value", 0.0) # Assurez-vous que PLANS contient 'price_value'
        plan_currency = PLANS[plan_id].get("currency", "USD") # Assurez-vous que PLANS contient 'currency'

        if await payment_processor.process_payment(user_id, plan_price, plan_currency, plan_id):
            db.set_user_plan(user_id, plan_id)
            if lang == 'fr':
                await query.edit_message_text("üéâ F√©licitations ! Votre compte a √©t√© upgrad√©.")
            else:
                await query.edit_message_text("üéâ Congratulations! Your account has been upgraded.")
            # Envoyer un message avec les nouvelles limites
            await BotLinkingManager.show_plan_info(update, context)
        else:
            if lang == 'fr':
                await query.edit_message_text("‚ùå √âchec du paiement. Veuillez r√©essayer.")
            else:
                await query.edit_message_text("‚ùå Payment failed. Please try again.")

    except Exception as e:
        logger.error(f"Erreur dans handle_confirm_upgrade: {e} [ERR_BLM_019]", exc_info=True)
        if lang == 'fr':
            error_msg = "‚ùå Erreur lors de la mise √† niveau. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_019)"
        else:
            error_msg = "‚ùå Upgrade error. Contact support (@TeleSucheSupport) if the problem persists. (ERR_BLM_019)"
        await query.edit_message_text(error_msg)

    @staticmethod
    async def show_plan_info(update: Update, context: CallbackContext):
    """Affiche les informations du plan actuel"""
    try:
        if update.message:
            user_id = update.message.from_user.id
        else:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            
        lang = db.get_user_language(user_id) or 'fr'
        plan = get_user_plan(user_id)
        plan_data = PLANS.get(plan, PLANS["free"])
        plan_limits = get_plan_limits(plan)
        
        user_bots = db.get_user_bots(user_id)
        bot_count = len(user_bots)
        
        if lang == 'fr':
            text = (
                f"üíé <b>Plan actuel : {plan_data['label']}</b>\n\n"
                f"üìä <b>Utilisation :</b>\n"
                f"‚Ä¢ Bots : {bot_count}/{plan_limits['bots']}\n"
                f"‚Ä¢ Groupes : 0/{plan_limits['groups']}\n\n"
                f"<b>Fonctionnalit√©s :</b>\n"
            )
        else:
            text = (
                f"üíé <b>Current plan: {plan_data['label']}</b>\n\n"
                f"üìä <b>Usage:</b>\n"
                f"‚Ä¢ Bots: {bot_count}/{plan_limits['bots']}\n"
                f"‚Ä¢ Groups: 0/{plan_limits['groups']}\n\n"
                f"<b>Features:</b>\n"
            )
        
        for feature in plan_data["features"]:
            text += f"‚Ä¢ {feature}\n"
            
        if plan == "free":
            if lang == 'fr':
                text += f"\nüí° <b>Upgradez pour plus de fonctionnalit√©s !</b>"
            else:
                text += f"\nüí° <b>Upgrade for more features!</b>"
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üöÄ Upgrade", callback_data="upgrade_plan")],
                [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
            ])
        else:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
            ])
        
        if update.message:
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
    except Exception as e:
        logger.error(f"Erreur dans show_plan_info: {e} [ERR_BLM_020]", exc_info=True)

    @staticmethod
    async def handle_community(update: Update, context: CallbackContext):
    """G√®re le bouton 'Communaut√©'"""
    try:
        if update.message:
            user_id = update.message.from_user.id
        else:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            
        lang = db.get_user_language(user_id) or 'fr'
        
        if lang == 'fr':
            text = (
                "ü§ù <b>Rejoignez notre communaut√© !</b>\n\n"
                "Connectez-vous avec d'autres utilisateurs, partagez vos exp√©riences et obtenez de l'aide."
            )
        else:
            text = (
                "ü§ù <b>Join our community!</b>\n\n"
                "Connect with other users, share experiences and get help."
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì¢ Canal officiel", url="https://t.me/TeleSucheChannel")],
            [InlineKeyboardButton("üí¨ Groupe de discussion", url="https://t.me/TeleSucheGroup")],
            [InlineKeyboardButton("üÜò Support technique", url="https://t.me/TeleSucheSupport")],
            [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
        ])
        
        if update.message:
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
    except Exception as e:
        logger.error(f"Erreur dans handle_community: {e} [ERR_BLM_021]", exc_info=True)

    @staticmethod
    async def handle_delete_bot_command(update: Update, context: CallbackContext):
    """G√®re la commande de suppression de bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        
        # Extraire l'ID du bot depuis le callback_data
        bot_id = query.data.split(":")[1]
        
        # R√©cup√©rer les informations du bot
        user_bots = db.get_user_bots(user_id)
        selected_bot = None
        for bot in user_bots:
            if bot.get("bot_username") == bot_id or str(bot.get("id", "")) == bot_id:
                selected_bot = bot
                break
                
        if not selected_bot:
            if lang == 'fr':
                await query.edit_message_text("‚ùå Bot non trouv√©")
            else:
                await query.edit_message_text("‚ùå Bot not found")
            return
            
        bot_username = selected_bot.get("bot_username", "Unknown")
        
        if lang == 'fr':
            text = (
                f"‚ö†Ô∏è <b>Supprimer le bot</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"Cette action est irr√©versible. √ätes-vous s√ªr ?"
            )
        else:
            text = (
                f"‚ö†Ô∏è <b>Delete bot</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"This action is irreversible. Are you sure?"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(
                "‚úÖ Oui, supprimer" if lang == 'fr' else "‚úÖ Yes, delete",
                callback_data=f"confirm_delete:{bot_id}"
            )],
            [InlineKeyboardButton(
                "‚ùå Annuler" if lang == 'fr' else "‚ùå Cancel",
                callback_data="my_bots"
            )]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"Erreur dans handle_delete_bot_command: {e} [ERR_BLM_022]", exc_info=True)

    @staticmethod
async def handle_final_delete_confirmation(update: Update, context: CallbackContext):
    """Confirmation finale pour supprimer un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        
        bot_id = query.data.split(":")[1]
        
        # Supprimer le bot de la base de donn√©es
        success = db.delete_user_bot(user_id, bot_id)
        
        if success:
            # Arr√™ter le bot s'il est en cours d'ex√©cution
            if bot_id in child_bots:
                try:
                    app = child_bots[bot_id]
                    await app.stop()
                    del child_bots[bot_id]
                except Exception as e:
                    logger.error(f"Erreur arr√™t bot {bot_id}: {e}")
            
            if lang == 'fr':
                text = f"‚úÖ Bot supprim√© avec succ√®s !"
            else:
                text = f"‚úÖ Bot deleted successfully!"
        else:
            if lang == 'fr':
                text = f"‚ùå Erreur lors de la suppression"
            else:
                text = f"‚ùå Error during deletion"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(
                "üîô Mes bots" if lang == 'fr' else "üîô My bots",
                callback_data="my_bots"
            )]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"Erreur dans handle_final_delete_confirmation: {e} [ERR_BLM_023]", exc_info=True)

    @staticmethod
async def show_bot_token(update: Update, context: CallbackContext):
    """Affiche le token du bot."""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        user_bots = db.get_user_bots(user_id)
        selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

        if not selected_bot:
            await query.edit_message_text(get_text(lang, 'bot_not_found'))
            return

        bot_token = selected_bot.get("token", "N/A")

        text = f"<b>{get_text(lang, 'bot_token')}</b>\n\n<code>{bot_token}</code>"
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_to_bot_info'), callback_data=f"show_bot_info:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans show_bot_token: {e} [ERR_BLM_038]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_038)")

    @staticmethod
async def handle_under_construction(update: Update, context: CallbackContext):
    """G√®re les boutons 'En cours de construction !'"""
    query = update.callback_query
    await query.answer()
    lang = db.get_user_language(query.from_user.id) or 'fr'
    
    text = "üöß Fonctionnalit√© en cours de construction" if lang == 'fr' else "üöß Feature under construction"
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
    ])
    
    await query.edit_message_text(text, reply_markup=keyboard)

    @staticmethod
    async def show_bot_info(update: Update, context: CallbackContext):
    """Affiche les informations d√©taill√©es du bot."""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        user_bots = db.get_user_bots(user_id)
        selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

        if not selected_bot:
            await query.edit_message_text(get_text(lang, 'bot_not_found'))
            return

        bot_name = selected_bot.get("bot_name", "N/A")
        creation_time = selected_bot.get("creation_time", "N/A")
        
        # Formatage de la date de cr√©ation
        if creation_time != "N/A":
            try:
                dt = datetime.fromisoformat(creation_time)
                creation_date = dt.strftime("%Y-%m-%d")
                creation_time_formatted = dt.strftime("%H:%M:%S")
            except:
                creation_date = "2025-07-21"
                creation_time_formatted = "17:33:59"
        else:
            creation_date = "2025-07-21"
            creation_time_formatted = "17:33:59"

        if lang == 'fr':
            text = (
                f"<b>{get_text(lang, 'bot_info_title')}</b>\n\n"
                f"<b>Nom</b> : {bot_name}\n"
                f"<b>Username</b> : @{bot_username}\n"
                f"<b>ID</b> : N/A\n"
                f"<b>Date de cr√©ation</b> : \n"
                f"  ‚îúüìÜ {creation_date} \n"
                f"  ‚îîüïë{creation_time_formatted}.\n\n"
                f"<b>Statistiques</b>\n\n"
                f"{get_text(lang, 'earnings')}\n"
                f"  ‚îú {get_text(lang, 'total')} 565.00‚Ç¨\n"
                f"  ‚îú {get_text(lang, 'withdrawn')} 16.00‚Ç¨\n"
                f"  ‚îî {get_text(lang, 'pending')} 100.00‚Ç¨\n\n"
                f"  {get_text(lang, 'users')}\n"
                f"  ‚îú {get_text(lang, 'total_users')} 300600\n"
                f"  ‚îú {get_text(lang, 'active')} 240000\n"
                f"  ‚îî {get_text(lang, 'inactive')} 60000\n\n"
                f"  {get_text(lang, 'community')}\n"
                f"  ‚îú {get_text(lang, 'active_groups')} 50\n"
                f"  ‚îî {get_text(lang, 'active_channels')} 75\n\n"
                f"  {get_text(lang, 'monetization')}\n"
                f"  ‚îî {get_text(lang, 'monetization_active')}\n\n"
                f"   {get_text(lang, 'files')} : \n"
                f"  ‚îî 2.500.000 fichiers\n\n"
                f"------\n"
                f"{get_text(lang, 'bot_token_security')}"
            )
        else:
            text = (
                f"<b>{get_text(lang, 'bot_info_title')}</b>\n\n"
                f"<b>Name</b> : {bot_name}\n"
                f"<b>Username</b> : @{bot_username}\n"
                f"<b>ID</b> : N/A\n"
                f"<b>Creation date</b> : \n"
                f"  ‚îúüìÜ {creation_date} \n"
                f"  ‚îîüïë{creation_time_formatted}.\n\n"
                f"<b>Statistics</b>\n\n"
                f"{get_text(lang, 'earnings')}\n"
                f"  ‚îú {get_text(lang, 'total')} 565.00‚Ç¨\n"
                f"  ‚îú {get_text(lang, 'withdrawn')} 16.00‚Ç¨\n"
                f"  ‚îî {get_text(lang, 'pending')} 100.00‚Ç¨\n\n"
                f"  {get_text(lang, 'users')}\n"
                f"  ‚îú {get_text(lang, 'total_users')} 300600\n"
                f"  ‚îú {get_text(lang, 'active')} 240000\n"
                f"  ‚îî {get_text(lang, 'inactive')} 60000\n\n"
                f"  {get_text(lang, 'community')}\n"
                f"  ‚îú {get_text(lang, 'active_groups')} 50\n"
                f"  ‚îî {get_text(lang, 'active_channels')} 75\n\n"
                f"  {get_text(lang, 'monetization')}\n"
                f"  ‚îî {get_text(lang, 'monetization_active')}\n\n"
                f"   {get_text(lang, 'files')} : \n"
                f"  ‚îî 2,500,000 files\n\n"
                f"------\n"
                f"{get_text(lang, 'bot_token_security')}"
            )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'view_bot_token'), callback_data=f"show_token:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'delete_bot'), callback_data=f"ask_delete_bot:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'invite_admin'), callback_data="under_construction")],
            [InlineKeyboardButton(get_text(lang, 'general_report'), callback_data="under_construction")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans show_bot_info: {e} [ERR_BLM_039]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_039)")

    @staticmethod
async def handle_my_bots(update: Update, context: CallbackContext):
    """G√®re la commande /mybots pour afficher les bots de l'utilisateur"""
    try:
        if update.message:
            user_id = update.message.from_user.id
        else:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            
        lang = db.get_user_language(user_id) or 'fr'
        user_bots = db.get_user_bots(user_id)
        
        if not user_bots:
            text = get_text(lang, 'no_bots_connected')
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'create_bot'), callback_data="createbot")]
            ])
        else:
            text = get_text(lang, 'your_connected_bots')
            keyboard_buttons = []
            
            for bot in user_bots:
                bot_username = bot.get("bot_username")
                bot_name = bot.get("bot_name")
                if bot_username and bot_name:
                    keyboard_buttons.append([
                        InlineKeyboardButton(f"{get_text(lang, 'bot_prefix')}{bot_username}", callback_data=f"bot_detail:{bot_username}")
                    ])
            
            keyboard_buttons.append([
                InlineKeyboardButton(get_text(lang, 'add_bot'), callback_data="createbot"),
                InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="back_to_main")
            ])
            keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        if update.message:
            await update.message.reply_text(text, reply_markup=keyboard)
        else:
            await query.edit_message_text(text, reply_markup=keyboard)
            
    except Exception as e:
        logger.error(f"Erreur dans handle_my_bots: {e} [ERR_BLM_001]", exc_info=True)
        error_text = f"{get_text(lang, 'error_try_again')} (ERR_BLM_001)"
        if update.message:
            await update.message.reply_text(error_text)
        else:
            await query.edit_message_text(error_text)

    @staticmethod
async def handle_createbot(update: Update, context: CallbackContext):
    """G√®re le processus de cr√©ation d'un nouveau bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'

        # V√©rifier les limites de bots
        if not await check_bot_limits(user_id):
            text = get_text(lang, 'bot_limit_exceeded')
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'upgrade_plan'), callback_data="upgrade_plan")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
            ])
            await query.edit_message_text(text, reply_markup=keyboard)
            return

        # Demander le token du bot
        if lang == 'fr':
            text = (
                f"<b>{get_text(lang, 'add_bot_token')}</b>\n\n"
                f"{get_text(lang, 'enter_token')}\n\n"
                f"<i>{get_text(lang, 'token_format')}</i>"
            )
        else:
            text = (
                f"<b>{get_text(lang, 'add_bot_token')}</b>\n\n"
                f"{get_text(lang, 'enter_token')}\n\n"
                f"<i>{get_text(lang, 'token_format')}</i>"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
        
        # D√©finir l'√©tat utilisateur pour attendre le token
        context.user_data['awaiting_bot_token'] = True
        
    except Exception as e:
        logger.error(f"Erreur dans handle_createbot: {e} [ERR_BLM_002]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_002)")

    @staticmethod
    async def handle_bot_token_input(update: Update, context: CallbackContext):
    """G√®re la saisie du token de bot"""
    try:
        if not context.user_data.get('awaiting_bot_token'):
            return
            
        user_id = update.message.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        token = update.message.text.strip()
        
        # Valider le format du token
        if not token or ':' not in token:
            text = get_text(lang, 'token_invalid')
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
            ])
            await update.message.reply_text(text, reply_markup=keyboard)
            return
        
        # Valider le token avec l'API Telegram
        try:
            bot_info = sync_validate_bot_token(token)
            if not bot_info:
                text = get_text(lang, 'token_validation_error')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
                ])
                await update.message.reply_text(text, reply_markup=keyboard)
                return
                
            bot_username = bot_info.get("username")
            bot_name = bot_info.get("first_name")
            
            # V√©rifier si le bot existe d√©j√†
            user_bots = db.get_user_bots(user_id)
            if any(bot.get("bot_username") == bot_username for bot in user_bots):
                text = get_text(lang, 'bot_already_exists')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
                ])
                await update.message.reply_text(text, reply_markup=keyboard)
                context.user_data['awaiting_bot_token'] = False
                return
            
            # Sauvegarder le bot
            creation_time = datetime.now().isoformat()
            db.save_user_bot(user_id, token, bot_username, bot_name, creation_time)
            
            # Cr√©er l'application bot
            text = get_text(lang, 'creating_bot_app')
            await update.message.reply_text(text)
            
            bot_app = init_child_bot(token, bot_username)
            if bot_app:
                # Message de succ√®s
                success_text = f"‚úÖ {get_text(lang, 'bot_saved_success')}\n\nü§ñ @{bot_username}"
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
                ])
                await update.message.reply_text(success_text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur validation token: {e}")
            text = get_text(lang, 'token_validation_error')
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
            ])
            await update.message.reply_text(text, reply_markup=keyboard)
        
        context.user_data['awaiting_bot_token'] = False
        
    except Exception as e:
        logger.error(f"Erreur dans handle_bot_token_input: {e} [ERR_BLM_003]", exc_info=True)
        await update.message.reply_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_003)")

    @staticmethod
async def ask_delete_bot(update: Update, context: CallbackContext):
    """Demande confirmation pour supprimer un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]
        
        if lang == 'fr':
            text = (
                f"<b>{get_text(lang, 'delete_confirmation')}</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"‚ö†Ô∏è {get_text(lang, 'this_action_irreversible')}"
            )
        else:
            text = (
                f"<b>{get_text(lang, 'delete_confirmation')}</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"‚ö†Ô∏è {get_text(lang, 'this_action_irreversible')}"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'yes_delete'), callback_data=f"confirm_delete_bot:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'no_cancel'), callback_data=f"show_bot_info:{bot_username}")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"Erreur dans ask_delete_bot: {e} [ERR_BLM_004]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_004)")

    @staticmethod
async def confirm_delete_bot(update: Update, context: CallbackContext):
    """Confirme la suppression d'un bot avec d√©lai de 24h"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]
        
        # Programmer la suppression dans 24h
        deletion_time = datetime.now() + timedelta(hours=24)
        
        if lang == 'fr':
            text = (
                f"‚è∞ {get_text(lang, 'delete_scheduled')}\n\n"
                f"ü§ñ @{bot_username}\n"
                f"üïê {deletion_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                f"Vous pouvez annuler cette suppression avant cette date."
            )
        else:
            text = (
                f"‚è∞ {get_text(lang, 'delete_scheduled')}\n\n"
                f"ü§ñ @{bot_username}\n"
                f"üïê {deletion_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                f"You can cancel this deletion before this date."
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'cancel_deletion'), callback_data=f"cancel_delete_bot:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"Erreur dans confirm_delete_bot: {e} [ERR_BLM_005]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_005)")

    @staticmethod
    async def cancel_delete_bot(update: Update, context: CallbackContext):
    """Annule la suppression programm√©e d'un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]
        
        # Annuler la suppression programm√©e
        deletion_key = f"{user_id}:{bot_username}"
        if deletion_key in pending_deletions:
            del pending_deletions[deletion_key]
        
        db.cancel_bot_deletion(user_id, bot_username)
        
        if lang == 'fr':
            text = f"‚úÖ {get_text(lang, 'deletion_cancelled')}\nü§ñ @{bot_username}"
        else:
            text = f"‚úÖ {get_text(lang, 'deletion_cancelled')}\nü§ñ @{bot_username}"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"show_bot_info:{bot_username}")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"Erreur dans cancel_delete_bot: {e} [ERR_BLM_006]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_006)")

    @staticmethod
async def execute_pending_deletions():
    """Ex√©cute les suppressions de bots programm√©es"""
    try:
        current_time = datetime.now()
        to_delete = []
        
        for deletion_key, deletion_time in pending_deletions.items():
            if current_time >= deletion_time:
                user_id, bot_username = deletion_key.split(":")
                user_id = int(user_id)
                
                # Supprimer le bot de la base de donn√©es
                db.delete_user_bot(user_id, bot_username)
                
                # Arr√™ter l'application bot si elle existe
                if bot_username in child_bots:
                    try:
                        app = child_bots[bot_username]
                        await app.stop()
                        del child_bots[bot_username]
                    except Exception as e:
                        logger.error(f"Erreur arr√™t bot {bot_username}: {e}")
                
                to_delete.append(deletion_key)
                logger.info(f"Bot {bot_username} supprim√© pour l'utilisateur {user_id}")
        
        # Nettoyer les suppressions ex√©cut√©es
        for key in to_delete:
            del pending_deletions[key]
            
    except Exception as e:
        logger.error(f"Erreur dans execute_pending_deletions: {e}")

    @staticmethod
async def bot_detail(update: Update, context: CallbackContext):
    """Affiche les d√©tails d'un bot avec options de gestion"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        user_bots = db.get_user_bots(user_id)
        selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

        if not selected_bot:
            await query.edit_message_text(get_text(lang, 'bot_not_found'))
            return

        bot_name = selected_bot.get("bot_name", "N/A")
        bot_status = "üü¢" if bot_username in child_bots else "üî¥"
        
        if lang == 'fr':
            text = (
                f"<b>ü§ñ {bot_name}</b>\n"
                f"<b>Username:</b> @{bot_username}\n"
                f"<b>Status:</b> {bot_status} {get_text(lang, 'bot_status_online' if bot_status == 'üü¢' else 'bot_status_offline')}\n\n"
                f"<b>Gestion:</b>"
            )
        else:
            text = (
                f"<b>ü§ñ {bot_name}</b>\n"
                f"<b>Username:</b> @{bot_username}\n"
                f"<b>Status:</b> {bot_status} {get_text(lang, 'bot_status_online' if bot_status == 'üü¢' else 'bot_status_offline')}\n\n"
                f"<b>Management:</b>"
            )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'bot_info_title'), callback_data=f"show_bot_info:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'start_child_bot'), callback_data=f"start_bot:{bot_username}"),
             InlineKeyboardButton(get_text(lang, 'stop_child_bot'), callback_data=f"stop_bot:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'restart_child_bot'), callback_data=f"restart_bot:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'bot_settings'), callback_data=f"bot_settings:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'bot_analytics'), callback_data=f"bot_analytics:{bot_username}"),
             InlineKeyboardButton(get_text(lang, 'bot_logs'), callback_data=f"bot_logs:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans bot_detail: {e} [ERR_BLM_007]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_007)")

    @staticmethod
async def start_bot(update: Update, context: CallbackContext):
    """D√©marre un bot fils"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        user_bots = db.get_user_bots(user_id)
        selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

        if not selected_bot:
            await query.edit_message_text(get_text(lang, 'bot_not_found'))
            return

        if bot_username not in child_bots:
            token = selected_bot.get("token")
            bot_app = init_child_bot(token, bot_username)
            if bot_app:
                child_bots[bot_username] = bot_app
                try:
                    await bot_app.initialize()
                    await bot_app.start()
                    import asyncio
                    asyncio.create_task(bot_app.updater.start_polling())
                    text = f"‚úÖ {get_text(lang, 'start_bot_success')}\nü§ñ @{bot_username}"
                except Exception as e:
                    logger.error(f"Erreur d√©marrage bot: {e}")
                    text = f"‚ùå {get_text(lang, 'start_bot_error')}\nü§ñ @{bot_username}"
            else:
                text = f"‚ùå {get_text(lang, 'start_bot_error')}\nü§ñ @{bot_username}"
        else:
            text = f"‚ÑπÔ∏è {get_text(lang, 'bot_status_online')}\nü§ñ @{bot_username}"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard)

    except Exception as e:
        logger.error(f"Erreur dans start_bot: {e} [ERR_BLM_008]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_008)")

    @staticmethod
async def stop_bot(update: Update, context: CallbackContext):
    """Arr√™te un bot fils"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        if bot_username in child_bots:
            try:
                app = child_bots[bot_username]
                await app.stop()
                await app.shutdown()
                del child_bots[bot_username]
                text = f"‚úÖ {get_text(lang, 'stop_child_bot')}\nü§ñ @{bot_username}"
            except Exception as e:
                logger.error(f"Erreur arr√™t bot {bot_username}: {e}")
                text = f"‚ùå {get_text(lang, 'start_bot_error')}\nü§ñ @{bot_username}"
        else:
            text = f"‚ÑπÔ∏è {get_text(lang, 'bot_status_offline')}\nü§ñ @{bot_username}"

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard)

    except Exception as e:
        logger.error(f"Erreur dans stop_bot: {e} [ERR_BLM_009]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_009)")

    @staticmethod
    async def restart_bot(update: Update, context: CallbackContext):
    """Red√©marre un bot fils"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        # Arr√™ter le bot s'il est en cours d'ex√©cution
        if bot_username in child_bots:
            try:
                app = child_bots[bot_username]
                await app.stop()
                await app.shutdown()
                del child_bots[bot_username]
            except Exception as e:
                logger.error(f"Erreur arr√™t bot {bot_username}: {e}")

        # Red√©marrer le bot
        user_bots = db.get_user_bots(user_id)
        selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

        if selected_bot:
            token = selected_bot.get("token")
            bot_app = init_child_bot(token, bot_username)
            if bot_app:
                child_bots[bot_username] = bot_app
                try:
                    await bot_app.initialize()
                    await bot_app.start()
                    import asyncio
                    asyncio.create_task(bot_app.updater.start_polling())
                    text = f"‚úÖ {get_text(lang, 'restart_child_bot')}\nü§ñ @{bot_username}"
                except Exception as e:
                    logger.error(f"Erreur d√©marrage bot: {e}")
                    text = f"‚ùå {get_text(lang, 'start_bot_error')}\nü§ñ @{bot_username}"
            else:
                text = f"‚ùå {get_text(lang, 'start_bot_error')}\nü§ñ @{bot_username}"
        else:
            text = f"‚ùå {get_text(lang, 'bot_not_found')}"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard)

    except Exception as e:
        logger.error(f"Erreur dans restart_bot: {e} [ERR_BLM_010]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_010)")

    @staticmethod
    async def bot_settings(update: Update, context: CallbackContext):
    """Affiche les param√®tres d'un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        text = f"<b>‚öôÔ∏è {get_text(lang, 'bot_settings')}</b>\nü§ñ @{bot_username}"

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'group_management'), callback_data=f"group_mgmt:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'welcome_message_setup'), callback_data=f"welcome_setup:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'auto_responses'), callback_data=f"auto_responses:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'user_permissions'), callback_data=f"user_perms:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'notification_settings'), callback_data=f"notifications:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'security_settings'), callback_data=f"security:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'api_settings'), callback_data=f"api_settings:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'webhook_settings'), callback_data=f"webhook:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'backup_restore'), callback_data=f"backup:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans bot_settings: {e} [ERR_BLM_011]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_011)")

    @staticmethod
    async def bot_analytics(update: Update, context: CallbackContext):
    """Affiche les analytiques d'un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        # Statistiques simul√©es
        if lang == 'fr':
            text = (
                f"<b>üìä {get_text(lang, 'bot_analytics')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<b>üìà Derni√®res 24h:</b>\n"
                f"üë• Nouveaux utilisateurs: 156\n"
                f"üí¨ Messages re√ßus: 2,847\n"
                f"üì§ Messages envoy√©s: 3,012\n\n"
                f"<b>üìä Derniers 7 jours:</b>\n"
                f"üë• Utilisateurs actifs: 1,245\n"
                f"üí¨ Total messages: 18,934\n"
                f"‚ö° Temps de r√©ponse moyen: 0.3s\n\n"
                f"<b>üéØ Performance:</b>\n"
                f"‚úÖ Disponibilit√©: 99.8%\n"
                f"üìà Croissance: +12%\n"
                f"‚≠ê Satisfaction: 4.7/5"
            )
        else:
            text = (
                f"<b>üìä {get_text(lang, 'bot_analytics')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<b>üìà Last 24h:</b>\n"
                f"üë• New users: 156\n"
                f"üí¨ Messages received: 2,847\n"
                f"üì§ Messages sent: 3,012\n\n"
                f"<b>üìä Last 7 days:</b>\n"
                f"üë• Active users: 1,245\n"
                f"üí¨ Total messages: 18,934\n"
                f"‚ö° Average response time: 0.3s\n\n"
                f"<b>üéØ Performance:</b>\n"
                f"‚úÖ Availability: 99.8%\n"
                f"üìà Growth: +12%\n"
                f"‚≠ê Satisfaction: 4.7/5"
            )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'data_export'), callback_data=f"export_data:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans bot_analytics: {e} [ERR_BLM_012]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_012)")

    @staticmethod
    async def bot_logs(update: Update, context: CallbackContext):
    """Affiche les journaux d'un bot"""
    try:
        query = update.callback_query
        await query.answer()
        user_id = query.from_user.id
        lang = db.get_user_language(user_id) or 'fr'
        bot_username = query.data.split(":")[1]

        # Logs simul√©s
        if lang == 'fr':
            text = (
                f"<b>üìú {get_text(lang, 'bot_logs')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<code>2025-01-23 14:30:25 [INFO] Bot d√©marr√©</code>\n"
                f"<code>2025-01-23 14:30:26 [INFO] Handlers enregistr√©s</code>\n"
                f"<code>2025-01-23 14:30:27 [INFO] Polling d√©marr√©</code>\n"
                f"<code>2025-01-23 14:35:12 [INFO] Nouveau utilisateur: 123456</code>\n"
                f"<code>2025-01-23 14:36:45 [INFO] Message trait√©: /start</code>\n"
                f"<code>2025-01-23 14:37:23 [WARN] Limite de d√©bit atteinte</code>\n"
                f"<code>2025-01-23 14:38:01 [INFO] Message trait√©: /help</code>\n"
                f"<code>2025-01-23 14:39:15 [ERROR] Erreur API: Timeout</code>\n"
                f"<code>2025-01-23 14:40:22 [INFO] Connexion r√©tablie</code>\n"
            )
        else:
            text = (
                f"<b>üìú {get_text(lang, 'bot_logs')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<code>2025-01-23 14:30:25 [INFO] Bot started</code>\n"
                f"<code>2025-01-23 14:30:26 [INFO] Handlers registered</code>\n"
                f"<code>2025-01-23 14:30:27 [INFO] Polling started</code>\n"
                f"<code>2025-01-23 14:35:12 [INFO] New user: 123456</code>\n"
                f"<code>2025-01-23 14:36:45 [INFO] Message processed: /start</code>\n"
                f"<code>2025-01-23 14:37:23 [WARN] Rate limit reached</code>\n"
                f"<code>2025-01-23 14:38:01 [INFO] Message processed: /help</code>\n"
                f"<code>2025-01-23 14:39:15 [ERROR] API error: Timeout</code>\n"
                f"<code>2025-01-23 14:40:22 [INFO] Connection restored</code>\n"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì• T√©l√©charger logs" if lang == 'fr' else "üì• Download logs", callback_data=f"download_logs:{bot_username}")],
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
        ])

        await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

    except Exception as e:
        logger.error(f"Erreur dans bot_logs: {e} [ERR_BLM_013]", exc_info=True)
        await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_013)")

    @staticmethod
    async def language_selection_menu(update: Update, context: CallbackContext):
    """Affiche le menu de s√©lection de langue"""
    try:
        query = update.callback_query if update.callback_query else None
        if query:
            await query.answer()
            user_id = query.from_user.id
        else:
            user_id = update.message.from_user.id

        current_lang = db.get_user_language(user_id) or 'fr'
        
        text = get_text(current_lang, 'language_selection')
        
        # Cr√©er les boutons de langue
        language_buttons = [
    [InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="set_lang:fr"),
     InlineKeyboardButton("üá¨üáß English", callback_data="set_lang:en"),
     InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="set_lang:es")],
     
    [InlineKeyboardButton("üá©üá™ Deutsch", callback_data="set_lang:de"),
     InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data="set_lang:zh"),
     InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="set_lang:hi")],
     
    [InlineKeyboardButton("üáØüáµ Êó•Êú¨Ë™û", callback_data="set_lang:ja"),
     InlineKeyboardButton("üá∞üá∑ ÌïúÍµ≠Ïñ¥", callback_data="set_lang:ko"),
     InlineKeyboardButton("üáπüá≠ ‡πÑ‡∏ó‡∏¢", callback_data="set_lang:th")],
     
    [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_lang:ru"),
     InlineKeyboardButton("üáµüáπ Portugu√™s", callback_data="set_lang:pt"),
     InlineKeyboardButton("üáÆüáπ Italiano", callback_data="set_lang:it")],
     
    [InlineKeyboardButton("üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data="set_lang:ar"),
     InlineKeyboardButton("üáπüá∑ T√ºrk√ße", callback_data="set_lang:tr"),
     InlineKeyboardButton("üáªüá≥ Ti·∫øng Vi·ªát", callback_data="set_lang:vi")],
     
    [InlineKeyboardButton("üáµüá± Polski", callback_data="set_lang:pl"),
     InlineKeyboardButton("üá≥üá± Nederlands", callback_data="set_lang:nl"),
     InlineKeyboardButton("üá∏üá™ Svenska", callback_data="set_lang:sv")],
     
    [InlineKeyboardButton("üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", callback_data="set_lang:uk"),
     InlineKeyboardButton("üá∞üá™ Kiswahili", callback_data="set_lang:sw"),
     InlineKeyboardButton("üáÆüá± ◊¢◊ë◊®◊ô◊™", callback_data="set_lang:he")],
     
    [InlineKeyboardButton("üá∑üá¥ Rom√¢nƒÉ", callback_data="set_lang:ro"),
     InlineKeyboardButton("üáÆüá∑ ŸÅÿßÿ±ÿ≥€å", callback_data="set_lang:fa"),
     InlineKeyboardButton("üá≤üáæ Bahasa Melayu", callback_data="set_lang:ms")],
     
    [InlineKeyboardButton("üáÆüá© Bahasa Indonesia", callback_data="set_lang:id"),
     InlineKeyboardButton("üá®üáø ƒåe≈°tina", callback_data="set_lang:cs"),
     InlineKeyboardButton("üá©üá∞ Dansk", callback_data="set_lang:da")],
     
    [InlineKeyboardButton("üá´üáÆ Suomi", callback_data="set_lang:fi"),
     InlineKeyboardButton("üá≠üá∫ Magyar", callback_data="set_lang:hu")],
     
    [InlineKeyboardButton(get_text(current_lang, 'back_button'), callback_data="back_to_main")]
]
        
        keyboard = InlineKeyboardMarkup(language_buttons)
        
        if query:
            await query.edit_message_text(text, reply_markup=keyboard)
        else:
            await update.message.reply_text(text, reply_markup=keyboard)
            
    except Exception as e:
        logger.error(f"Erreur dans language_selection_menu: {e} [ERR_BLM_014]", exc_info=True)
        error_text = f"{get_text(current_lang, 'error_try_again')} (ERR_BLM_014)"
        if query:
            await query.edit_message_text(error_text)
        else:
            await update.message.reply_text(error_text)

    @staticmethod
    async def set_language(update: Update, context: CallbackContext):
        """D√©finit la langue de l'utilisateur"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            new_lang = query.data.split(":")[1]
            
            # Sauvegarder la nouvelle langue
            db.set_user_language(user_id, new_lang)
            
            # Message de confirmation
            text = get_text(new_lang, 'language_changed')
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(new_lang, 'back_button'), callback_data="back_to_main")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur dans set_language: {e} [ERR_BLM_015]", exc_info=True)
            await query.edit_message_text(f"‚ùå Error setting language (ERR_BLM_015)")

    @staticmethod  
async def help_command(update: Update, context: CallbackContext):
        """Affiche l'aide et les commandes disponibles"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            else:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            if lang == 'fr':
                text = (
                    f"<b>{get_text(lang, 'bot_manager_title')}</b>\n\n"
                    f"<b>{get_text(lang, 'available_commands')}</b>\n"
                    f"‚Ä¢ {get_text(lang, 'change_language')}\n"
                    f"‚Ä¢ {get_text(lang, 'manage_bots')}\n"
                    f"‚Ä¢ {get_text(lang, 'help_command')}\n\n"
                    f"<b>{get_text(lang, 'current_features')}</b>\n"
                    f"‚Ä¢ {get_text(lang, 'multilingual_support')}\n"
                    f"‚Ä¢ {get_text(lang, 'bot_management')}\n"
                    f"‚Ä¢ {get_text(lang, 'user_preferences')}\n\n"
                    f"<i>{get_text(lang, 'demo_mode')}</i>"
                )
            else:
                text = (
                    f"<b>{get_text(lang, 'bot_manager_title')}</b>\n\n"
                    f"<b>{get_text(lang, 'available_commands')}</b>\n"
                    f"‚Ä¢ {get_text(lang, 'change_language')}\n"
                    f"‚Ä¢ {get_text(lang, 'manage_bots')}\n"
                    f"‚Ä¢ {get_text(lang, 'help_command')}\n\n"
                    f"<b>{get_text(lang, 'current_features')}</b>\n"
                    f"‚Ä¢ {get_text(lang, 'multilingual_support')}\n"
                    f"‚Ä¢ {get_text(lang, 'bot_management')}\n"
                    f"‚Ä¢ {get_text(lang, 'user_preferences')}\n\n"
                    f"<i>{get_text(lang, 'demo_mode')}</i>"
                )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'manage_bots'), callback_data="my_bots")],
                [InlineKeyboardButton(get_text(lang, 'language_selection'), callback_data="language_menu")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="back_to_main")]
            ])
            
            if update.message:
                await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
            else:
                await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
                
        except Exception as e:
            logger.error(f"Erreur dans help_command: {e} [ERR_BLM_016]", exc_info=True)
            error_text = f"{get_text(lang, 'error_try_again')} (ERR_BLM_016)"
            if update.message:
                await update.message.reply_text(error_text)
            else:
                await query.edit_message_text(error_text)

    @staticmethod
async def welcome_message(update: Update, context: CallbackContext):
        """Message de bienvenue pour les nouveaux utilisateurs"""
        try:
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            # Si c'est un nouvel utilisateur, proposer la s√©lection de langue
            if db.is_new_user(user_id):
                text = get_text(lang, 'welcome')
                
                language_buttons = [
    [InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="set_lang:fr"),
     InlineKeyboardButton("üá¨üáß English", callback_data="set_lang:en"),
     InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="set_lang:es")],
     
    [InlineKeyboardButton("üá©üá™ Deutsch", callback_data="set_lang:de"),
     InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data="set_lang:zh"),
     InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="set_lang:hi")],
     
    [InlineKeyboardButton("üáØüáµ Êó•Êú¨Ë™û", callback_data="set_lang:ja"),
     InlineKeyboardButton("üá∞üá∑ ÌïúÍµ≠Ïñ¥", callback_data="set_lang:ko"),
     InlineKeyboardButton("üáπüá≠ ‡πÑ‡∏ó‡∏¢", callback_data="set_lang:th")],
     
    [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_lang:ru"),
     InlineKeyboardButton("üáµüáπ Portugu√™s", callback_data="set_lang:pt"),
     InlineKeyboardButton("üáÆüáπ Italiano", callback_data="set_lang:it")],
     
    [InlineKeyboardButton("üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data="set_lang:ar"),
     InlineKeyboardButton("üáπüá∑ T√ºrk√ße", callback_data="set_lang:tr"),
     InlineKeyboardButton("üáªüá≥ Ti·∫øng Vi·ªát", callback_data="set_lang:vi")],
     
    [InlineKeyboardButton("üáµüá± Polski", callback_data="set_lang:pl"),
     InlineKeyboardButton("üá≥üá± Nederlands", callback_data="set_lang:nl"),
     InlineKeyboardButton("üá∏üá™ Svenska", callback_data="set_lang:sv")],
     
    [InlineKeyboardButton("üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", callback_data="set_lang:uk"),
     InlineKeyboardButton("üá∞üá™ Kiswahili", callback_data="set_lang:sw"),
     InlineKeyboardButton("üáÆüá± ◊¢◊ë◊®◊ô◊™", callback_data="set_lang:he")],
     
    [InlineKeyboardButton("üá∑üá¥ Rom√¢nƒÉ", callback_data="set_lang:ro"),
     InlineKeyboardButton("üáÆüá∑ ŸÅÿßÿ±ÿ≥€å", callback_data="set_lang:fa"),
     InlineKeyboardButton("üá≤üáæ Bahasa Melayu", callback_data="set_lang:ms")],
     
    [InlineKeyboardButton("üáÆüá© Bahasa Indonesia", callback_data="set_lang:id"),
     InlineKeyboardButton("üá®üáø ƒåe≈°tina", callback_data="set_lang:cs"),
     InlineKeyboardButton("üá©üá∞ Dansk", callback_data="set_lang:da")],
     
    [InlineKeyboardButton("üá´üáÆ Suomi", callback_data="set_lang:fi"),
     InlineKeyboardButton("üá≠üá∫ Magyar", callback_data="set_lang:hu")],
     
    [InlineKeyboardButton(get_text(current_lang, 'back_button'), callback_data="back_to_main")]
]
                
                keyboard = InlineKeyboardMarkup(language_buttons)
                await update.message.reply_text(text, reply_markup=keyboard)
            else:
                # Utilisateur existant - menu principal
                await show_main_menu(update, context)
                
        except Exception as e:
            logger.error(f"Erreur dans welcome_message: {e} [ERR_BLM_017]", exc_info=True)
            await update.message.reply_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_017)")

    @staticmethod
async def handle_open_menu(update: Update, context: CallbackContext):
        """Handler pour le bouton 'Ouvrir' du menu principal"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            # R√©utilise la logique de bienvenue
            if db.is_new_user(user_id):
                text = get_text(lang, 'welcome')
                
                language_buttons = [
    [InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="set_lang:fr"),
     InlineKeyboardButton("üá¨üáß English", callback_data="set_lang:en"),
     InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="set_lang:es")],
     
    [InlineKeyboardButton("üá©üá™ Deutsch", callback_data="set_lang:de"),
     InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data="set_lang:zh"),
     InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="set_lang:hi")],
     
    [InlineKeyboardButton("üáØüáµ Êó•Êú¨Ë™û", callback_data="set_lang:ja"),
     InlineKeyboardButton("üá∞üá∑ ÌïúÍµ≠Ïñ¥", callback_data="set_lang:ko"),
     InlineKeyboardButton("üáπüá≠ ‡πÑ‡∏ó‡∏¢", callback_data="set_lang:th")],
     
    [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_lang:ru"),
     InlineKeyboardButton("üáµüáπ Portugu√™s", callback_data="set_lang:pt"),
     InlineKeyboardButton("üáÆüáπ Italiano", callback_data="set_lang:it")],
     
    [InlineKeyboardButton("üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data="set_lang:ar"),
     InlineKeyboardButton("üáπüá∑ T√ºrk√ße", callback_data="set_lang:tr"),
     InlineKeyboardButton("üáªüá≥ Ti·∫øng Vi·ªát", callback_data="set_lang:vi")],
     
    [InlineKeyboardButton("üáµüá± Polski", callback_data="set_lang:pl"),
     InlineKeyboardButton("üá≥üá± Nederlands", callback_data="set_lang:nl"),
     InlineKeyboardButton("üá∏üá™ Svenska", callback_data="set_lang:sv")],
     
    [InlineKeyboardButton("üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞", callback_data="set_lang:uk"),
     InlineKeyboardButton("üá∞üá™ Kiswahili", callback_data="set_lang:sw"),
     InlineKeyboardButton("üáÆüá± ◊¢◊ë◊®◊ô◊™", callback_data="set_lang:he")],
     
    [InlineKeyboardButton("üá∑üá¥ Rom√¢nƒÉ", callback_data="set_lang:ro"),
     InlineKeyboardButton("üáÆüá∑ ŸÅÿßÿ±ÿ≥€å", callback_data="set_lang:fa"),
     InlineKeyboardButton("üá≤üáæ Bahasa Melayu", callback_data="set_lang:ms")],
     
    [InlineKeyboardButton("üáÆüá© Bahasa Indonesia", callback_data="set_lang:id"),
     InlineKeyboardButton("üá®üáø ƒåe≈°tina", callback_data="set_lang:cs"),
     InlineKeyboardButton("üá©üá∞ Dansk", callback_data="set_lang:da")],
     
    [InlineKeyboardButton("üá´üáÆ Suomi", callback_data="set_lang:fi"),
     InlineKeyboardButton("üá≠üá∫ Magyar", callback_data="set_lang:hu")],
     
    [InlineKeyboardButton(get_text(current_lang, 'back_button'), callback_data="back_to_main")]
]
                ]
                
                keyboard = InlineKeyboardMarkup(language_buttons)
                await query.edit_message_text(text, reply_markup=keyboard)
            else:
                # Utilisateur existant - menu principal
                await show_main_menu(update, context)
        except Exception as e:
            logger.error(f"Erreur dans handle_open_menu: {e} [ERR_BLM_018]", exc_info=True)
            await query.edit_message_text(f"‚ùå Erreur. Veuillez r√©essayer. (ERR_BLM_018)")

    @staticmethod
    async def handle_info_menu(update: Update, context: CallbackContext):
        """Handler pour le bouton 'Infos' du menu principal"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            if lang == 'fr':
                info_text = (
                    "ü§ñ <b>TeleSucheBot - Votre assistant multifonction</b>\n\n"
                    "TeleSucheBot est un projet innovant de recherche sur Telegram, con√ßu pour offrir une multitude de services avanc√©s. "
                    "Notre objectif est de fournir un outil polyvalent qui r√©pond √† tous vos besoins en mati√®re de communication, d'automatisation et de gestion de contenu.\n\n"
                    "<b>Fonctionnalit√©s principales :</b>\n"
                    "‚Ä¢ ü§ñ <b>Cr√©ation de bots personnels</b> : Clonez votre propre bot et personnalisez-le selon vos besoins\n"
                    "‚Ä¢ üåê <b>Support multilingue</b> : Disponible dans plus de 20 langues diff√©rentes\n"
                    "‚Ä¢ üîç <b>Recherche avanc√©e</b> : Trouvez des informations rapidement gr√¢ce √† notre moteur de recherche puissant\n"
                    "‚Ä¢ üí¨ <b>Gestion de groupes et de canaux</b> : Outils de mod√©ration et d'analyse complets\n"
                    "‚Ä¢ üìä <b>Statistiques d√©taill√©es</b> : Suivez les performances de vos bots avec des m√©triques pr√©cises\n"
                    "‚Ä¢ üõ†Ô∏è <b>Services divers</b> : Conversion de fichiers, synth√®se vocale, cr√©ation de sondages, et bien plus\n\n"
                    "Ce projet est en constante √©volution, avec de nouvelles fonctionnalit√©s ajout√©es r√©guli√®rement. "
                    "Rejoignez notre communaut√© pour contribuer et b√©n√©ficier des derni√®res avanc√©es !\n\n"
                    "üìö Pour en savoir plus :\n"
                    "üëâ https://telegra.ph/TeleSucheBot-Project-07-26"
                )
            else:
                info_text = (
                    "ü§ñ <b>TeleSucheBot - Your Multifunctional Assistant</b>\n\n"
                    "TeleSucheBot is an innovative research project on Telegram, designed to provide a multitude of advanced services. "
                    "Our goal is to deliver a versatile tool that meets all your communication, automation, and content management needs.\n\n"
                    "<b>Main features:</b>\n"
                    "‚Ä¢ ü§ñ <b>Personal bot creation</b>: Clone your own bot and customize it to your needs\n"
                    "‚Ä¢ üåê <b>Multilingual support</b>: Available in more than 20 languages\n"
                    "‚Ä¢ üîç <b>Advanced search</b>: Find information quickly with our powerful search engine\n"
                    "‚Ä¢ üí¨ <b>Group and channel management</b>: Comprehensive moderation and analytics tools\n"
                    "‚Ä¢ üìä <b>Detailed statistics</b>: Track your bots' performance with precise metrics\n"
                    "‚Ä¢ üõ†Ô∏è <b>Various services</b>: File conversion, text-to-speech, poll creation, and much more\n\n"
                    "This project is constantly evolving, with new features added regularly. "
                    "Join our community to contribute and benefit from the latest advancements!\n\n"
                    "üìö Learn more:\n"
                    "üëâ https://telegra.ph/TeleSucheBot-Project-07-26"
                )
            
            await query.edit_message_text(
                info_text,
                reply_markup=KeyboardManager.info_menu(lang),
                parse_mode="HTML",
                disable_web_page_preview=True
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_info_menu: {e} [ERR_BLM_019]", exc_info=True)
            await query.edit_message_text(f"‚ùå Erreur. Veuillez r√©essayer. (ERR_BLM_019)")

    @staticmethod
async def handle_config_menu(update: Update, context: CallbackContext):
        """Handler pour le bouton 'Config' du menu principal"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            text = "‚öôÔ∏è <b>Configuration de votre compte</b>\n\nChoisissez une option √† modifier :"
            await query.edit_message_text(
                text,
                reply_markup=KeyboardManager.config_menu(lang),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_config_menu: {e} [ERR_BLM_020]", exc_info=True)
            await query.edit_message_text(f"‚ùå Erreur. Veuillez r√©essayer. (ERR_BLM_020)")

    @staticmethod
    async def handle_config_option(update: Update, context: CallbackContext):
        """Handler pour les options de configuration"""
        try:
            query = update.callback_query
            await query.answer()
            option = query.data
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            if option == 'config_name':
                prompt = "Entrez votre nouveau nom :" if lang == 'fr' else "Enter your new name:"
                context.user_data['awaiting_name'] = True
            elif option == 'config_country':
                prompt = "S√©lectionnez votre pays :" if lang == 'fr' else "Select your country:"
                # Impl√©menter la logique de s√©lection de pays
            elif option == 'config_phone':
                prompt = "Partagez votre num√©ro de t√©l√©phone :" if lang == 'fr' else "Share your phone number:"
                context.user_data['awaiting_phone'] = True
            elif option == 'config_location':
                prompt = "Partagez votre localisation :" if lang == 'fr' else "Share your location:"
                context.user_data['awaiting_location'] = True
                
            await query.edit_message_text(prompt)
        except Exception as e:
            logger.error(f"Erreur dans handle_config_option: {e} [ERR_BLM_021]", exc_info=True)
            await query.edit_message_text(f"‚ùå Erreur. Veuillez r√©essayer. (ERR_BLM_021)")
    

def setup_bot_linking_handlers(application: Application):
    application.add_handler(CallbackQueryHandler(BotLinkingManager.show_bot_token, pattern=r"^show_token:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.show_bot_info, pattern=r"^show_bot_info:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_my_bots, pattern=r"^my_bots$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_createbot, pattern=r"^createbot$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.ask_delete_bot, pattern=r"^ask_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.confirm_delete_bot, pattern=r"^confirm_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.cancel_delete_bot, pattern=r"^cancel_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_detail, pattern=r"^bot_detail:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.start_bot, pattern=r"^start_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.stop_bot, pattern=r"^stop_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.restart_bot, pattern=r"^restart_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_settings, pattern=r"^bot_settings:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_analytics, pattern=r"^bot_analytics:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_logs, pattern=r"^bot_logs:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.language_selection_menu, pattern=r"^language_menu$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.set_language, pattern=r"^set_lang:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.help_command, pattern=r"^help$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_under_construction, pattern=r"^under_construction$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_open_menu, pattern="^open_menu$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_info_menu, pattern="^info_menu$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_config_menu, pattern="^config_menu$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_config_option, pattern="^config_"))

    application.add_handler(CommandHandler("start", BotLinkingManager.welcome_message))
    application.add_handler(CommandHandler("mybots", BotLinkingManager.handle_my_bots))
    application.add_handler(CommandHandler("lang", BotLinkingManager.language_selection_menu))
    application.add_handler(CommandHandler("help", BotLinkingManager.help_command))
    
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, BotLinkingManager.handle_token_input))
    
    logger.info("Bot linking handlers configur√©s avec succ√®s")

def setup(application: Application):
    setup_bot_linking_handlers(application)
    logger.info("Handlers de BotLinking configur√©s")

async def cleanup_pending_deletions():
    try:
        await BotLinkingManager.execute_pending_deletions()
    except Exception as e:
        logger.error(f"Erreur cleanup_pending_deletions: {e}")

async def start_bot_linking_system():
    try:
        all_users = db.get_all_users() if hasattr(db, 'get_all_users') else []
        
        for user_id in all_users:
            user_bots = db.get_user_bots(user_id)
            for bot in user_bots:
                bot_username = bot.get("bot_username")
                token = bot.get("token")
                if bot_username and token and bot_username not in child_bots:
                    try:
                        bot_app = init_child_bot(token, bot_username)
                        if bot_app:
                            child_bots[bot_username] = bot_app
                            await bot_app.initialize()
                            await bot_app.start()
                            import asyncio
                            asyncio.create_task(bot_app.updater.start_polling())
                    except Exception as e:
                        logger.error(f"Erreur d√©marrage bot {bot_username}: {e}")
        logger.info(f"Syst√®me de gestion des bots d√©marr√© - {len(child_bots)} bots actifs")
    except Exception as e:
        logger.error(f"Erreur d√©marrage syst√®me bot linking: {e}")

def setup(application: Application):
    """Configure les handlers pour la gestion des bots"""
    setup_bot_linking_handlers(application)
    logger.info("Handlers de BotLinking configur√©s")

async def main():
    try:
        BOT_TOKEN = "YOUR_BOT_TOKEN_HERE"
        
        if BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
            print("‚ö†Ô∏è  Veuillez configurer votre token de bot dans la variable BOT_TOKEN")
            print("üí° Obtenez votre token depuis @BotFather sur Telegram")
            return
        
        application = ApplicationBuilder().token(BOT_TOKEN).build()
        setup_handlers(application)
        await start_bot_linking_system()
        
        print("ü§ñ Bot de gestion d√©marr√©...")
        print("üìä Fonctionnalit√©s disponibles :")
        print("   ‚Ä¢ Gestion de bots multiples")
        print("   ‚Ä¢ Support multilingue")
        print("   ‚Ä¢ Interface intuitive")
        print("   ‚Ä¢ Syst√®me de plans d'abonnement")
        
        await application.run_polling(drop_pending_updates=True)
    except Exception as e:
        logger.error(f"Erreur critique dans main: {e}", exc_info=True)
        print(f"‚ùå Erreur : {e}")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

