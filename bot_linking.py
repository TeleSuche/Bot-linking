# ‚úîÔ∏è Fichier reconstruit avec corrections majeures - g√©n√©r√© par ChatGPT

import logging
logger = logging.getLogger(__name__)
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CallbackContext, CallbackQueryHandler, CommandHandler, MessageHandler, filters, ApplicationBuilder

from typing import Dict
from datetime import datetime, timedelta

from utils.memory_full import db
from utils.api_client import sync_validate_bot_token
from utils.user_features import get_welcome_message
from config import config
from utils.keyboards import KeyboardManager
from utils.menu_utils import show_main_menu
from utils.security import SecurityManager
from handlers.subscriptions import PLANS, get_user_plan, get_plan_limits # Import from subscriptions.py
from modepay import PaymentProcessor

# √âtats utilisateur
from enum import Enum

class UserStates(Enum):
    INITIAL = "initial"
    AWAITING_TOKEN = "awaiting_token"
    SELECTING_LANGUAGE = "selecting_language"

PDG_USER_ID = config.PDG_USER_ID
child_bots: Dict[str, Application] = {}
pending_deletions = {}

bot_stats = {
    "earnings": {
        "total": 565.00,
        "withdrawn": 16.00,
        "pending": 100.00
    },
    "users": {
        "total": 300600,
        "active": 240000,
        "inactive": 60000
    },
    "community": {
        "active_groups": 50,
        "active_channels": 75
    },
    "status": {
        "health": "üü¢",  # üü¢/‚ö´/üî¥
        "monetization": "Active"
    }
}

def init_child_bot(token: str, bot_username: str):
    """Initialise et d√©marre un bot fils avec python-telegram-bot"""
    try:
        application = (
            ApplicationBuilder()
            .token(token)
            .connect_timeout(30)
            .read_timeout(30)
            .pool_timeout(30)
            .build()
        )
        
        # La fonction register_user_bot_handlers est asynchrone et sera appel√©e dans la t√¢che asyncio
        
        return application
    except Exception as e:
        logger.error(f"Erreur initialisation bot fils: {e}")
        return None


async def check_bot_limits(user_id: int) -> bool:
    """V√©rifie si l'utilisateur peut ajouter un nouveau bot"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    # Check for trial period for 'free' plan
    if plan == "free":
        trial_end_date = db.get_user_trial_end_date(user_id)
        if trial_end_date and datetime.now() < datetime.fromisoformat(trial_end_date):
            # During trial, allow up to 10 bots
            if len(user_bots) >= 10:
                return False
        else:
            # After trial, apply plan limits for 'free' plan
            if len(user_bots) >= plan_limits["bots"]:
                return False
    else:
        # For other plans, apply their limits directly
        if len(user_bots) >= plan_limits["bots"]:
            return False
    return True

async def check_group_limits(user_id: int, new_group_id: int = 0) -> bool:
    """V√©rifie les limites de groupes"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    total_groups = sum(len(bot.get("groups", [])) for bot in user_bots)
    if new_group_id > 0:
        total_groups += 1
    
    if total_groups >= plan_limits["groups"]:
        return False
    return True
    def delete_user_bot(self, user_id: int, bot_username: str) -> bool:
        if user_id in self.bots:
            self.bots[user_id] = [bot for bot in self.bots[user_id] 
                                  if bot.get('bot_username') != bot_username]
            return True
        return False
        
    def cancel_bot_deletion(self, user_id: int, bot_username: str):
        # Impl√©mentation simplifi√©e
        pass
        
    def save_terms_acceptance(self, user_id: int):
        if user_id not in self.users:
            self.users[user_id] = {}
        self.users[user_id]['terms_accepted'] = True
        
    def get_user_trial_end_date(self, user_id: int):
        return self.users.get(user_id, {}).get('trial_end_date')

db = SimpleDB()

# Plans d'abonnement simplifi√©s
PLANS = {
    "free": {
        "label": "Gratuit",
        "price": "0‚Ç¨/mois",
        "features": ["1 bot", "Support communautaire"],
        "limits": {"bots": 1, "groups": 5}
    },
    "premium": {
        "label": "Premium",
        "price": "9.99‚Ç¨/mois", 
        "features": ["10 bots", "Support prioritaire", "Analytics"],
        "limits": {"bots": 10, "groups": 50}
    }
}

def get_user_plan(user_id: int) -> str:
    return db.users.get(user_id, {}).get('plan', 'free')

def get_plan_limits(plan: str) -> dict:
    return PLANS.get(plan, PLANS['free'])['limits']

# Validation de token simplifi√©e
def sync_validate_bot_token(token: str) -> dict:
    """Validation simplifi√©e du token (pour d√©monstration)"""
    if ':' in token and len(token) > 20:
        # Simulation d'une validation r√©ussie
        return {
            'username': 'test_bot',
            'first_name': 'Test Bot'
        }
    return None

# Gestionnaire de claviers simplifi√©s
class KeyboardManager:
    @staticmethod
    def bot_creation_options(lang: str):
        return InlineKeyboardMarkup([
            [InlineKeyboardButton(
                "‚úÖ Oui, j'ai un token" if lang == 'fr' else "‚úÖ Yes, I have a token",
                callback_data="has_token_yes"
            )],
            [InlineKeyboardButton(
                "‚ùå Non, cr√©er un bot" if lang == 'fr' else "‚ùå No, create a bot", 
                callback_data="has_token_no"
            )]
        ])

# Menu principal simplifi√©
async def show_main_menu(update: Update, context: CallbackContext):
    """Affiche le menu principal"""
    try:
        if update.message:
            user_id = update.message.from_user.id
        elif update.callback_query:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            
        lang = db.get_user_language(user_id)
        
        text = (
            "ü§ñ <b>TeleSuche Bot Manager</b>\n\n"
            "Bienvenue dans votre gestionnaire de bots Telegram !"
            if lang == 'fr' else
            "ü§ñ <b>TeleSuche Bot Manager</b>\n\n"
            "Welcome to your Telegram bot manager!"
        )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ü§ñ Mes bots", callback_data="my_bots")],
            [InlineKeyboardButton("üåê Langue", callback_data="language_menu")],
            [InlineKeyboardButton("üÜò Aide", callback_data="help")]
        ])
        
        if update.message:
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
    except Exception as e:
        logger.error(f"Erreur dans show_main_menu: {e}")

# Gestionnaire de paiement fictif
class PaymentProcessor:
    async def process_payment(self, user_id: int, amount: float, currency: str, plan_id: str) -> bool:
        # Simulation d'un paiement r√©ussi
        return True

# Dictionnaire des traductions
TRANSLATIONS = {
    'fr': {
        'bot_token': "Token du bot",
        'token_not_found': "Token non trouv√©",
        'bot_not_found': "Bot non trouv√©", 
        'error_try_again': "Erreur, veuillez r√©essayer",
        'back_button': "Retour",
        'cancel': "Annuler",
        'token_invalid': "Token invalide",
        'token_validation_error': "Erreur de validation du token",
        'bot_already_exists': "Ce bot existe d√©j√†",
        'creating_bot_app': "Cr√©ation de l'application bot...",
        'start_bot_success': "Bot d√©marr√© avec succ√®s",
        'start_bot_error': "Erreur lors du d√©marrage du bot",
        'bot_saved_success': "Bot sauvegard√© avec succ√®s",
        'delete_confirmation': "Confirmation de suppression",
        'this_action_irreversible': "Cette action est irr√©versible",
        'yes_delete': "Oui, supprimer",
        'no_cancel': "Non, annuler",
        'delete_scheduled': "Suppression programm√©e",
        'deletion_cancelled': "Suppression annul√©e",
        'cancel_deletion': "Annuler la suppression",
        'bot_info_title': "Informations du bot",
        'start_child_bot': "D√©marrer le bot",
        'stop_child_bot': "Arr√™ter le bot",
        'restart_child_bot': "Red√©marrer le bot",
        'bot_settings': "Param√®tres du bot",
        'bot_analytics': "Analytiques du bot",
        'bot_logs': "Journaux du bot",
        'bot_status_online': "En ligne",
        'bot_status_offline': "Hors ligne",
        'language_selection': "S√©lection de la langue",
        'language_changed': "Langue modifi√©e avec succ√®s",
        'bot_manager_title': "Gestionnaire de bots",
        'available_commands': "Commandes disponibles",
        'change_language': "Changer la langue",
        'manage_bots': "G√©rer les bots",
        'help_command': "Aide",
        'current_features': "Fonctionnalit√©s actuelles",
        'multilingual_support': "Support multilingue",
        'bot_management': "Gestion des bots",
        'user_preferences': "Pr√©f√©rences utilisateur",
        'demo_mode': "Mode d√©mo actif",
        'welcome': "Bienvenue ! Choisissez votre langue :",
        'data_export': "Exporter les donn√©es"
    },
    'en': {
        'bot_token': "Bot token",
        'token_not_found': "Token not found",
        'bot_not_found': "Bot not found",
        'error_try_again': "Error, please try again",
        'back_button': "Back",
        'cancel': "Cancel",
        'token_invalid': "Invalid token",
        'token_validation_error': "Token validation error",
        'bot_already_exists': "This bot already exists",
        'creating_bot_app': "Creating bot application...",
        'start_bot_success': "Bot started successfully",
        'start_bot_error': "Error starting bot",
        'bot_saved_success': "Bot saved successfully",
        'delete_confirmation': "Delete confirmation",
        'this_action_irreversible': "This action is irreversible",
        'yes_delete': "Yes, delete",
        'no_cancel': "No, cancel",
        'delete_scheduled': "Deletion scheduled",
        'deletion_cancelled': "Deletion cancelled",
        'cancel_deletion': "Cancel deletion",
        'bot_info_title': "Bot information",
        'start_child_bot': "Start bot",
        'stop_child_bot': "Stop bot", 
        'restart_child_bot': "Restart bot",
        'bot_settings': "Bot settings",
        'bot_analytics': "Bot analytics",
        'bot_logs': "Bot logs",
        'bot_status_online': "Online",
        'bot_status_offline': "Offline",
        'language_selection': "Language selection",
        'language_changed': "Language changed successfully",
        'bot_manager_title': "Bot Manager",
        'available_commands': "Available commands",
        'change_language': "Change language",
        'manage_bots': "Manage bots",
        'help_command': "Help",
        'current_features': "Current features",
        'multilingual_support': "Multilingual support",
        'bot_management': "Bot management",
        'user_preferences': "User preferences",
        'demo_mode': "Demo mode active",
        'welcome': "Welcome! Choose your language:",
        'data_export': "Export data"
    },
    
    'es': {  # Espa√±ol
        # 'example_key': 'Translation in Espa√±ol'
        {
  "bot_token": "Token del bot",
  "token_not_found": "Token no encontrado",
  "bot_not_found": "Bot no encontrado",
  "error_try_again": "Error, int√©ntelo de nuevo",
  "back": "Volver",
  "cancel": "Cancelar",
  "token_invalid": "Token inv√°lido",
  "token_validation_error": "Error de validaci√≥n del token",
  "bot_already_exists": "Este bot ya existe",
  "creating_bot_app": "Creando la aplicaci√≥n del bot...",
  "start_bot_success": "Bot iniciado con √©xito",
  "start_bot_error": "Error al iniciar el bot",
  "bot_saved_success": "Bot guardado con √©xito",
  "delete_confirmation": "Confirmaci√≥n de eliminaci√≥n",
  "this_action_irreversible": "Esta acci√≥n es irreversible",
  "yes_delete": "S√≠, eliminar",
  "no_cancel": "No, cancelar",
  "delete_scheduled": "Eliminaci√≥n programada",
  "deletion_cancelled": "Eliminaci√≥n cancelada",
  "cancel_deletion": "Cancelar eliminaci√≥n",
  "bot_info_title": "Informaci√≥n del bot",
  "start_child_bot": "Iniciar el bot",
  "stop_child_bot": "Detener el bot",
  "restart_child_bot": "Reiniciar el bot",
  "bot_settings": "Configuraciones del bot",
  "bot_analytics": "Anal√≠ticas del bot",
  "bot_logs": "Registros del bot",
  "bot_status_online": "En l√≠nea",
  "bot_status_offline": "Desconectado",
  "language_selection": "Selecci√≥n de idioma",
  "language_changed": "Idioma cambiado con √©xito",
  "bot_manager_title": "Administrador de bots",
  "available_commands": "Comandos disponibles",
  "change_language": "Cambiar idioma",
  "manage_bots": "Gestionar bots",
  "help_command": "Ayuda",
  "current_features": "Caracter√≠sticas actuales",
  "multilingual_support": "Soporte multiling√ºe",
  "bot_management": "Gesti√≥n de bots",
  "user_preferences": "Preferencias del usuario",
  "demo_mode": "Modo demo activo",
  "welcome": "¬°Bienvenido! Elige tu idioma:",
  "data_export": "Exportar datos"
}
    },
    'de': {  # Deutsch
        # 'example_key': 'Translation in Deutsch'
        {
  "bot_token": "Bot-Token",
  "token_not_found": "Token nicht gefunden",
  "bot_not_found": "Bot nicht gefunden",
  "error_try_again": "Fehler, bitte erneut versuchen",
  "back": "Zur√ºck",
  "cancel": "Abbrechen",
  "token_invalid": "Ung√ºltiger Token",
  "token_validation_error": "Token-Validierungsfehler",
  "bot_already_exists": "Dieser Bot existiert bereits",
  "creating_bot_app": "Bot-Anwendung wird erstellt...",
  "start_bot_success": "Bot erfolgreich gestartet",
  "start_bot_error": "Fehler beim Starten des Bots",
  "bot_saved_success": "Bot erfolgreich gespeichert",
  "delete_confirmation": "L√∂schbest√§tigung",
  "this_action_irreversible": "Diese Aktion ist nicht r√ºckg√§ngig zu machen",
  "yes_delete": "Ja, l√∂schen",
  "no_cancel": "Nein, abbrechen",
  "delete_scheduled": "L√∂schung geplant",
  "deletion_cancelled": "L√∂schung abgebrochen",
  "cancel_deletion": "L√∂schung abbrechen",
  "bot_info_title": "Bot-Informationen",
  "start_child_bot": "Bot starten",
  "stop_child_bot": "Bot stoppen",
  "restart_child_bot": "Bot neu starten",
  "bot_settings": "Bot-Einstellungen",
  "bot_analytics": "Bot-Analysen",
  "bot_logs": "Bot-Protokolle",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Sprachauswahl",
  "language_changed": "Sprache erfolgreich ge√§ndert",
  "bot_manager_title": "Bot-Manager",
  "available_commands": "Verf√ºgbare Befehle",
  "change_language": "Sprache √§ndern",
  "manage_bots": "Bots verwalten",
  "help_command": "Hilfe",
  "current_features": "Aktuelle Funktionen",
  "multilingual_support": "Mehrsprachige Unterst√ºtzung",
  "bot_management": "Bot-Verwaltung",
  "user_preferences": "Benutzereinstellungen",
  "demo_mode": "Demo-Modus aktiv",
  "welcome": "Willkommen! Bitte w√§hlen Sie Ihre Sprache:",
  "data_export": "Daten exportieren"
}
    },
    'zh': {  # ‰∏≠Êñá
        # 'example_key': 'Translation in ‰∏≠Êñá'
        {
  "bot_token": "Êú∫Âô®‰∫∫‰ª§Áâå",
  "token_not_found": "Êú™ÊâæÂà∞‰ª§Áâå",
  "bot_not_found": "Êú™ÊâæÂà∞Êú∫Âô®‰∫∫",
  "error_try_again": "ÂèëÁîüÈîôËØØÔºåËØ∑ÈáçËØï",
  "back": "ËøîÂõû",
  "cancel": "ÂèñÊ∂à",
  "token_invalid": "‰ª§ÁâåÊó†Êïà",
  "token_validation_error": "‰ª§ÁâåÈ™åËØÅÈîôËØØ",
  "bot_already_exists": "ËØ•Êú∫Âô®‰∫∫Â∑≤Â≠òÂú®",
  "creating_bot_app": "Ê≠£Âú®ÂàõÂª∫Êú∫Âô®‰∫∫Â∫îÁî®...",
  "start_bot_success": "Êú∫Âô®‰∫∫ÂêØÂä®ÊàêÂäü",
  "start_bot_error": "ÂêØÂä®Êú∫Âô®‰∫∫Êó∂Âá∫Èîô",
  "bot_saved_success": "Êú∫Âô®‰∫∫‰øùÂ≠òÊàêÂäü",
  "delete_confirmation": "Âà†Èô§Á°ÆËÆ§",
  "this_action_irreversible": "Ê≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ",
  "yes_delete": "ÊòØÁöÑÔºåÂà†Èô§",
  "no_cancel": "‰∏çÔºåÂèñÊ∂à",
  "delete_scheduled": "Â∑≤ÂÆâÊéíÂà†Èô§",
  "deletion_cancelled": "Âà†Èô§Â∑≤ÂèñÊ∂à",
  "cancel_deletion": "ÂèñÊ∂àÂà†Èô§",
  "bot_info_title": "Êú∫Âô®‰∫∫‰ø°ÊÅØ",
  "start_child_bot": "ÂêØÂä®Êú∫Âô®‰∫∫",
  "stop_child_bot": "ÂÅúÊ≠¢Êú∫Âô®‰∫∫",
  "restart_child_bot": "ÈáçÂêØÊú∫Âô®‰∫∫",
  "bot_settings": "Êú∫Âô®‰∫∫ËÆæÁΩÆ",
  "bot_analytics": "Êú∫Âô®‰∫∫ÂàÜÊûê",
  "bot_logs": "Êú∫Âô®‰∫∫Êó•Âøó",
  "bot_status_online": "Âú®Á∫ø",
  "bot_status_offline": "Á¶ªÁ∫ø",
  "language_selection": "ÈÄâÊã©ËØ≠Ë®Ä",
  "language_changed": "ËØ≠Ë®ÄÊõ¥ÊîπÊàêÂäü",
  "bot_manager_title": "Êú∫Âô®‰∫∫ÁÆ°ÁêÜÂô®",
  "available_commands": "ÂèØÁî®ÂëΩ‰ª§",
  "change_language": "Êõ¥ÊîπËØ≠Ë®Ä",
  "manage_bots": "ÁÆ°ÁêÜÊú∫Âô®‰∫∫",
  "help_command": "Â∏ÆÂä©",
  "current_features": "ÂΩìÂâçÂäüËÉΩ",
  "multilingual_support": "Â§öËØ≠Ë®ÄÊîØÊåÅ",
  "bot_management": "Êú∫Âô®‰∫∫ÁÆ°ÁêÜ",
  "user_preferences": "Áî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ",
  "demo_mode": "ÊºîÁ§∫Ê®°ÂºèÂ∑≤ÊøÄÊ¥ª",
  "welcome": "Ê¨¢ËøéÔºÅËØ∑ÈÄâÊã©ÊÇ®ÁöÑËØ≠Ë®ÄÔºö",
  "data_export": "ÂØºÂá∫Êï∞ÊçÆ"
}
    },
    'hi': {  # ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä
        # 'example_key': 'Translation in ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä'
        {
  "bot_token": "‡§¨‡•â‡§ü ‡§ü‡•ã‡§ï‡§®",
  "token_not_found": "‡§ü‡•ã‡§ï‡§® ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ",
  "bot_not_found": "‡§¨‡•â‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ",
  "error_try_again": "‡§§‡•ç‡§∞‡•Å‡§ü‡§ø, ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç",
  "back": "‡§µ‡§æ‡§™‡§∏",
  "cancel": "‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
  "token_invalid": "‡§Ö‡§µ‡•à‡§ß ‡§ü‡•ã‡§ï‡§®",
  "token_validation_error": "‡§ü‡•ã‡§ï‡§® ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§® ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
  "bot_already_exists": "‡§Ø‡§π ‡§¨‡•â‡§ü ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à",
  "creating_bot_app": "‡§¨‡•â‡§ü ‡§ê‡§™ ‡§¨‡§®‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...",
  "start_bot_success": "‡§¨‡•â‡§ü ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•Å‡§Ü",
  "start_bot_error": "‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø",
  "bot_saved_success": "‡§¨‡•â‡§ü ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∏‡§π‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ",
  "delete_confirmation": "‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø",
  "this_action_irreversible": "‡§Ø‡§π ‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§Ö‡§™‡§∞‡§ø‡§µ‡§∞‡•ç‡§§‡§®‡•Ä‡§Ø ‡§π‡•à",
  "yes_delete": "‡§π‡§æ‡§Å, ‡§π‡§ü‡§æ‡§è‡§Ç",
  "no_cancel": "‡§®‡§π‡•Ä‡§Ç, ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
  "delete_scheduled": "‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§¨‡§®‡§æ‡§à ‡§ó‡§à ‡§π‡•à",
  "deletion_cancelled": "‡§π‡§ü‡§æ‡§®‡§æ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ",
  "cancel_deletion": "‡§π‡§ü‡§æ‡§®‡§æ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç",
  "bot_info_title": "‡§¨‡•â‡§ü ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä",
  "start_child_bot": "‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
  "stop_child_bot": "‡§¨‡•â‡§ü ‡§∞‡•ã‡§ï‡•á‡§Ç",
  "restart_child_bot": "‡§¨‡•â‡§ü ‡§™‡•Å‡§®‡§É ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
  "bot_settings": "‡§¨‡•â‡§ü ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏",
  "bot_analytics": "‡§¨‡•â‡§ü ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
  "bot_logs": "‡§¨‡•â‡§ü ‡§≤‡•â‡§ó‡•ç‡§∏",
  "bot_status_online": "‡§ë‡§®‡§≤‡§æ‡§á‡§®",
  "bot_status_offline": "‡§ë‡§´‡§≤‡§æ‡§á‡§®",
  "language_selection": "‡§≠‡§æ‡§∑‡§æ ‡§ö‡§Ø‡§®",
  "language_changed": "‡§≠‡§æ‡§∑‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§¶‡§≤‡•Ä ‡§ó‡§à",
  "bot_manager_title": "‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§ï",
  "available_commands": "‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏",
  "change_language": "‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤‡•á‡§Ç",
  "manage_bots": "‡§¨‡•â‡§ü‡•ç‡§∏ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§® ‡§ï‡§∞‡•á‡§Ç",
  "help_command": "‡§∏‡§π‡§æ‡§Ø‡§§‡§æ",
  "current_features": "‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ‡§è‡§Å",
  "multilingual_support": "‡§¨‡§π‡•Å‡§≠‡§æ‡§∑‡•Ä‡§Ø ‡§∏‡§Æ‡§∞‡•ç‡§•‡§®",
  "bot_management": "‡§¨‡•â‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®",
  "user_preferences": "‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§™‡•ç‡§∞‡§æ‡§•‡§Æ‡§ø‡§ï‡§§‡§æ‡§è‡§Å",
  "demo_mode": "‡§°‡•á‡§Æ‡•ã ‡§Æ‡•ã‡§° ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•à",
  "welcome": "‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ‡§Ö‡§™‡§®‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç:",
  "data_export": "‡§°‡•á‡§ü‡§æ ‡§®‡§ø‡§∞‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§∞‡•á‡§Ç"
}
    },
    'ja': {  # Êó•Êú¨Ë™û
        # 'example_key': 'Translation in Êó•Êú¨Ë™û'
        {
  "bot_token": "„Éú„ÉÉ„Éà„Éà„Éº„ÇØ„É≥",
  "token_not_found": "„Éà„Éº„ÇØ„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
  "bot_not_found": "„Éú„ÉÉ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
  "error_try_again": "„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
  "back": "Êàª„Çã",
  "cancel": "„Ç≠„É£„É≥„Çª„É´",
  "token_invalid": "ÁÑ°Âäπ„Å™„Éà„Éº„ÇØ„É≥",
  "token_validation_error": "„Éà„Éº„ÇØ„É≥„ÅÆÊ§úË®º„Ç®„É©„Éº",
  "bot_already_exists": "„Åì„ÅÆ„Éú„ÉÉ„Éà„ÅØ„Åô„Åß„Å´Â≠òÂú®„Åó„Åæ„Åô",
  "creating_bot_app": "„Éú„ÉÉ„Éà„Ç¢„Éó„É™„Çí‰ΩúÊàê‰∏≠...",
  "start_bot_success": "„Éú„ÉÉ„Éà„ÅÆËµ∑Âãï„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü",
  "start_bot_error": "„Éú„ÉÉ„Éà„ÅÆËµ∑Âãï‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
  "bot_saved_success": "„Éú„ÉÉ„Éà„ÇíÊ≠£Â∏∏„Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü",
  "delete_confirmation": "ÂâäÈô§„ÅÆÁ¢∫Ë™ç",
  "this_action_irreversible": "„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì",
  "yes_delete": "„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åô„Çã",
  "no_cancel": "„ÅÑ„ÅÑ„Åà„ÄÅ„Ç≠„É£„É≥„Çª„É´„Åô„Çã",
  "delete_scheduled": "ÂâäÈô§„Åå‰∫àÂÆö„Åï„Çå„Åæ„Åó„Åü",
  "deletion_cancelled": "ÂâäÈô§„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
  "cancel_deletion": "ÂâäÈô§„Çí„Ç≠„É£„É≥„Çª„É´„Åô„Çã",
  "bot_info_title": "„Éú„ÉÉ„Éà„ÅÆÊÉÖÂ†±",
  "start_child_bot": "„Éú„ÉÉ„Éà„ÇíËµ∑Âãï",
  "stop_child_bot": "„Éú„ÉÉ„Éà„ÇíÂÅúÊ≠¢",
  "restart_child_bot": "„Éú„ÉÉ„Éà„ÇíÂÜçËµ∑Âãï",
  "bot_settings": "„Éú„ÉÉ„Éà„ÅÆË®≠ÂÆö",
  "bot_analytics": "„Éú„ÉÉ„Éà„ÅÆÂàÜÊûê",
  "bot_logs": "„Éú„ÉÉ„Éà„É≠„Ç∞",
  "bot_status_online": "„Ç™„É≥„É©„Ç§„É≥",
  "bot_status_offline": "„Ç™„Éï„É©„Ç§„É≥",
  "language_selection": "Ë®ÄË™ûÈÅ∏Êäû",
  "language_changed": "Ë®ÄË™û„ÅåÊ≠£Â∏∏„Å´Â§âÊõ¥„Åï„Çå„Åæ„Åó„Åü",
  "bot_manager_title": "„Éú„ÉÉ„Éà„Éû„Éç„Éº„Ç∏„É£„Éº",
  "available_commands": "Âà©Áî®ÂèØËÉΩ„Å™„Ç≥„Éû„É≥„Éâ",
  "change_language": "Ë®ÄË™û„ÇíÂ§âÊõ¥„Åô„Çã",
  "manage_bots": "„Éú„ÉÉ„Éà„ÇíÁÆ°ÁêÜ„Åô„Çã",
  "help_command": "„Éò„É´„Éó",
  "current_features": "ÁèæÂú®„ÅÆÊ©üËÉΩ",
  "multilingual_support": "Â§öË®ÄË™ûÂØæÂøú",
  "bot_management": "„Éú„ÉÉ„ÉàÁÆ°ÁêÜ",
  "user_preferences": "„É¶„Éº„Ç∂„ÉºË®≠ÂÆö",
  "demo_mode": "„Éá„É¢„É¢„Éº„Éâ„ÅåÊúâÂäπ„Åß„Åô",
  "welcome": "„Çà„ÅÜ„Åì„ÅùÔºÅË®ÄË™û„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö",
  "data_export": "„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã"
}
    },
    'ko': {  # ÌïúÍµ≠Ïñ¥
        # 'example_key': 'Translation in ÌïúÍµ≠Ïñ¥'
        {
  "bot_token": "Î¥á ÌÜ†ÌÅ∞",
  "token_not_found": "ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
  "bot_not_found": "Î¥áÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
  "error_try_again": "Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî",
  "back": "Îí§Î°ú",
  "cancel": "Ï∑®ÏÜå",
  "token_invalid": "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞",
  "token_validation_error": "ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïò§Î•ò",
  "bot_already_exists": "Ïù¥ Î¥áÏùÄ Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§",
  "creating_bot_app": "Î¥á Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÉùÏÑ± Ï§ë...",
  "start_bot_success": "Î¥áÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§",
  "start_bot_error": "Î¥á ÏãúÏûë Ï§ë Ïò§Î•ò Î∞úÏÉù",
  "bot_saved_success": "Î¥áÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§",
  "delete_confirmation": "ÏÇ≠Ï†ú ÌôïÏù∏",
  "this_action_irreversible": "Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§",
  "yes_delete": "Ïòà, ÏÇ≠Ï†úÌï©ÎãàÎã§",
  "no_cancel": "ÏïÑÎãàÏöî, Ï∑®ÏÜåÌï©ÎãàÎã§",
  "delete_scheduled": "ÏÇ≠Ï†ú ÏòàÏ†ïÎê®",
  "deletion_cancelled": "ÏÇ≠Ï†úÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§",
  "cancel_deletion": "ÏÇ≠Ï†ú Ï∑®ÏÜå",
  "bot_info_title": "Î¥á Ï†ïÎ≥¥",
  "start_child_bot": "Î¥á ÏãúÏûë",
  "stop_child_bot": "Î¥á Ï†ïÏßÄ",
  "restart_child_bot": "Î¥á Ïû¨ÏãúÏûë",
  "bot_settings": "Î¥á ÏÑ§Ï†ï",
  "bot_analytics": "Î¥á Î∂ÑÏÑù",
  "bot_logs": "Î¥á Î°úÍ∑∏",
  "bot_status_online": "Ïò®ÎùºÏù∏",
  "bot_status_offline": "Ïò§ÌîÑÎùºÏù∏",
  "language_selection": "Ïñ∏Ïñ¥ ÏÑ†ÌÉù",
  "language_changed": "Ïñ∏Ïñ¥Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§",
  "bot_manager_title": "Î¥á Í¥ÄÎ¶¨Ïûê",
  "available_commands": "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™ÖÎ†πÏñ¥",
  "change_language": "Ïñ∏Ïñ¥ Î≥ÄÍ≤Ω",
  "manage_bots": "Î¥á Í¥ÄÎ¶¨",
  "help_command": "ÎèÑÏõÄÎßê",
  "current_features": "ÌòÑÏû¨ Í∏∞Îä•",
  "multilingual_support": "Îã§Íµ≠Ïñ¥ ÏßÄÏõê",
  "bot_management": "Î¥á Í¥ÄÎ¶¨",
  "user_preferences": "ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï",
  "demo_mode": "Îç∞Î™® Î™®Îìú ÌôúÏÑ±ÌôîÎê®",
  "welcome": "ÌôòÏòÅÌï©ÎãàÎã§! Ïñ∏Ïñ¥Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî:",
  "data_export": "Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞"
}
    },
    'th': {  # ‡πÑ‡∏ó‡∏¢
        # 'example_key': 'Translation in ‡πÑ‡∏ó‡∏¢'
        {
  "bot_token": "‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ï",
  "token_not_found": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô",
  "bot_not_found": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏≠‡∏ï",
  "error_try_again": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
  "back": "‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö",
  "cancel": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
  "token_invalid": "‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
  "token_validation_error": "‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ó‡πÄ‡∏Ñ‡∏ô",
  "bot_already_exists": "‡∏ö‡∏≠‡∏ï‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß",
  "creating_bot_app": "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏≠‡∏õ‡∏ö‡∏≠‡∏ï...",
  "start_bot_success": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
  "start_bot_error": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï",
  "bot_saved_success": "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ö‡∏≠‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
  "delete_confirmation": "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö",
  "this_action_irreversible": "‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ",
  "yes_delete": "‡πÉ‡∏ä‡πà ‡∏•‡∏ö‡πÄ‡∏•‡∏¢",
  "no_cancel": "‡πÑ‡∏°‡πà ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
  "delete_scheduled": "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏ö‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß",
  "deletion_cancelled": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÅ‡∏•‡πâ‡∏ß",
  "cancel_deletion": "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏ö",
  "bot_info_title": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏≠‡∏ï",
  "start_child_bot": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏≠‡∏ï",
  "stop_child_bot": "‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏≠‡∏ï",
  "restart_child_bot": "‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡∏ö‡∏≠‡∏ï",
  "bot_settings": "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ö‡∏≠‡∏ï",
  "bot_analytics": "‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ö‡∏≠‡∏ï",
  "bot_logs": "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ö‡∏≠‡∏ï",
  "bot_status_online": "‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå",
  "bot_status_offline": "‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå",
  "language_selection": "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤",
  "language_changed": "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß",
  "bot_manager_title": "‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
  "available_commands": "‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
  "change_language": "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤",
  "manage_bots": "‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
  "help_command": "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠",
  "current_features": "‡∏Ñ‡∏∏‡∏ì‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô",
  "multilingual_support": "‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏©‡∏≤",
  "bot_management": "‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏ï",
  "user_preferences": "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ",
  "demo_mode": "‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏≤‡∏ò‡∏¥‡∏ï‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
  "welcome": "‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö! ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤:",
  "data_export": "‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•"
}
    },
    'ru': {  # –†—É—Å—Å–∫–∏–π
        # 'example_key': 'Translation in –†—É—Å—Å–∫–∏–π'
        {
  "bot_token": "–¢–æ–∫–µ–Ω –±–æ—Ç–∞",
  "token_not_found": "–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω",
  "bot_not_found": "–ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
  "error_try_again": "–û—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑",
  "back": "–ù–∞–∑–∞–¥",
  "cancel": "–û—Ç–º–µ–Ω–∞",
  "token_invalid": "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ç–æ–∫–µ–Ω",
  "token_validation_error": "–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞",
  "bot_already_exists": "–ë–æ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç",
  "creating_bot_app": "–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –±–æ—Ç–∞...",
  "start_bot_success": "–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω",
  "start_bot_error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞",
  "bot_saved_success": "–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω",
  "delete_confirmation": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è",
  "this_action_irreversible": "–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ",
  "yes_delete": "–î–∞, —É–¥–∞–ª–∏—Ç—å",
  "no_cancel": "–ù–µ—Ç, –æ—Ç–º–µ–Ω–∞",
  "delete_scheduled": "–£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ",
  "deletion_cancelled": "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ",
  "cancel_deletion": "–û—Ç–º–µ–Ω–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ",
  "bot_info_title": "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ",
  "start_child_bot": "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞",
  "stop_child_bot": "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞",
  "restart_child_bot": "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞",
  "bot_settings": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞",
  "bot_analytics": "–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –±–æ—Ç–∞",
  "bot_logs": "–õ–æ–≥–∏ –±–æ—Ç–∞",
  "bot_status_online": "–û–Ω–ª–∞–π–Ω",
  "bot_status_offline": "–û—Ñ—Ñ–ª–∞–π–Ω",
  "language_selection": "–í—ã–±–æ—Ä —è–∑—ã–∫–∞",
  "language_changed": "–Ø–∑—ã–∫ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω",
  "bot_manager_title": "–ú–µ–Ω–µ–¥–∂–µ—Ä –±–æ—Ç–æ–≤",
  "available_commands": "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã",
  "change_language": "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",
  "manage_bots": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏",
  "help_command": "–ü–æ–º–æ—â—å",
  "current_features": "–¢–µ–∫—É—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏",
  "multilingual_support": "–ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞",
  "bot_management": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–º",
  "user_preferences": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
  "demo_mode": "–î–µ–º–æ-—Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω",
  "welcome": "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
  "data_export": "–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"
}
    },
    'pt': {  # Portugu√™s
        # 'example_key': 'Translation in Portugu√™s'
        {
  "bot_token": "Token do bot",
  "token_not_found": "Token n√£o encontrado",
  "bot_not_found": "Bot n√£o encontrado",
  "error_try_again": "Erro, tente novamente",
  "back": "Voltar",
  "cancel": "Cancelar",
  "token_invalid": "Token inv√°lido",
  "token_validation_error": "Erro de valida√ß√£o do token",
  "bot_already_exists": "Este bot j√° existe",
  "creating_bot_app": "Criando aplicativo do bot...",
  "start_bot_success": "Bot iniciado com sucesso",
  "start_bot_error": "Erro ao iniciar o bot",
  "bot_saved_success": "Bot salvo com sucesso",
  "delete_confirmation": "Confirma√ß√£o de exclus√£o",
  "this_action_irreversible": "Esta a√ß√£o √© irrevers√≠vel",
  "yes_delete": "Sim, excluir",
  "no_cancel": "N√£o, cancelar",
  "delete_scheduled": "Exclus√£o agendada",
  "deletion_cancelled": "Exclus√£o cancelada",
  "cancel_deletion": "Cancelar exclus√£o",
  "bot_info_title": "Informa√ß√µes do bot",
  "start_child_bot": "Iniciar bot",
  "stop_child_bot": "Parar bot",
  "restart_child_bot": "Reiniciar bot",
  "bot_settings": "Configura√ß√µes do bot",
  "bot_analytics": "An√°lises do bot",
  "bot_logs": "Registros do bot",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Sele√ß√£o de idioma",
  "language_changed": "Idioma alterado com sucesso",
  "bot_manager_title": "Gerenciador de bots",
  "available_commands": "Comandos dispon√≠veis",
  "change_language": "Alterar idioma",
  "manage_bots": "Gerenciar bots",
  "help_command": "Ajuda",
  "current_features": "Recursos atuais",
  "multilingual_support": "Suporte multil√≠ngue",
  "bot_management": "Gest√£o de bots",
  "user_preferences": "Prefer√™ncias do usu√°rio",
  "demo_mode": "Modo demonstra√ß√£o ativado",
  "welcome": "Bem-vindo! Escolha seu idioma:",
  "data_export": "Exportar dados"
}
    },
    'it': {  # Italiano
        # 'example_key': 'Translation in Italiano'
        {
  "bot_token": "Token del bot",
  "token_not_found": "Token non trovato",
  "bot_not_found": "Bot non trovato",
  "error_try_again": "Errore, riprova",
  "back": "Indietro",
  "cancel": "Annulla",
  "token_invalid": "Token non valido",
  "token_validation_error": "Errore di convalida del token",
  "bot_already_exists": "Questo bot esiste gi√†",
  "creating_bot_app": "Creazione dell'app del bot...",
  "start_bot_success": "Bot avviato con successo",
  "start_bot_error": "Errore durante l'avvio del bot",
  "bot_saved_success": "Bot salvato con successo",
  "delete_confirmation": "Conferma eliminazione",
  "this_action_irreversible": "Questa azione √® irreversibile",
  "yes_delete": "S√¨, elimina",
  "no_cancel": "No, annulla",
  "delete_scheduled": "Eliminazione programmata",
  "deletion_cancelled": "Eliminazione annullata",
  "cancel_deletion": "Annulla eliminazione",
  "bot_info_title": "Informazioni del bot",
  "start_child_bot": "Avvia bot",
  "stop_child_bot": "Ferma bot",
  "restart_child_bot": "Riavvia bot",
  "bot_settings": "Impostazioni del bot",
  "bot_analytics": "Analisi del bot",
  "bot_logs": "Log del bot",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Selezione della lingua",
  "language_changed": "Lingua modificata con successo",
  "bot_manager_title": "Gestore dei bot",
  "available_commands": "Comandi disponibili",
  "change_language": "Cambia lingua",
  "manage_bots": "Gestisci i bot",
  "help_command": "Aiuto",
  "current_features": "Funzionalit√† attuali",
  "multilingual_support": "Supporto multilingue",
  "bot_management": "Gestione bot",
  "user_preferences": "Preferenze utente",
  "demo_mode": "Modalit√† demo attiva",
  "welcome": "Benvenuto! Scegli la tua lingua:",
  "data_export": "Esporta dati"
}
    },
    'ar': {  # ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
        # 'example_key': 'Translation in ÿßŸÑÿπÿ±ÿ®Ÿäÿ©'
        {
  "bot_token": "ÿ±ŸÖÿ≤ ÿßŸÑÿ®Ÿàÿ™",
  "token_not_found": "ÿßŸÑÿ±ŸÖÿ≤ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ",
  "bot_not_found": "ÿßŸÑÿ®Ÿàÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ",
  "error_try_again": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ",
  "back": "ÿ±ÿ¨Ÿàÿπ",
  "cancel": "ÿ•ŸÑÿ∫ÿßÿ°",
  "token_invalid": "ÿ±ŸÖÿ≤ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠",
  "token_validation_error": "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ±ŸÖÿ≤",
  "bot_already_exists": "Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ",
  "creating_bot_app": "ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ®Ÿàÿ™...",
  "start_bot_success": "ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠",
  "start_bot_error": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™",
  "bot_saved_success": "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠",
  "delete_confirmation": "ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ",
  "this_action_irreversible": "Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜŸá",
  "yes_delete": "ŸÜÿπŸÖÿå ÿßÿ≠ÿ∞ŸÅ",
  "no_cancel": "ŸÑÿßÿå ÿ•ŸÑÿ∫ÿßÿ°",
  "delete_scheduled": "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ŸÖŸàÿπÿØ ÿßŸÑÿ≠ÿ∞ŸÅ",
  "deletion_cancelled": "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∞ŸÅ",
  "cancel_deletion": "ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∞ŸÅ",
  "bot_info_title": "ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
  "start_child_bot": "ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™",
  "stop_child_bot": "ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ®Ÿàÿ™",
  "restart_child_bot": "ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™",
  "bot_settings": "ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
  "bot_analytics": "ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
  "bot_logs": "ÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
  "bot_status_online": "ŸÖÿ™ÿµŸÑ",
  "bot_status_offline": "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ",
  "language_selection": "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿ∫ÿ©",
  "language_changed": "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ© ÿ®ŸÜÿ¨ÿßÿ≠",
  "bot_manager_title": "ŸÖÿØŸäÿ± ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
  "available_commands": "ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©",
  "change_language": "ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ©",
  "manage_bots": "ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
  "help_command": "ŸÖÿ≥ÿßÿπÿØÿ©",
  "current_features": "ÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©",
  "multilingual_support": "ÿØÿπŸÖ ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÑÿ∫ÿßÿ™",
  "bot_management": "ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™",
  "user_preferences": "ÿ™ŸÅÿ∂ŸäŸÑÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ",
  "demo_mode": "Ÿàÿ∂ÿπ ÿßŸÑÿπÿ±ÿ∂ ŸÖŸÅÿπŸÑ",
  "welcome": "ŸÖÿ±ÿ≠ÿ®Ÿãÿß! Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÑÿ∫ÿ™ŸÉ:",
  "data_export": "ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"
}
    },
    'tr': {  # T√ºrk√ße
        # 'example_key': 'Translation in T√ºrk√ße'
        {
  "bot_token": "Bot belirteci",
  "token_not_found": "Belirte√ß bulunamadƒ±",
  "bot_not_found": "Bot bulunamadƒ±",
  "error_try_again": "Hata olu≈ütu, l√ºtfen tekrar deneyin",
  "back": "Geri",
  "cancel": "ƒ∞ptal",
  "token_invalid": "Ge√ßersiz belirte√ß",
  "token_validation_error": "Belirte√ß doƒürulama hatasƒ±",
  "bot_already_exists": "Bu bot zaten mevcut",
  "creating_bot_app": "Bot uygulamasƒ± olu≈üturuluyor...",
  "start_bot_success": "Bot ba≈üarƒ±yla ba≈ülatƒ±ldƒ±",
  "start_bot_error": "Bot ba≈ülatƒ±lƒ±rken hata olu≈ütu",
  "bot_saved_success": "Bot ba≈üarƒ±yla kaydedildi",
  "delete_confirmation": "Silme onayƒ±",
  "this_action_irreversible": "Bu i≈ülem geri alƒ±namaz",
  "yes_delete": "Evet, sil",
  "no_cancel": "Hayƒ±r, iptal et",
  "delete_scheduled": "Silme zamanlandƒ±",
  "deletion_cancelled": "Silme i≈ülemi iptal edildi",
  "cancel_deletion": "Silme i≈ülemini iptal et",
  "bot_info_title": "Bot bilgileri",
  "start_child_bot": "Botu ba≈ülat",
  "stop_child_bot": "Botu durdur",
  "restart_child_bot": "Botu yeniden ba≈ülat",
  "bot_settings": "Bot ayarlarƒ±",
  "bot_analytics": "Bot analizleri",
  "bot_logs": "Bot g√ºnl√ºkleri",
  "bot_status_online": "√áevrimi√ßi",
  "bot_status_offline": "√áevrimdƒ±≈üƒ±",
  "language_selection": "Dil se√ßimi",
  "language_changed": "Dil ba≈üarƒ±yla deƒüi≈ütirildi",
  "bot_manager_title": "Bot y√∂neticisi",
  "available_commands": "Mevcut komutlar",
  "change_language": "Dili deƒüi≈ütir",
  "manage_bots": "Botlarƒ± y√∂net",
  "help_command": "Yardƒ±m",
  "current_features": "Mevcut √∂zellikler",
  "multilingual_support": "√áoklu dil desteƒüi",
  "bot_management": "Bot y√∂netimi",
  "user_preferences": "Kullanƒ±cƒ± tercihleri",
  "demo_mode": "Demo modu etkin",
  "welcome": "Ho≈ü geldiniz! L√ºtfen dilinizi se√ßin:",
  "data_export": "Verileri dƒ±≈üa aktar"
}
    },
    'vi': {  # Ti·∫øng Vi·ªát
        # 'example_key': 'Translation in Ti·∫øng Vi·ªát'
        {
  "bot_token": "M√£ token c·ªßa bot",
  "token_not_found": "Kh√¥ng t√¨m th·∫•y token",
  "bot_not_found": "Kh√¥ng t√¨m th·∫•y bot",
  "error_try_again": "ƒê√£ x·∫£y ra l·ªói, vui l√≤ng th·ª≠ l·∫°i",
  "back": "Quay l·∫°i",
  "cancel": "H·ªßy",
  "token_invalid": "Token kh√¥ng h·ª£p l·ªá",
  "token_validation_error": "L·ªói x√°c th·ª±c token",
  "bot_already_exists": "Bot n√†y ƒë√£ t·ªìn t·∫°i",
  "creating_bot_app": "ƒêang t·∫°o ·ª©ng d·ª•ng bot...",
  "start_bot_success": "Kh·ªüi ƒë·ªông bot th√†nh c√¥ng",
  "start_bot_error": "L·ªói khi kh·ªüi ƒë·ªông bot",
  "bot_saved_success": "ƒê√£ l∆∞u bot th√†nh c√¥ng",
  "delete_confirmation": "X√°c nh·∫≠n x√≥a",
  "this_action_irreversible": "H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c",
  "yes_delete": "C√≥, x√≥a",
  "no_cancel": "Kh√¥ng, h·ªßy",
  "delete_scheduled": "ƒê√£ l√™n l·ªãch x√≥a",
  "deletion_cancelled": "ƒê√£ h·ªßy x√≥a",
  "cancel_deletion": "H·ªßy x√≥a",
  "bot_info_title": "Th√¥ng tin bot",
  "start_child_bot": "Kh·ªüi ƒë·ªông bot",
  "stop_child_bot": "D·ª´ng bot",
  "restart_child_bot": "Kh·ªüi ƒë·ªông l·∫°i bot",
  "bot_settings": "C√†i ƒë·∫∑t bot",
  "bot_analytics": "Ph√¢n t√≠ch bot",
  "bot_logs": "Nh·∫≠t k√Ω bot",
  "bot_status_online": "Tr·ª±c tuy·∫øn",
  "bot_status_offline": "Ngo·∫°i tuy·∫øn",
  "language_selection": "Ch·ªçn ng√¥n ng·ªØ",
  "language_changed": "Thay ƒë·ªïi ng√¥n ng·ªØ th√†nh c√¥ng",
  "bot_manager_title": "Tr√¨nh qu·∫£n l√Ω bot",
  "available_commands": "L·ªánh kh·∫£ d·ª•ng",
  "change_language": "Thay ƒë·ªïi ng√¥n ng·ªØ",
  "manage_bots": "Qu·∫£n l√Ω bot",
  "help_command": "Tr·ª£ gi√∫p",
  "current_features": "T√≠nh nƒÉng hi·ªán t·∫°i",
  "multilingual_support": "H·ªó tr·ª£ ƒëa ng√¥n ng·ªØ",
  "bot_management": "Qu·∫£n l√Ω bot",
  "user_preferences": "T√πy ch·ªçn ng∆∞·ªùi d√πng",
  "demo_mode": "Ch·∫ø ƒë·ªô demo ƒëang ho·∫°t ƒë·ªông",
  "welcome": "Ch√†o m·ª´ng! Vui l√≤ng ch·ªçn ng√¥n ng·ªØ:",
  "data_export": "Xu·∫•t d·ªØ li·ªáu"
}
    },
    'pl': {  # Polski
        # 'example_key': 'Translation in Polski'
        {
  "bot_token": "Token bota",
  "token_not_found": "Nie znaleziono tokenu",
  "bot_not_found": "Nie znaleziono bota",
  "error_try_again": "WystƒÖpi≈Ç b≈ÇƒÖd, spr√≥buj ponownie",
  "back": "Wstecz",
  "cancel": "Anuluj",
  "token_invalid": "Nieprawid≈Çowy token",
  "token_validation_error": "B≈ÇƒÖd walidacji tokenu",
  "bot_already_exists": "Ten bot ju≈º istnieje",
  "creating_bot_app": "Tworzenie aplikacji bota...",
  "start_bot_success": "Bot zosta≈Ç pomy≈õlnie uruchomiony",
  "start_bot_error": "B≈ÇƒÖd podczas uruchamiania bota",
  "bot_saved_success": "Bot zosta≈Ç pomy≈õlnie zapisany",
  "delete_confirmation": "Potwierdzenie usuniƒôcia",
  "this_action_irreversible": "Tej operacji nie mo≈ºna cofnƒÖƒá",
  "yes_delete": "Tak, usu≈Ñ",
  "no_cancel": "Nie, anuluj",
  "delete_scheduled": "Usuniƒôcie zaplanowane",
  "deletion_cancelled": "Usuniƒôcie anulowane",
  "cancel_deletion": "Anuluj usuniƒôcie",
  "bot_info_title": "Informacje o bocie",
  "start_child_bot": "Uruchom bota",
  "stop_child_bot": "Zatrzymaj bota",
  "restart_child_bot": "Uruchom ponownie bota",
  "bot_settings": "Ustawienia bota",
  "bot_analytics": "Analizy bota",
  "bot_logs": "Logi bota",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Wyb√≥r jƒôzyka",
  "language_changed": "Jƒôzyk zosta≈Ç pomy≈õlnie zmieniony",
  "bot_manager_title": "Mened≈ºer bot√≥w",
  "available_commands": "Dostƒôpne polecenia",
  "change_language": "Zmie≈Ñ jƒôzyk",
  "manage_bots": "ZarzƒÖdzaj botami",
  "help_command": "Pomoc",
  "current_features": "Obecne funkcje",
  "multilingual_support": "Obs≈Çuga wielu jƒôzyk√≥w",
  "bot_management": "ZarzƒÖdzanie botami",
  "user_preferences": "Preferencje u≈ºytkownika",
  "demo_mode": "Tryb demonstracyjny aktywny",
  "welcome": "Witaj! Wybierz sw√≥j jƒôzyk:",
  "data_export": "Eksport danych"
}
    },
    'nl': {  # Nederlands
        # 'example_key': 'Translation in Nederlands'
        {
  "bot_token": "Bot-token",
  "token_not_found": "Token niet gevonden",
  "bot_not_found": "Bot niet gevonden",
  "error_try_again": "Fout, probeer het opnieuw",
  "back": "Terug",
  "cancel": "Annuleren",
  "token_invalid": "Ongeldig token",
  "token_validation_error": "Fout bij tokenvalidatie",
  "bot_already_exists": "Deze bot bestaat al",
  "creating_bot_app": "Bot-app wordt aangemaakt...",
  "start_bot_success": "Bot succesvol gestart",
  "start_bot_error": "Fout bij het starten van de bot",
  "bot_saved_success": "Bot succesvol opgeslagen",
  "delete_confirmation": "Verwijderbevestiging",
  "this_action_irreversible": "Deze actie is onomkeerbaar",
  "yes_delete": "Ja, verwijderen",
  "no_cancel": "Nee, annuleren",
  "delete_scheduled": "Verwijdering gepland",
  "deletion_cancelled": "Verwijdering geannuleerd",
  "cancel_deletion": "Verwijdering annuleren",
  "bot_info_title": "Botinformatie",
  "start_child_bot": "Start bot",
  "stop_child_bot": "Stop bot",
  "restart_child_bot": "Herstart bot",
  "bot_settings": "Botinstellingen",
  "bot_analytics": "Botanalyse",
  "bot_logs": "Botlogboeken",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Taalkeuze",
  "language_changed": "Taal succesvol gewijzigd",
  "bot_manager_title": "Botbeheerder",
  "available_commands": "Beschikbare commando's",
  "change_language": "Taal wijzigen",
  "manage_bots": "Beheer bots",
  "help_command": "Help",
  "current_features": "Huidige functies",
  "multilingual_support": "Meertalige ondersteuning",
  "bot_management": "Botbeheer",
  "user_preferences": "Gebruikersvoorkeuren",
  "demo_mode": "Demomodus actief",
  "welcome": "Welkom! Kies je taal:",
  "data_export": "Gegevens exporteren"
}
    },
    'sv': {  # Svenska
        # 'example_key': 'Translation in Svenska'
        {
  "bot_token": "Bot-token",
  "token_not_found": "Token hittades inte",
  "bot_not_found": "Bot hittades inte",
  "error_try_again": "Fel, f√∂rs√∂k igen",
  "back": "Tillbaka",
  "cancel": "Avbryt",
  "token_invalid": "Ogiltig token",
  "token_validation_error": "Tokenverifieringsfel",
  "bot_already_exists": "Denna bot finns redan",
  "creating_bot_app": "Skapar bot-applikation...",
  "start_bot_success": "Bot startades framg√•ngsrikt",
  "start_bot_error": "Fel vid start av bot",
  "bot_saved_success": "Bot sparades framg√•ngsrikt",
  "delete_confirmation": "Bekr√§fta borttagning",
  "this_action_irreversible": "Denna √•tg√§rd kan inte √•ngras",
  "yes_delete": "Ja, ta bort",
  "no_cancel": "Nej, avbryt",
  "delete_scheduled": "Borttagning planerad",
  "deletion_cancelled": "Borttagning avbr√∂ts",
  "cancel_deletion": "Avbryt borttagning",
  "bot_info_title": "Botinformation",
  "start_child_bot": "Starta bot",
  "stop_child_bot": "Stoppa bot",
  "restart_child_bot": "Starta om bot",
  "bot_settings": "Botinst√§llningar",
  "bot_analytics": "Botanalys",
  "bot_logs": "Botloggar",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Spr√•kval",
  "language_changed": "Spr√•k har √§ndrats",
  "bot_manager_title": "Bothanterare",
  "available_commands": "Tillg√§ngliga kommandon",
  "change_language": "Byt spr√•k",
  "manage_bots": "Hantera bottar",
  "help_command": "Hj√§lp",
  "current_features": "Nuvarande funktioner",
  "multilingual_support": "Flerspr√•kigt st√∂d",
  "bot_management": "Botadministration",
  "user_preferences": "Anv√§ndarinst√§llningar",
  "demo_mode": "Demol√§ge aktivt",
  "welcome": "V√§lkommen! V√§lj ditt spr√•k:",
  "data_export": "Exportera data"
}
    },
    'uk': {  # –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞
        # 'example_key': 'Translation in –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞'
        {
  "bot_token": "–¢–æ–∫–µ–Ω –±–æ—Ç–∞",
  "token_not_found": "–¢–æ–∫–µ–Ω –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
  "bot_not_found": "–ë–æ—Ç–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ",
  "error_try_again": "–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑",
  "back": "–ù–∞–∑–∞–¥",
  "cancel": "–°–∫–∞—Å—É–≤–∞—Ç–∏",
  "token_invalid": "–ù–µ–¥—ñ–π—Å–Ω–∏–π —Ç–æ–∫–µ–Ω",
  "token_validation_error": "–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó —Ç–æ–∫–µ–Ω–∞",
  "bot_already_exists": "–¶–µ–π –±–æ—Ç –≤–∂–µ —ñ—Å–Ω—É—î",
  "creating_bot_app": "–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞—Å—Ç–æ—Å—É–Ω–∫—É –¥–ª—è –±–æ—Ç–∞...",
  "start_bot_success": "–ë–æ—Ç —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ",
  "start_bot_error": "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –±–æ—Ç–∞",
  "bot_saved_success": "–ë–æ—Ç–∞ —É—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ",
  "delete_confirmation": "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è",
  "this_action_irreversible": "–¶—é –¥—ñ—é –Ω–µ–º–æ–∂–ª–∏–≤–æ —Å–∫–∞—Å—É–≤–∞—Ç–∏",
  "yes_delete": "–¢–∞–∫, –≤–∏–¥–∞–ª–∏—Ç–∏",
  "no_cancel": "–ù—ñ, —Å–∫–∞—Å—É–≤–∞—Ç–∏",
  "delete_scheduled": "–í–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ",
  "deletion_cancelled": "–í–∏–¥–∞–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ",
  "cancel_deletion": "–°–∫–∞—Å—É–≤–∞—Ç–∏ –≤–∏–¥–∞–ª–µ–Ω–Ω—è",
  "bot_info_title": "–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –±–æ—Ç–∞",
  "start_child_bot": "–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –±–æ—Ç–∞",
  "stop_child_bot": "–ó—É–ø–∏–Ω–∏—Ç–∏ –±–æ—Ç–∞",
  "restart_child_bot": "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–∏ –±–æ—Ç–∞",
  "bot_settings": "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–æ—Ç–∞",
  "bot_analytics": "–ê–Ω–∞–ª—ñ—Ç–∏–∫–∞ –±–æ—Ç–∞",
  "bot_logs": "–õ–æ–≥–∏ –±–æ—Ç–∞",
  "bot_status_online": "–û–Ω–ª–∞–π–Ω",
  "bot_status_offline": "–û—Ñ–ª–∞–π–Ω",
  "language_selection": "–í–∏–±—ñ—Ä –º–æ–≤–∏",
  "language_changed": "–ú–æ–≤—É —É—Å–ø—ñ—à–Ω–æ –∑–º—ñ–Ω–µ–Ω–æ",
  "bot_manager_title": "–ú–µ–Ω–µ–¥–∂–µ—Ä –±–æ—Ç—ñ–≤",
  "available_commands": "–î–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–∞–Ω–¥–∏",
  "change_language": "–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É",
  "manage_bots": "–ö–µ—Ä—É–≤–∞—Ç–∏ –±–æ—Ç–∞–º–∏",
  "help_command": "–î–æ–ø–æ–º–æ–≥–∞",
  "current_features": "–ü–æ—Ç–æ—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó",
  "multilingual_support": "–ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –±–∞–≥–∞—Ç–æ–º–æ–≤–Ω–æ—Å—Ç—ñ",
  "bot_management": "–ö–µ—Ä—É–≤–∞–Ω–Ω—è –±–æ—Ç–æ–º",
  "user_preferences": "–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞",
  "demo_mode": "–î–µ–º–æ-—Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–Ω–∏–π",
  "welcome": "–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ! –û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É:",
  "data_export": "–ï–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–∏—Ö"
}
    },
    'sw': {  # Kiswahili
        # 'example_key': 'Translation in Kiswahili'
        {
  "bot_token": "Tokeni ya bot",
  "token_not_found": "Tokeni haijapatikana",
  "bot_not_found": "Bot haijapatikana",
  "error_try_again": "Hitilafu imetokea, tafadhali jaribu tena",
  "back": "Rudi nyuma",
  "cancel": "Ghairi",
  "token_invalid": "Tokeni si sahihi",
  "token_validation_error": "Hitilafu ya uthibitishaji wa tokeni",
  "bot_already_exists": "Bot hii tayari ipo",
  "creating_bot_app": "Inaunda programu ya bot...",
  "start_bot_success": "Bot imeanza kwa mafanikio",
  "start_bot_error": "Hitilafu ilipotokea wakati wa kuanza bot",
  "bot_saved_success": "Bot imehifadhiwa kwa mafanikio",
  "delete_confirmation": "Uthibitisho wa kufuta",
  "this_action_irreversible": "Hatua hii haiwezi kubatilishwa",
  "yes_delete": "Ndio, futa",
  "no_cancel": "Hapana, ghairi",
  "delete_scheduled": "Kufuta kumewekwa ratiba",
  "deletion_cancelled": "Kufuta kumefutwa",
  "cancel_deletion": "Ghairi kufuta",
  "bot_info_title": "Maelezo ya bot",
  "start_child_bot": "Anzisha bot",
  "stop_child_bot": "Simamisha bot",
  "restart_child_bot": "Anzisha upya bot",
  "bot_settings": "Mipangilio ya bot",
  "bot_analytics": "Takwimu za bot",
  "bot_logs": "Rekodi za bot",
  "bot_status_online": "Mtandaoni",
  "bot_status_offline": "Nje ya mtandao",
  "language_selection": "Chagua lugha",
  "language_changed": "Lugha imebadilishwa kwa mafanikio",
  "bot_manager_title": "Meneja wa bot",
  "available_commands": "Amri zinazopatikana",
  "change_language": "Badilisha lugha",
  "manage_bots": "Simamia bot",
  "help_command": "Msaada",
  "current_features": "Vipengele vya sasa",
  "multilingual_support": "Msaada wa lugha nyingi",
  "bot_management": "Usimamizi wa bot",
  "user_preferences": "Mapendeleo ya mtumiaji",
  "demo_mode": "Hali ya majaribio imewashwa",
  "welcome": "Karibu! Tafadhali chagua lugha yako:",
  "data_export": "Hamisha data"
}
    },
    'he': {  # ◊¢◊ë◊®◊ô◊™
        # 'example_key': 'Translation in ◊¢◊ë◊®◊ô◊™'
        {
  "bot_token": "◊ê◊°◊ô◊û◊ï◊ü ◊î◊ë◊ï◊ò",
  "token_not_found": "◊î◊ê◊°◊ô◊û◊ï◊ü ◊ú◊ê ◊†◊û◊¶◊ê",
  "bot_not_found": "◊î◊ë◊ï◊ò ◊ú◊ê ◊†◊û◊¶◊ê",
  "error_try_again": "◊©◊í◊ô◊ê◊î, ◊†◊°◊î ◊©◊ï◊ë",
  "back": "◊ó◊ñ◊®◊î",
  "cancel": "◊ë◊ô◊ò◊ï◊ú",
  "token_invalid": "◊ê◊°◊ô◊û◊ï◊ü ◊©◊í◊ï◊ô",
  "token_validation_error": "◊©◊í◊ô◊ê◊î ◊ë◊ê◊ô◊û◊ï◊™ ◊î◊ê◊°◊ô◊û◊ï◊ü",
  "bot_already_exists": "◊î◊ë◊ï◊ò ◊õ◊ë◊® ◊ß◊ô◊ô◊ù",
  "creating_bot_app": "◊ô◊ï◊¶◊® ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™ ◊ë◊ï◊ò...",
  "start_bot_success": "◊î◊ë◊ï◊ò ◊î◊ï◊§◊¢◊ú ◊ë◊î◊¶◊ú◊ó◊î",
  "start_bot_error": "◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊î◊§◊¢◊ú◊™ ◊î◊ë◊ï◊ò",
  "bot_saved_success": "◊î◊ë◊ï◊ò ◊†◊©◊û◊® ◊ë◊î◊¶◊ú◊ó◊î",
  "delete_confirmation": "◊ê◊ô◊©◊ï◊® ◊û◊ó◊ô◊ß◊î",
  "this_action_irreversible": "◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊ê◊ô◊†◊î ◊î◊§◊ô◊õ◊î",
  "yes_delete": "◊õ◊ü, ◊û◊ó◊ß",
  "no_cancel": "◊ú◊ê, ◊ë◊ò◊ú",
  "delete_scheduled": "◊î◊û◊ó◊ô◊ß◊î ◊™◊ï◊ñ◊û◊†◊î",
  "deletion_cancelled": "◊î◊û◊ó◊ô◊ß◊î ◊ë◊ï◊ò◊ú◊î",
  "cancel_deletion": "◊ë◊ò◊ú ◊û◊ó◊ô◊ß◊î",
  "bot_info_title": "◊û◊ô◊ì◊¢ ◊¢◊ú ◊î◊ë◊ï◊ò",
  "start_child_bot": "◊î◊§◊¢◊ú◊™ ◊î◊ë◊ï◊ò",
  "stop_child_bot": "◊î◊§◊°◊ß◊™ ◊î◊ë◊ï◊ò",
  "restart_child_bot": "◊ê◊™◊ó◊ï◊ú ◊î◊ë◊ï◊ò",
  "bot_settings": "◊î◊í◊ì◊®◊ï◊™ ◊î◊ë◊ï◊ò",
  "bot_analytics": "◊†◊ô◊™◊ï◊ó ◊†◊™◊ï◊†◊ô ◊î◊ë◊ï◊ò",
  "bot_logs": "◊ô◊ï◊û◊†◊ô ◊î◊ë◊ï◊ò",
  "bot_status_online": "◊û◊ß◊ï◊ï◊ü",
  "bot_status_offline": "◊ú◊ê ◊û◊ß◊ï◊ï◊ü",
  "language_selection": "◊ë◊ó◊ô◊®◊™ ◊©◊§◊î",
  "language_changed": "◊î◊©◊§◊î ◊©◊ï◊†◊™◊î ◊ë◊î◊¶◊ú◊ó◊î",
  "bot_manager_title": "◊û◊†◊î◊ú ◊î◊ë◊ï◊ò◊ô◊ù",
  "available_commands": "◊§◊ß◊ï◊ì◊ï◊™ ◊ñ◊û◊ô◊†◊ï◊™",
  "change_language": "◊©◊†◊î ◊©◊§◊î",
  "manage_bots": "◊†◊ô◊î◊ï◊ú ◊ë◊ï◊ò◊ô◊ù",
  "help_command": "◊¢◊ñ◊®◊î",
  "current_features": "◊§◊ô◊¶◊≥◊®◊ô◊ù ◊†◊ï◊õ◊ó◊ô◊ô◊ù",
  "multilingual_support": "◊™◊û◊ô◊õ◊î ◊®◊ë÷æ◊ú◊©◊ï◊†◊ô◊™",
  "bot_management": "◊†◊ô◊î◊ï◊ú ◊ë◊ï◊ò◊ô◊ù",
  "user_preferences": "◊î◊¢◊ì◊§◊ï◊™ ◊û◊©◊™◊û◊©",
  "demo_mode": "◊û◊¶◊ë ◊î◊ì◊í◊û◊î ◊§◊¢◊ô◊ú",
  "welcome": "◊ë◊®◊ï◊ö ◊î◊ë◊ê! ◊ê◊†◊ê ◊ë◊ó◊® ◊©◊§◊î:",
  "data_export": "◊ô◊ô◊¶◊ï◊ê ◊†◊™◊ï◊†◊ô◊ù"
}
    },
    'ro': {  # Rom√¢nƒÉ
        # 'example_key': 'Translation in Rom√¢nƒÉ'
        {
  "bot_token": "Tokenul botului",
  "token_not_found": "Tokenul nu a fost gƒÉsit",
  "bot_not_found": "Botul nu a fost gƒÉsit",
  "error_try_again": "Eroare, te rog √ÆncearcƒÉ din nou",
  "back": "√énapoi",
  "cancel": "AnuleazƒÉ",
  "token_invalid": "Token invalid",
  "token_validation_error": "Eroare la validarea tokenului",
  "bot_already_exists": "Acest bot existƒÉ deja",
  "creating_bot_app": "Se creeazƒÉ aplica»õia botului...",
  "start_bot_success": "Botul a fost pornit cu succes",
  "start_bot_error": "Eroare la pornirea botului",
  "bot_saved_success": "Botul a fost salvat cu succes",
  "delete_confirmation": "Confirmare »ôtergere",
  "this_action_irreversible": "AceastƒÉ ac»õiune este ireversibilƒÉ",
  "yes_delete": "Da, »ôterge",
  "no_cancel": "Nu, anuleazƒÉ",
  "delete_scheduled": "»òtergerea a fost programatƒÉ",
  "deletion_cancelled": "»òtergerea a fost anulatƒÉ",
  "cancel_deletion": "AnuleazƒÉ »ôtergerea",
  "bot_info_title": "Informa»õii despre bot",
  "start_child_bot": "Porne»ôte botul",
  "stop_child_bot": "Opre»ôte botul",
  "restart_child_bot": "Reporne»ôte botul",
  "bot_settings": "SetƒÉri bot",
  "bot_analytics": "Analize bot",
  "bot_logs": "Jurnale bot",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Selectare limbƒÉ",
  "language_changed": "Limba a fost schimbatƒÉ cu succes",
  "bot_manager_title": "Managerul de boturi",
  "available_commands": "Comenzi disponibile",
  "change_language": "SchimbƒÉ limba",
  "manage_bots": "GestioneazƒÉ boturile",
  "help_command": "Ajutor",
  "current_features": "Func»õionalitƒÉ»õi curente",
  "multilingual_support": "Suport multilingv",
  "bot_management": "Administrare boturi",
  "user_preferences": "Preferin»õe utilizator",
  "demo_mode": "Mod demo activat",
  "welcome": "Bine ai venit! Alege limba:",
  "data_export": "ExportƒÉ datele"
}
    },
    'fa': {  # ŸÅÿßÿ±ÿ≥€å
        # 'example_key': 'Translation in ŸÅÿßÿ±ÿ≥€å'
        {
  "bot_token": "ÿ™Ÿà⁄©ŸÜ ÿ±ÿ®ÿßÿ™",
  "token_not_found": "ÿ™Ÿà⁄©ŸÜ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ",
  "bot_not_found": "ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ",
  "error_try_again": "ÿÆÿ∑ÿßÿå ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ",
  "back": "ÿ®ÿßÿ≤⁄Øÿ¥ÿ™",
  "cancel": "ŸÑÿ∫Ÿà",
  "token_invalid": "ÿ™Ÿà⁄©ŸÜ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™",
  "token_validation_error": "ÿÆÿ∑ÿß ÿØÿ± ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿ™Ÿà⁄©ŸÜ",
  "bot_already_exists": "ÿß€åŸÜ ÿ±ÿ®ÿßÿ™ ŸÇÿ®ŸÑÿßŸã Ÿàÿ¨ŸàÿØ ÿØÿßÿ±ÿØ",
  "creating_bot_app": "ÿØÿ± ÿ≠ÿßŸÑ ÿ≥ÿßÿÆÿ™ ÿßŸæŸÑ€å⁄©€åÿ¥ŸÜ ÿ±ÿ®ÿßÿ™...",
  "start_bot_success": "ÿ±ÿ®ÿßÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ¥ÿØ",
  "start_bot_error": "ÿÆÿ∑ÿß ÿØÿ± ŸáŸÜ⁄ØÿßŸÖ ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ±ÿ®ÿßÿ™",
  "bot_saved_success": "ÿ±ÿ®ÿßÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ",
  "delete_confirmation": "ÿ™ÿ£€å€åÿØ ÿ≠ÿ∞ŸÅ",
  "this_action_irreversible": "ÿß€åŸÜ ÿπŸÖŸÑ€åÿßÿ™ ŸÇÿßÿ®ŸÑ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ŸÜ€åÿ≥ÿ™",
  "yes_delete": "ÿ®ŸÑŸáÿå ÿ≠ÿ∞ŸÅ ÿ¥ŸàÿØ",
  "no_cancel": "ÿÆ€åÿ±ÿå ŸÑÿ∫Ÿà ÿ¥ŸàÿØ",
  "delete_scheduled": "ÿ≠ÿ∞ŸÅ ÿ≤ŸÖÿßŸÜ‚Äåÿ®ŸÜÿØ€å ÿ¥ÿØŸá ÿßÿ≥ÿ™",
  "deletion_cancelled": "ÿ≠ÿ∞ŸÅ ŸÑÿ∫Ÿà ÿ¥ÿØ",
  "cancel_deletion": "ŸÑÿ∫Ÿà ÿ≠ÿ∞ŸÅ",
  "bot_info_title": "ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ±ÿ®ÿßÿ™",
  "start_child_bot": "ÿ¥ÿ±Ÿàÿπ ÿ±ÿ®ÿßÿ™",
  "stop_child_bot": "ÿ™ŸàŸÇŸÅ ÿ±ÿ®ÿßÿ™",
  "restart_child_bot": "ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÖÿ¨ÿØÿØ ÿ±ÿ®ÿßÿ™",
  "bot_settings": "ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ±ÿ®ÿßÿ™",
  "bot_analytics": "ÿ™ÿ≠ŸÑ€åŸÑ‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™",
  "bot_logs": "⁄Øÿ≤ÿßÿ±ÿ¥‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™",
  "bot_status_online": "ÿ¢ŸÜŸÑÿß€åŸÜ",
  "bot_status_offline": "ÿ¢ŸÅŸÑÿß€åŸÜ",
  "language_selection": "ÿßŸÜÿ™ÿÆÿßÿ® ÿ≤ÿ®ÿßŸÜ",
  "language_changed": "ÿ≤ÿ®ÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ",
  "bot_manager_title": "ŸÖÿØ€åÿ± ÿ±ÿ®ÿßÿ™",
  "available_commands": "ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ ŸÇÿßÿ®ŸÑ ÿßÿ≥ÿ™ŸÅÿßÿØŸá",
  "change_language": "ÿ™ÿ∫€å€åÿ± ÿ≤ÿ®ÿßŸÜ",
  "manage_bots": "ŸÖÿØ€åÿ±€åÿ™ ÿ±ÿ®ÿßÿ™‚ÄåŸáÿß",
  "help_command": "ÿ±ÿßŸáŸÜŸÖÿß",
  "current_features": "Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß€å ŸÅÿπŸÑ€å",
  "multilingual_support": "Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ⁄ÜŸÜÿØÿ≤ÿ®ÿßŸÜŸá",
  "bot_management": "ŸÖÿØ€åÿ±€åÿ™ ÿ±ÿ®ÿßÿ™",
  "user_preferences": "ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±",
  "demo_mode": "ÿ≠ÿßŸÑÿ™ ÿØŸÖŸà ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™",
  "welcome": "ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ! ŸÑÿ∑ŸÅÿßŸã ÿ≤ÿ®ÿßŸÜ ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
  "data_export": "ÿÆÿ±Ÿàÿ¨€å ⁄Øÿ±ŸÅÿ™ŸÜ ÿßÿ≤ ÿØÿßÿØŸá‚ÄåŸáÿß"
}
    },
    'ms': {  # Bahasa Melayu
        # 'example_key': 'Translation in Bahasa Melayu'
        {
  "bot_token": "Token bot",
  "token_not_found": "Token tidak dijumpai",
  "bot_not_found": "Bot tidak dijumpai",
  "error_try_again": "Ralat berlaku, sila cuba lagi",
  "back": "Kembali",
  "cancel": "Batal",
  "token_invalid": "Token tidak sah",
  "token_validation_error": "Ralat pengesahan token",
  "bot_already_exists": "Bot ini sudah wujud",
  "creating_bot_app": "Sedang mencipta aplikasi bot...",
  "start_bot_success": "Bot berjaya dimulakan",
  "start_bot_error": "Ralat semasa memulakan bot",
  "bot_saved_success": "Bot berjaya disimpan",
  "delete_confirmation": "Pengesahan penghapusan",
  "this_action_irreversible": "Tindakan ini tidak boleh diundurkan",
  "yes_delete": "Ya, padam",
  "no_cancel": "Tidak, batal",
  "delete_scheduled": "Penghapusan telah dijadualkan",
  "deletion_cancelled": "Penghapusan telah dibatalkan",
  "cancel_deletion": "Batal penghapusan",
  "bot_info_title": "Maklumat bot",
  "start_child_bot": "Mulakan bot",
  "stop_child_bot": "Hentikan bot",
  "restart_child_bot": "Mulakan semula bot",
  "bot_settings": "Tetapan bot",
  "bot_analytics": "Analitik bot",
  "bot_logs": "Log bot",
  "bot_status_online": "Dalam talian",
  "bot_status_offline": "Luar talian",
  "language_selection": "Pemilihan bahasa",
  "language_changed": "Bahasa telah berjaya ditukar",
  "bot_manager_title": "Pengurus bot",
  "available_commands": "Arahan yang tersedia",
  "change_language": "Tukar bahasa",
  "manage_bots": "Urus bot",
  "help_command": "Bantuan",
  "current_features": "Ciri-ciri semasa",
  "multilingual_support": "Sokongan berbilang bahasa",
  "bot_management": "Pengurusan bot",
  "user_preferences": "Keutamaan pengguna",
  "demo_mode": "Mod demo diaktifkan",
  "welcome": "Selamat datang! Sila pilih bahasa anda:",
  "data_export": "Eksport data"
}
    },
    'id': {  # Bahasa Indonesia
        # 'example_key': 'Translation in Bahasa Indonesia'
        {
  "bot_token": "Token bot",
  "token_not_found": "Token tidak ditemukan",
  "bot_not_found": "Bot tidak ditemukan",
  "error_try_again": "Terjadi kesalahan, silakan coba lagi",
  "back": "Kembali",
  "cancel": "Batalkan",
  "token_invalid": "Token tidak valid",
  "token_validation_error": "Kesalahan validasi token",
  "bot_already_exists": "Bot ini sudah ada",
  "creating_bot_app": "Membuat aplikasi bot...",
  "start_bot_success": "Bot berhasil dijalankan",
  "start_bot_error": "Kesalahan saat menjalankan bot",
  "bot_saved_success": "Bot berhasil disimpan",
  "delete_confirmation": "Konfirmasi penghapusan",
  "this_action_irreversible": "Tindakan ini tidak dapat dibatalkan",
  "yes_delete": "Ya, hapus",
  "no_cancel": "Tidak, batalkan",
  "delete_scheduled": "Penghapusan dijadwalkan",
  "deletion_cancelled": "Penghapusan dibatalkan",
  "cancel_deletion": "Batalkan penghapusan",
  "bot_info_title": "Informasi bot",
  "start_child_bot": "Jalankan bot",
  "stop_child_bot": "Hentikan bot",
  "restart_child_bot": "Mulai ulang bot",
  "bot_settings": "Pengaturan bot",
  "bot_analytics": "Analitik bot",
  "bot_logs": "Log bot",
  "bot_status_online": "Online",
  "bot_status_offline": "Offline",
  "language_selection": "Pemilihan bahasa",
  "language_changed": "Bahasa berhasil diubah",
  "bot_manager_title": "Manajer bot",
  "available_commands": "Perintah yang tersedia",
  "change_language": "Ubah bahasa",
  "manage_bots": "Kelola bot",
  "help_command": "Bantuan",
  "current_features": "Fitur saat ini",
  "multilingual_support": "Dukungan multibahasa",
  "bot_management": "Manajemen bot",
  "user_preferences": "Preferensi pengguna",
  "demo_mode": "Mode demo aktif",
  "welcome": "Selamat datang! Silakan pilih bahasa Anda:",
  "data_export": "Ekspor data"
}
    },
}
def get_text(lang: str, key: str) -> str:
    """R√©cup√®re le texte traduit selon la langue"""
    return TRANSLATIONS.get(lang, TRANSLATIONS['fr']).get(key, key)

        # La fonction register_user_bot_handlers est asynchrone et sera appel√©e dans la t√¢che asyncio
        
    return application
    except Exception as e:
    logger.error(f"Erreur dans handle_pdg_token_input: {e} [ERR_BLM_037]", exc_info=True)
    await update.message.reply_text("‚ùå Erreur lors de la configuration du Bot PDG. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_037)")

async def check_bot_limits(user_id: int) -> bool:
    """V√©rifie si l'utilisateur peut ajouter un nouveau bot"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    # Check for trial period for 'free' plan
    if plan == "free":
        trial_end_date = db.get_user_trial_end_date(user_id)
        if trial_end_date and datetime.now() < datetime.fromisoformat(trial_end_date):
            # During trial, allow up to 10 bots
            if len(user_bots) >= 10:
                return False
        else:
            # After trial, apply plan limits for 'free' plan
            if len(user_bots) >= plan_limits["bots"]:
                return False
    else:
        # For other plans, apply their limits directly
        if len(user_bots) >= plan_limits["bots"]:
            return False
    return True

async def check_group_limits(user_id: int, new_group_id: int = 0) -> bool:
    """V√©rifie les limites de groupes"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    total_groups = sum(len(bot.get("groups", [])) for bot in user_bots)
    if new_group_id > 0:
        total_groups += 1
    
    if total_groups >= plan_limits["groups"]:
        return False
    return Truedef get_text(lang: str, key: str) -> str:
    """R√©cup√®re le texte traduit selon la langue"""
    return TRANSLATIONS.get(lang, TRANSLATIONS['fr']).get(key, key)

# La fonction register_user_bot_handlers est asynchrone et sera appel√©e dans la t√¢che asyncio
    return application
except Exception as e:
    logger.error(f"Erreur dans handle_pdg_token_input: {e} [ERR_BLM_A37]", exc_info=True)
    await update.message.reply_text("Erreur lors de la configuration du Bot PDG. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_B37)")

async def check_bot_limits(user_id: int) -> bool:
    """V√©rifie si l'utilisateur peut ajouter un nouveau bot"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    # Check for trial period for 'free' plan
    if plan == "free":
        trial_end_date = db.get_user_trial_end_date(user_id)
        if trial_end_date and datetime.now() < datetime.fromisoformat(trial_end_date):
            # During trial, allow up to 10 bots
            if len(user_bots) >= 10:
                return False
        else:
            # After trial, apply plan limits for 'free' plan
            if len(user_bots) >= plan_limits["bots"]:
                return False
    else:
        # For other plans, apply their limits directly
        if len(user_bots) >= plan_limits["bots"]:
            return False
    return True

# Comprehensive multilingual translations
        # La fonction register_user_bot_handlers est asynchrone et sera appel√©e dans la t√¢che asyncio
        
    return application
    except Exception as e:
        logger.error(f"Erreur initialisation bot fils: {e}")
        return None

async def check_bot_limits(user_id: int) -> bool:
    """V√©rifie si l'utilisateur peut ajouter un nouveau bot"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    # Check for trial period for 'free' plan
    if plan == "free":
        trial_end_date = db.get_user_trial_end_date(user_id)
        if trial_end_date and datetime.now() < datetime.fromisoformat(trial_end_date):
            # During trial, allow up to 10 bots
            if len(user_bots) >= 10:
                return False
        else:
            # After trial, apply plan limits for 'free' plan
            if len(user_bots) >= plan_limits["bots"]:
                return False
    else:
        # For other plans, apply their limits directly
        if len(user_bots) >= plan_limits["bots"]:
            return False
    return True

async def check_group_limits(user_id: int, new_group_id: int = 0) -> bool:
    """V√©rifie les limites de groupes"""
    plan = get_user_plan(user_id)
    user_bots = db.get_user_bots(user_id)
    plan_limits = get_plan_limits(plan)
    
    total_groups = sum(len(bot.get("groups", [])) for bot in user_bots)
    if new_group_id > 0:
        total_groups += 1
    
    if total_groups >= plan_limits["groups"]:
        return False
    return True

class BotLinkingManager:

    @staticmethod
    async def handle_main_start(update: Update, context: CallbackContext):
        """Handler /start pour le bot principal"""
        try:
            user_id = update.effective_user.id
            
            if db.is_new_user(user_id):
                db.users[user_id] = {
                    'state': UserStates.INITIAL.value,
                    'language': 'fr',
                    'trial_end_date': (datetime.now() + timedelta(days=14)).isoformat()
                }
                db.save_to_disk('users', {str(user_id): db.users[user_id]})
                await BotLinkingManager.show_language_options(update, context)
            else:
                await show_main_menu(update, context)

        except Exception as e:
            logger.error(f"Erreur dans handle_main_start: {e} [ERR_BLM_004]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de l'initialisation. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_004)")

    @staticmethod
    async def show_language_options(update: Update, context: CallbackContext):
        """Affiche les options de langue"""
        try:
            if update.message:
                user_id = update.message.from_user.id
                lang = db.get_user_language(user_id) or 'fr'
            elif update.callback_query:
                query = update.callback_query
                await query.answer()
                user_id = query.from_user.id
                lang = db.get_user_language(user_id) or 'fr'
            
            text = (
                "üåê Veuillez choisir votre langue pr√©f√©r√©e :"
                if lang == 'fr' else
                "üåê Please choose your preferred language:"
            )
            
            keyboard = [
                [
                    InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="setlang_fr"),
                    InlineKeyboardButton("üá¨üáß English", callback_data="setlang_en"),
                    InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="setlang_es")
                ],
                [
                    InlineKeyboardButton("üá©üá™ Deutsch", callback_data="setlang_de"),
                    InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data="setlang_zh"),
                    InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="setlang_hi")
                ],
                [
                    InlineKeyboardButton("üáØüáµ Êó•Êú¨Ë™û", callback_data="setlang_ja"),
                    InlineKeyboardButton("üá∞üá∑ ÌïúÍµ≠Ïñ¥", callback_data="setlang_ko"),
                    InlineKeyboardButton("üáπüá≠ ‡πÑ‡∏ó‡∏¢", callback_data="setlang_th")
                ],
                [
                    InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="setlang_ru"),
                    InlineKeyboardButton("üáµüáπ Portugu√™s", callback_data="setlang_pt"),
                    InlineKeyboardButton("üáÆüáπ Italiano", callback_data="setlang_it")
                ],
                [
                    InlineKeyboardButton("üîô Retour" if lang == 'fr' else "üîô Back", 
                                       callback_data="back_to_main")
                ]
            ]
            
            if update.callback_query:
                await query.edit_message_text(
                    text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="HTML"
                )
            else:
                await update.message.reply_text(
                    text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="HTML"
                )
        except Exception as e:
            logger.error(f"Erreur dans show_language_options: {e} [ERR_BLM_005]", exc_info=True)

    @staticmethod
    async def set_language_callback(update: Update, context: CallbackContext):
        """D√©finit la langue de l'utilisateur via callback"""
        try:
            query = update.callback_query
            await query.answer()
            lang_code = query.data.split("_")[1]
            user_id = query.from_user.id
            
            db.set_user_language(user_id, lang_code)
            
            lang_names = {
    'fr': "Fran√ßais",
    'en': "English",
    'es': "Espa√±ol", 
    'de': "Deutsch",
    'zh': "‰∏≠Êñá",
    'hi': "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä",
    'ja': "Êó•Êú¨Ë™û",
    'ko': "ÌïúÍµ≠Ïñ¥",
    'th': "‡πÑ‡∏ó‡∏¢",
    'ru': "–†—É—Å—Å–∫–∏–π",
    'pt': "Portugu√™s",
    'it': "Italiano",
    'ar': "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
    'tr': "T√ºrk√ße",
    'vi': "Ti·∫øng Vi·ªát",
    'pl': "Polski",
    'nl': "Nederlands",
    'sv': "Svenska",
    'uk': "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
    'sw': "Kiswahili",
    'he': "◊¢◊ë◊®◊ô◊™",
    'ro': "Rom√¢nƒÉ",
    'fa': "ŸÅÿßÿ±ÿ≥€å",
    'ms': "Bahasa Melayu",
    'id': "Bahasa Indonesia"
}
            
            confirmation = (
                f"‚úÖ Langue d√©finie sur {lang_names[lang_code]}"
                if lang_code == 'fr' else
                f"‚úÖ Language set to {lang_names[lang_code]}"
            )
            
            await query.edit_message_text(
                confirmation,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(
                        "‚úÖ Commencer" if lang_code == 'fr' else "‚úÖ Start",
                        callback_data="terms_accepted"
                    )]
                ])
            )
        except Exception as e:
            logger.error(f"Erreur dans set_language_callback: {e} [ERR_BLM_006]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_006)")

    @staticmethod
    async def accept_terms(update: Update, context: CallbackContext):
        """Affiche et g√®re l'acceptation des conditions"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            terms_text = (
                "üìú <b>Conditions d'utilisation</b>\n\n"
                "1. Confidentialit√© : Vos donn√©es sont crypt√©es\n"
                "2. Utilisation : Interdiction de spam\n"
                "3. S√©curit√© : Ne partagez pas vos tokens\n\n"
                "En continuant, vous acceptez nos conditions."
                if lang == 'fr' else
                "üìú <b>Terms of Service</b>\n\n"
                "1. Privacy: Your data is encrypted\n"
                "2. Usage: No spamming allowed\n"
                "3. Security: Don't share your tokens\n\n"
                "By continuing, you accept our terms."
            )
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ J'accepte" if lang == 'fr' else "‚úÖ I Accept", 
                                     callback_data="terms_accepted")],
                [InlineKeyboardButton("‚ùå Refuser" if lang == 'fr' else "‚ùå Decline", 
                                    callback_data="terms_declined")]
            ]
            
            await query.edit_message_text(
                terms_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Erreur dans accept_terms: {e} [ERR_BLM_007]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_007)")

    @staticmethod
    async def terms_accepted(update: Update, context: CallbackContext):
        """Passe au menu principal apr√®s acceptation"""
        try:
            query = update.callback_query
            await query.answer()
            db.save_terms_acceptance(query.from_user.id)
            await show_main_menu(update, context)
        except Exception as e:
            logger.error(f"Erreur dans terms_accepted: {e} [ERR_BLM_008]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_008)")

    @staticmethod
    async def start_bot_creation(update: Update, context: CallbackContext):
        """D√©marre le processus de cr√©ation de bot"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            text = (
                "ü§ñ Cr√©ation de votre bot personnel\n\n"
                "Avez-vous d√©j√† un bot Telegram existant ?"
                if lang == 'fr' else
                "ü§ñ Creating your bot assistant\n\n"
                "Do you already have an existing Telegram bot?"
            )
            
            if update.message:
                await update.message.reply_text(
                    text, 
                    reply_markup=KeyboardManager.bot_creation_options(lang)
                )
            else:
                await query.edit_message_text(
                    text, 
                    reply_markup=KeyboardManager.bot_creation_options(lang)
                )
        except Exception as e:
            logger.error(f"Erreur dans start_bot_creation: {e} [ERR_BLM_009]", exc_info=True)
            if update.callback_query:
                await update.callback_query.message.reply_text("‚ùå Erreur lors du d√©marrage. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_009)")
            else:
                await update.message.reply_text("‚ùå Erreur lors du d√©marrage. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_009)")

    @staticmethod
    async def handle_has_token_yes(update: Update, context: CallbackContext):
        """G√®re la r√©ponse 'Oui, j'ai un token'"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'

            security_advice = (
                "üîê Conseil de s√©curit√© :\n"
                "1. Ne partagez jamais votre token publiquement\n"
                "2. Utilisez /revoke dans @BotFather si compromis\n"
                "3. Notre syst√®me le chiffrera automatiquement"
                if lang == 'fr' else
                "üîê Security advice:\n"
                "1. Never share your token publicly\n"
                "2. Use /revoke in @BotFather if compromised\n"
                "3. Our system will encrypt it automatically"
            )

            prompt = "Parfait ! Veuillez m'envoyer votre token :" if lang == 'fr' else "Perfect! Please send me your token:"
            await query.edit_message_text(f"‚úÖ {prompt}\n\n{security_advice}", parse_mode="Markdown")
            context.user_data["awaiting_token"] = True
        except Exception as e:
            logger.error(f"Erreur dans handle_has_token_yes: {e} [ERR_BLM_010]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_010)")

    @staticmethod
    async def handle_has_token_no(update: Update, context: CallbackContext):
        """G√®re la r√©ponse 'Non, je n'ai pas de token'"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'

            creation_guide = (
                "‚öôÔ∏è Cr√©ation de votre premier bot :\n\n"
                "1. Ouvrez @BotFather\n"
                "2. Envoyez /newbot\n"
                "3. Suivez les instructions\n"
                "4. Copiez le token g√©n√©r√©\n\n"
                "‚ö†Ô∏è Consignes de s√©curit√© :\n"
                "- Ne partagez JAMAIS ce token\n"
                "- Changez-le imm√©diatement si compromis\n"
                "- Notre syst√®me le chiffrera automatiquement\n\n"
            )

            await query.edit_message_text(creation_guide, parse_mode="Markdown")
            context.user_data["awaiting_token"] = True
        except Exception as e:
            logger.error(f"Erreur dans handle_has_token_no: {e} [ERR_BLM_011]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_011)")

    @staticmethod
    async def handle_token_input(update: Update, context: CallbackContext):
        if not context.user_data.get("awaiting_token"):
            return

        try:
            token = update.message.text.strip()
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'

            # Validation avec retour des donn√©es
            bot_data = sync_validate_bot_token(token)
            if not bot_data:
                error_msg = "‚ùå Token invalide. Veuillez v√©rifier et r√©essayer."
                await update.message.reply_text(error_msg)
                return

            # Utilisez les donn√©es retourn√©es
            bot_username = bot_data.get("username")
            bot_name = bot_data.get("first_name")
            
            bot_link = f"https://t.me/{bot_username}" # Define bot_link here
            
            creation_time = datetime.now().isoformat()
            db.save_user_bot(user_id, token, bot_username, bot_name, creation_time)


            # Lancement du bot enfant
            try:
                child_app = init_child_bot(token, bot_username)
                if child_app:
                    # Enregistrer les handlers sp√©cifiques au bot fils
                    from utils.user_features import setup_user_bot_handlers
                    await setup_user_bot_handlers(child_app)                    
                    # D√©marrer le polling du bot fils en arri√®re-plan
                    import asyncio
                    await child_app.initialize()
                    await child_app.start()
                    asyncio.create_task(child_app.updater.start_polling())
            # Message de succ√®s avec boutons
            success_text = (
                f"‚úÖ Bot @{bot_username} connect√© avec succ√®s !\n\n"
                f"Vous pouvez maintenant utiliser votre bot : {bot_link}\n\n"
                f"N'oubliez pas de consulter votre plan pour les limites et fonctionnalit√©s : /planinfo"
                if lang == 'fr' else
                f"‚úÖ Bot @{bot_username} successfully connected!\n\n"
                f"You can now use your bot: {bot_link}\n\n"
                f"Don't forget to check your plan for limits and features: /planinfo"
            )
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("ü§ñ Aller √† votre bot", url=bot_link),
                    InlineKeyboardButton("üìä Mon plan", callback_data="show_plan_info")
                ]
            ])

            await update.message.reply_text(success_text, reply_markup=keyboard, parse_mode="HTML")

            # Message de bienvenue dans le nouveau bot


        except Exception as e:
            logger.error(f"ERREUR: {str(e)}", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors du traitement")
        finally:
            context.user_data["awaiting_token"] = False

    @staticmethod
    async def log_violation(vtype: str, user_id: int, plan: str, context: CallbackContext):
        """Journalise les violations de limites"""
        try:
            pdg = db.pdg_config
            if not pdg or not pdg.get("is_active"):
                return
                
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_text = f"[{vtype}] {now} ‚Äî <code>{user_id}</code> d√©passement ({plan})"
            if pdg:
                # Ensure the main bot sends the message to the PDG owner
                await context.bot.send_message(pdg["owner"], log_text, parse_mode="HTML")
                if pdg.get("log_channel"):
                    # Ensure the main bot sends the message to the log channel
                    await context.bot.send_message(pdg["log_channel"], log_text, parse_mode="HTML")
                    db.setdefault("log_archive", []).append({
                        "type": vtype,
                        "timestamp": now,
                        "user_id": user_id,
                        "plan": plan
                    })
        except Exception as e:
            logger.error(f"Erreur dans log_violation: {e} [ERR_BLM_016]", exc_info=True)

    @staticmethod
    async def handle_services(update: Update, context: CallbackContext):
        """G√®re le bouton üõ†Ô∏è Services et la commande /services"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            text = "üõ†Ô∏è <b>Services disponibles</b> :" if lang == 'fr' else "üõ†Ô∏è <b>Available Services</b>:"
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ü§ñ Mes bots cr√©√©s ü§ñ", callback_data="my_bots")],
                [InlineKeyboardButton("üîç Recherche avanc√©e", callback_data="services_search")],
                [InlineKeyboardButton("‚ù§Ô∏è Groupe de rencontre üë©‚Äç‚ù§Ô∏è‚Äçüë®", callback_data="services_meetup")],
                [InlineKeyboardButton("üîÑ Change format fichier üìÅ", callback_data="services_format")],
                [InlineKeyboardButton("üìù Texte vers voixüéôÔ∏è", callback_data="services_tts")],
                [InlineKeyboardButton("üéôÔ∏è Voix vers texte üìù", callback_data="services_stt")],
                [InlineKeyboardButton("üì¢ Cr√©er un post üì¢", callback_data="services_post")],
                [InlineKeyboardButton("üìä Cr√©√© un sondage üìä", callback_data="services_poll")],
                [InlineKeyboardButton("üîó Cr√©e un lien court üîó", callback_data="services_shortlink")],
                [InlineKeyboardButton("üöÄ Cr√©√© une publicit√© üöÄ", callback_data="services_ads")],
                [InlineKeyboardButton("ü§ë Investissement intelligent ü§ë", callback_data="services_investment")],
                [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
            ])
            
            if update.message:
                await update.message.reply_text(text, parse_mode="HTML", reply_markup=keyboard)
            else:
                await query.edit_message_text(text, parse_mode="HTML", reply_markup=keyboard)
                
        except Exception as e:
            logger.error(f"Erreur dans handle_services: {e} [ERR_BLM_017]", exc_info=True)
            if update.callback_query:
                await update.callback_query.message.reply_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_017)")
            else:
                await update.message.reply_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_017)")

    @staticmethod
    async def handle_service_submenu(update: Update, context: CallbackContext):
        """G√®re les sous-menus des services"""
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        
        text = "üöß Fonctionnalit√© en cours de construction" if lang == 'fr' else "üöß Feature under construction"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîô Retour", callback_data="back_to_services")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)

    @staticmethod
    async def handle_back_to_services(update: Update, context: CallbackContext):
        """Retour au menu des services"""
        query = update.callback_query
        await query.answer()
        await BotLinkingManager.handle_services(update, context)

    @staticmethod
    async def handle_help_command(update: Update, context: CallbackContext):
        """G√®re le bouton 'Aide'"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
            
            lang = db.get_user_language(user_id) or 'fr'

            help_text = (
                "üÜò <b>Aide TeleSucheBot</b>\n\n"
                "<b>Fonctionnalit√©s principales :</b>\n"
                "‚Ä¢ ‚öôÔ∏è Cloner votre bot : Cr√©ez votre propre assistant\n"
                "‚Ä¢ ü§ù Communaut√© : Rejoignez nos canaux et groupes\n"
                "‚Ä¢ üõ†Ô∏è Services : Acc√©dez √† nos outils avanc√©s\n\n"
                "<b>Support technique :</b>\n"
                "üëâ @TeleSucheSupport\n"
                "üì¨ support@telesuche.com\n\n"
                "<b>Documentation :</b>\n"
                "üåê https://docs.telesuche.com"
                if lang == 'fr' else
                "üÜò <b>TeleSucheBot Help</b>\n\n"
                "<b>Main features:</b>\n"
                "‚Ä¢ ‚öôÔ∏è Clone your bot: Create your personal assistant\n"
                "‚Ä¢ ü§ù Community: Join our channels and groups\n"
                "‚Ä¢ üõ†Ô∏è Services: Access our advanced tools\n\n"
                "<b>Technical support:</b>\n"
                "üëâ @TeleSucheSupport\n"
                "üì¨ support@telesuche.com\n\n"
                "<b>Documentation :</b>\n"
                "üåê https://docs.telesuche.com"
            )
            
            if update.message:
                await update.message.reply_text(help_text, parse_mode="HTML")
            else:
                await query.edit_message_text(
                    help_text,
                    parse_mode="HTML",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîô Retour" if lang == 'fr' else "üîô Back", callback_data='back_to_main')]
                    ])
                )
        except Exception as e:
            logger.error(f"Erreur dans handle_help_command: {e}", exc_info=True)

    @staticmethod
    async def handle_upgrade_plan(update: Update, context: CallbackContext):
        """Affiche les options de mise √† niveau"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            text = (
                "üíé <b>Choisissez un plan</b>\n\n"
            )
            
            keyboard = []
            for plan_id, plan_data in PLANS.items():
                features_text = "\n".join([f"‚Ä¢ {f}" for f in plan_data["features"]])
                text += (
                    f"{plan_data['label']} ({plan_data['price']})\n"
                    f"{features_text}\n"
                    f"{plan_data['more_info_link']}\n\n"
                )
                keyboard.append([
                    InlineKeyboardButton(
                        f"{plan_data['label']} - {plan_data['price']}",
                        callback_data=f"plan_details:{plan_id}"
                    )
                ])
            
            keyboard.append([
                InlineKeyboardButton("üîô Retour", callback_data="back_to_main")
            ])

            await query.edit_message_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML"
            )

        except Exception as e:
            logger.error(f"Erreur dans handle_upgrade_plan: {e} [ERR_BLM_018]", exc_info=True)
            await query.edit_message_text(
                "‚ùå Erreur d'affichage des plans. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_018)"
                if lang == 'fr'
                else "‚ùå Error displaying plans. Contact support (@TeleSucheSupport) if the problem persists. (ERR_BLM_018)"
            )

    @staticmethod
    async def handle_confirm_upgrade(update: Update, context: CallbackContext):
        """Confirmation finale de l'upgrade"""
        try:
            query = update.callback_query
            await query.answer()
            plan_id = query.data.split(":")[1]
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'

            # Ici vous devriez int√©grer votre logique de paiement
            # Pour l'exemple, nous supposons que le paiement est valid√©
            payment_processor = PaymentProcessor()
            # Supposons que le plan a un prix et une devise associ√©s dans PLANS
            plan_price = PLANS[plan_id].get("price_value", 0.0) # Assurez-vous que PLANS contient 'price_value'
            plan_currency = PLANS[plan_id].get("currency", "USD") # Assurez-vous que PLANS contient 'currency'

            if await payment_processor.process_payment(user_id, plan_price, plan_currency, plan_id):
                db.set_user_plan(user_id, plan_id)
                await query.edit_message_text(
                    f"üéâ F√©licitations ! Votre compte a √©t√© upgrad√©." if lang == 'fr' \
                    else f"üéâ Congratulations! Your account has been upgraded."
                )
                # Envoyer un message avec les nouvelles limites
                await BotLinkingManager.show_plan_info(update, context)
            else:
                await query.edit_message_text(
                    "‚ùå √âchec du paiement. Veuillez r√©essayer." if lang == 'fr' \
                    else "‚ùå Payment failed. Please try again."
                )

        except Exception as e:
            logger.error(f"Erreur dans handle_confirm_upgrade: {e} [ERR_BLM_019]", exc_info=True)
            await query.edit_message_text(
                "‚ùå Erreur lors de la mise √† niveau. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_019)"
                if lang == 'fr'
                else "‚ùå Upgrade error. Contact support (@TeleSucheSupport) if the problem persists. (ERR_BLM_019)"
            )

    @staticmethod
    async def show_plan_info(update: Update, context: CallbackContext):
        """Affiche les informations du plan actuel"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            plan = get_user_plan(user_id)
            plan_data = PLANS.get(plan, PLANS["free"])
            plan_limits = get_plan_limits(plan)
            
            user_bots = db.get_user_bots(user_id)
            bot_count = len(user_bots)
            
            text = (
                f"üíé <b>Plan actuel : {plan_data['label']}</b>\n\n"
                f"üìä <b>Utilisation :</b>\n"
                f"‚Ä¢ Bots : {bot_count}/{plan_limits['bots']}\n"
                f"‚Ä¢ Groupes : 0/{plan_limits['groups']}\n\n"
                f"<b>Fonctionnalit√©s :</b>\n"
            )
            
            for feature in plan_data["features"]:
                text += f"‚Ä¢ {feature}\n"
                
            if plan == "free":
                text += f"\nüí° <b>Upgradez pour plus de fonctionnalit√©s !</b>"
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üöÄ Upgrade", callback_data="upgrade_plan")],
                    [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
                ])
            else:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
                ])
            
            if update.message:
                await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
            else:
                await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
                
        except Exception as e:
            logger.error(f"Erreur dans show_plan_info: {e} [ERR_BLM_020]", exc_info=True)

    @staticmethod
    async def handle_community(update: Update, context: CallbackContext):
        """G√®re le bouton 'Communaut√©'"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            text = (
                "ü§ù <b>Rejoignez notre communaut√© !</b>\n\n"
                "Connectez-vous avec d'autres utilisateurs, partagez vos exp√©riences et obtenez de l'aide."
                if lang == 'fr' else
                "ü§ù <b>Join our community!</b>\n\n"
                "Connect with other users, share experiences and get help."
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üì¢ Canal officiel", url="https://t.me/TeleSucheChannel")],
                [InlineKeyboardButton("üí¨ Groupe de discussion", url="https://t.me/TeleSucheGroup")],
                [InlineKeyboardButton("üÜò Support technique", url="https://t.me/TeleSucheSupport")],
                [InlineKeyboardButton("üîô Retour", callback_data="back_to_main")]
            ])
            
            if update.message:
                await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
            else:
                await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
                
        except Exception as e:
            logger.error(f"Erreur dans handle_community: {e} [ERR_BLM_021]", exc_info=True)

    @staticmethod
    async def handle_delete_bot_command(update: Update, context: CallbackContext):
        """G√®re la commande de suppression de bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            # Extraire l'ID du bot depuis le callback_data
            bot_id = query.data.split(":")[1]
            
            # R√©cup√©rer les informations du bot
            user_bots = db.get_user_bots(user_id)
            selected_bot = None
            for bot in user_bots:
                if bot.get("bot_username") == bot_id or str(bot.get("id", "")) == bot_id:
                    selected_bot = bot
                    break
                    
            if not selected_bot:
                await query.edit_message_text(
                    "‚ùå Bot non trouv√©" if lang == 'fr' else "‚ùå Bot not found"
                )
                return
                
            bot_username = selected_bot.get("bot_username", "Unknown")
            
            text = (
                f"‚ö†Ô∏è <b>Supprimer le bot</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"Cette action est irr√©versible. √ätes-vous s√ªr ?"
                if lang == 'fr' else
                f"‚ö†Ô∏è <b>Delete bot</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"This action is irreversible. Are you sure?"
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    "‚úÖ Oui, supprimer" if lang == 'fr' else "‚úÖ Yes, delete",
                    callback_data=f"confirm_delete:{bot_id}"
                )],
                [InlineKeyboardButton(
                    "‚ùå Annuler" if lang == 'fr' else "‚ùå Cancel",
                    callback_data="my_bots"
                )]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"Erreur dans handle_delete_bot_command: {e} [ERR_BLM_022]", exc_info=True)

    @staticmethod
    async def handle_final_delete_confirmation(update: Update, context: CallbackContext):
        """Confirmation finale pour supprimer un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            bot_id = query.data.split(":")[1]
            
            # Supprimer le bot de la base de donn√©es
            success = db.delete_user_bot(user_id, bot_id)
            
            if success:
                # Arr√™ter le bot s'il est en cours d'ex√©cution
                if bot_id in child_bots:
                    try:
                        app = child_bots[bot_id]
                        await app.stop()
                        del child_bots[bot_id]
                    except Exception as e:
                        logger.error(f"Erreur arr√™t bot {bot_id}: {e}")
                
                text = (
                    f"‚úÖ Bot supprim√© avec succ√®s !"
                    if lang == 'fr' else
                    f"‚úÖ Bot deleted successfully!"
                )
            else:
                text = (
                    f"‚ùå Erreur lors de la suppression"
                    if lang == 'fr' else
                    f"‚ùå Error during deletion"
                )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(
                    "üîô Mes bots" if lang == 'fr' else "üîô My bots",
                    callback_data="my_bots"
                )]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur dans handle_final_delete_confirmation: {e} [ERR_BLM_023]", exc_info=True)

    @staticmethod
    async def show_bot_token(update: Update, context: CallbackContext):
        """Affiche le token du bot."""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

            if not selected_bot:
                await query.edit_message_text(get_text(lang, 'bot_not_found'))
                return

            bot_token = selected_bot.get("token", "N/A")

            text = (
                f"<b>{get_text(lang, 'bot_token_title')}</b>\n\n"
                f"<code>{bot_token}</code>\n\n"
                f"{get_text(lang, 'bot_token_security')}"
            )
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'back_to_bot_info'), callback_data=f"show_bot_info:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans show_bot_token: {e} [ERR_BLM_038]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_038)")

    @staticmethod
    async def handle_under_construction(update: Update, context: CallbackContext):
        """G√®re les boutons 'En cours de construction !'"""
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        
        text = get_text(lang, 'under_construction')
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
        ])
        
        await query.edit_message_text(text, reply_markup=keyboard)

    @staticmethod
    async def show_bot_info(update: Update, context: CallbackContext):
        """Affiche les informations d√©taill√©es du bot."""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

            if not selected_bot:
                await query.edit_message_text(get_text(lang, 'bot_not_found'))
                return

            bot_name = selected_bot.get("bot_name", "N/A")
            creation_time = selected_bot.get("creation_time", "N/A")
            
            # Formatage de la date de cr√©ation
            if creation_time != "N/A":
                try:
                    from datetime import datetime
                    dt = datetime.fromisoformat(creation_time)
                    creation_date = dt.strftime("%Y-%m-%d")
                    creation_time_formatted = dt.strftime("%H:%M:%S")
                except:
                    creation_date = "2025-07-21"
                    creation_time_formatted = "17:33:59"
            else:
                creation_date = "2025-07-21"
                creation_time_formatted = "17:33:59"

            text = (
                f"<b>{get_text(lang, 'bot_info_title')}</b>\n\n"
                f"<b>{get_text(lang, 'name')}</b> : {bot_name}\n"
                f"<b>{get_text(lang, 'username')}</b> : @{bot_username}\n"
                f"<b>{get_text(lang, 'bot_id')}</b> : N/A\n"
                f"<b>{get_text(lang, 'creation_date')}</b> : \n"
                f"  ‚îúüìÜ {creation_date} \n"
                f"  ‚îîüïë{creation_time_formatted}.\n\n"
                f"<b>{get_text(lang, 'statistics')}</b>\n\n"
                f"{get_text(lang, 'earnings')} \n"
                f"  ‚îú {get_text(lang, 'total')} 565.00‚Ç¨\n"
                f"  ‚îú {get_text(lang, 'withdrawn')} 16.00‚Ç¨\n"
                f"  ‚îî {get_text(lang, 'pending')} 100.00‚Ç¨\n\n"
                f"  {get_text(lang, 'users')}\n"
                f"  ‚îú {get_text(lang, 'total_users')} 300600\n"
                f"  ‚îú {get_text(lang, 'active')} 240000\n"
                f"  ‚îî {get_text(lang, 'inactive')} 60000\n\n"
                f"  {get_text(lang, 'community')}\n"
                f"  ‚îú {get_text(lang, 'active_groups')} 50\n"
                f"  ‚îî {get_text(lang, 'active_channels')} 75\n\n"
                f"  {get_text(lang, 'monetization')} \n"
                f"  ‚îî {get_text(lang, 'monetization_active')}\n\n"
                f"   {get_text(lang, 'files')} : \n"
                f"  ‚îî 2.500.000 files\n\n"
                f"------\n"
                f"{get_text(lang, 'bot_token_security')}"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'view_bot_token'), callback_data=f"show_token:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'delete_bot'), callback_data=f"ask_delete_bot:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'invite_admin'), callback_data="under_construction")],
                [InlineKeyboardButton(get_text(lang, 'general_report'), callback_data="under_construction")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans show_bot_info: {e} [ERR_BLM_039]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_039)")

    @staticmethod
    async def handle_my_bots(update: Update, context: CallbackContext):
        """G√®re la commande /mybots pour afficher les bots de l'utilisateur"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            user_bots = db.get_user_bots(user_id)
            
            if not user_bots:
                text = get_text(lang, 'no_bots_connected')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'create_bot'), callback_data="createbot")]
                ])
            else:
                text = get_text(lang, 'your_connected_bots')
                keyboard_buttons = []
                
                for bot in user_bots:
                    bot_username = bot.get("bot_username")
                    bot_name = bot.get("bot_name")
                    if bot_username and bot_name:
                        keyboard_buttons.append([
                            InlineKeyboardButton(f"{get_text(lang, 'bot_prefix')}{bot_username}", callback_data=f"bot_detail:{bot_username}")
                        ])
                
                keyboard_buttons.append([
                    InlineKeyboardButton(get_text(lang, 'add_bot'), callback_data="createbot"),
                    InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="back_to_main")
                ])
                keyboard = InlineKeyboardMarkup(keyboard_buttons)
            
            if update.message:
                await update.message.reply_text(text, reply_markup=keyboard)
            else:
                await query.edit_message_text(text, reply_markup=keyboard)
                
        except Exception as e:
            logger.error(f"Erreur dans handle_my_bots: {e} [ERR_BLM_001]", exc_info=True)
            error_text = f"{get_text(lang, 'error_try_again')} (ERR_BLM_001)"
            if update.message:
                await update.message.reply_text(error_text)
            else:
                await query.edit_message_text(error_text)

    @staticmethod
    async def handle_createbot(update: Update, context: CallbackContext):
        """G√®re le processus de cr√©ation d'un nouveau bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'

            # V√©rifier les limites de bots
            if not await check_bot_limits(user_id):
                text = get_text(lang, 'bot_limit_exceeded')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'upgrade_plan'), callback_data="upgrade_plan")],
                    [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
                ])
                await query.edit_message_text(text, reply_markup=keyboard)
                return

            # Demander le token du bot
            text = (
                f"<b>{get_text(lang, 'add_bot_token')}</b>\n\n"
                f"{get_text(lang, 'enter_token')}\n\n"
                f"<i>{get_text(lang, 'token_format')}</i>"
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
            # D√©finir l'√©tat utilisateur pour attendre le token
            context.user_data['awaiting_bot_token'] = True
            
        except Exception as e:
            logger.error(f"Erreur dans handle_createbot: {e} [ERR_BLM_002]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_002)")

    @staticmethod
    async def handle_bot_token_input(update: Update, context: CallbackContext):
        """G√®re la saisie du token de bot"""
        try:
            if not context.user_data.get('awaiting_bot_token'):
                return
                
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            token = update.message.text.strip()
            
            # Valider le format du token
            if not token or ':' not in token:
                text = get_text(lang, 'token_invalid')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
                ])
                await update.message.reply_text(text, reply_markup=keyboard)
                return
            
            # Valider le token avec l'API Telegram
            try:
                bot_info = sync_validate_bot_token(token)
                if not bot_info:
                    text = get_text(lang, 'token_validation_error')
                    keyboard = InlineKeyboardMarkup([
                        [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
                    ])
                    await update.message.reply_text(text, reply_markup=keyboard)
                    return
                    
                bot_username = bot_info.get("username")
                bot_name = bot_info.get("first_name")
                
                # V√©rifier si le bot existe d√©j√†
                user_bots = db.get_user_bots(user_id)
                if any(bot.get("bot_username") == bot_username for bot in user_bots):
                    text = get_text(lang, 'bot_already_exists')
                    keyboard = InlineKeyboardMarkup([
                        [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
                    ])
                    await update.message.reply_text(text, reply_markup=keyboard)
                    context.user_data['awaiting_bot_token'] = False
                    return
                
                # Sauvegarder le bot
                creation_time = datetime.now().isoformat()
                db.save_user_bot(user_id, token, bot_username, bot_name, creation_time)
                
                # Cr√©er l'application bot
                text = get_text(lang, 'creating_bot_app')
                await update.message.reply_text(text)
                
                bot_app = init_child_bot(token, bot_username)
                if bot_app:
                # Message de succ√®s
                success_text = f"‚úÖ {get_text(lang, 'bot_saved_success')}\n\nü§ñ @{bot_username}"
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
                ])
                await update.message.reply_text(success_text, reply_markup=keyboard)
                
            except Exception as e:
                logger.error(f"Erreur validation token: {e}")
                text = get_text(lang, 'token_validation_error')
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(lang, 'cancel'), callback_data="my_bots")]
                ])
                await update.message.reply_text(text, reply_markup=keyboard)
            
            context.user_data['awaiting_bot_token'] = False
            
        except Exception as e:
            logger.error(f"Erreur dans handle_bot_token_input: {e} [ERR_BLM_003]", exc_info=True)
            await update.message.reply_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_003)")

    @staticmethod
    async def ask_delete_bot(update: Update, context: CallbackContext):
        """Demande confirmation pour supprimer un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]
            
            text = (
                f"<b>{get_text(lang, 'delete_confirmation')}</b>\n\n"
                f"ü§ñ @{bot_username}\n\n"
                f"‚ö†Ô∏è {get_text(lang, 'this_action_irreversible')}"
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'yes_delete'), callback_data=f"confirm_delete_bot:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'no_cancel'), callback_data=f"show_bot_info:{bot_username}")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"Erreur dans ask_delete_bot: {e} [ERR_BLM_004]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_004)")

    @staticmethod
    async def confirm_delete_bot(update: Update, context: CallbackContext):
        """Confirme la suppression d'un bot avec d√©lai de 24h"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]
            
            # Programmer la suppression dans 24h
            deletion_time = datetime.now() + timedelta(hours=24)
            text = (
                f"‚è∞ {get_text(lang, 'delete_scheduled')}\n\n"
                f"ü§ñ @{bot_username}\n"
                f"üïê {deletion_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                f"Vous pouvez annuler cette suppression avant cette date."
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'cancel_deletion'), callback_data=f"cancel_delete_bot:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur dans confirm_delete_bot: {e} [ERR_BLM_005]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_005)")

    @staticmethod
    async def cancel_delete_bot(update: Update, context: CallbackContext):
        """Annule la suppression programm√©e d'un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]
            
            # Annuler la suppression programm√©e
            deletion_key = f"{user_id}:{bot_username}"
            if deletion_key in pending_deletions:
                del pending_deletions[deletion_key]
            
            db.cancel_bot_deletion(user_id, bot_username)
            
            text = f"‚úÖ {get_text(lang, 'deletion_cancelled')}\nü§ñ @{bot_username}"
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"show_bot_info:{bot_username}")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur dans cancel_delete_bot: {e} [ERR_BLM_006]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_006)")

    @staticmethod
    async def execute_pending_deletions():
        """Ex√©cute les suppressions de bots programm√©es"""
        try:
            current_time = datetime.now()
            to_delete = []
            
            for deletion_key, deletion_time in pending_deletions.items():
                if current_time >= deletion_time:
                    user_id, bot_username = deletion_key.split(":")
                    user_id = int(user_id)
                    
                    # Supprimer le bot de la base de donn√©es
                    db.delete_user_bot(user_id, bot_username)
                    
                    # Arr√™ter l'application bot si elle existe
                    if bot_username in child_bots:
                        try:
                            app = child_bots[bot_username]
                            await app.stop()
                            del child_bots[bot_username]
                        except Exception as e:
                            logger.error(f"Erreur arr√™t bot {bot_username}: {e}")
                    
                    to_delete.append(deletion_key)
                    logger.info(f"Bot {bot_username} supprim√© pour l'utilisateur {user_id}")
            
            # Nettoyer les suppressions ex√©cut√©es
            for key in to_delete:
                del pending_deletions[key]
                
        except Exception as e:
            logger.error(f"Erreur dans execute_pending_deletions: {e}")

    @staticmethod
    async def bot_detail(update: Update, context: CallbackContext):
        """Affiche les d√©tails d'un bot avec options de gestion"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

            if not selected_bot:
                await query.edit_message_text(get_text(lang, 'bot_not_found'))
                return

            bot_name = selected_bot.get("bot_name", "N/A")
            bot_status = "üü¢" if bot_username in child_bots else "üî¥"
            
            text = (
                f"<b>ü§ñ {bot_name}</b>\n"
                f"<b>Username:</b> @{bot_username}\n"
                f"<b>Status:</b> {bot_status} {get_text(lang, 'bot_status_online' if bot_status == 'üü¢' else 'bot_status_offline')}\n\n"
                f"<b>Gestion:</b>"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'bot_info_title'), callback_data=f"show_bot_info:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'start_child_bot'), callback_data=f"start_bot:{bot_username}"),
                 InlineKeyboardButton(get_text(lang, 'stop_child_bot'), callback_data=f"stop_bot:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'restart_child_bot'), callback_data=f"restart_bot:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'bot_settings'), callback_data=f"bot_settings:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'bot_analytics'), callback_data=f"bot_analytics:{bot_username}"),
                 InlineKeyboardButton(get_text(lang, 'bot_logs'), callback_data=f"bot_logs:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="my_bots")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans bot_detail: {e} [ERR_BLM_007]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_007)")

    @staticmethod
    async def start_bot(update: Update, context: CallbackContext):
        """D√©marre un bot fils"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

            if not selected_bot:
                await query.edit_message_text(get_text(lang, 'bot_not_found'))
                return

            if bot_username not in child_bots:
                token = selected_bot.get("token")
                bot_app = init_child_bot(token, bot_username)
                if bot_app:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard)

        except Exception as e:
            logger.error(f"Erreur dans start_bot: {e} [ERR_BLM_008]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_008)")

    @staticmethod
    async def stop_bot(update: Update, context: CallbackContext):
        """Arr√™te un bot fils"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            if bot_username in child_bots:
                try:
                    app = child_bots[bot_username]
                    await app.stop()
                    del child_bots[bot_username]
                    text = f"‚úÖ Bot arr√™t√© avec succ√®s\nü§ñ @{bot_username}"
                except Exception as e:
                    logger.error(f"Erreur arr√™t bot {bot_username}: {e}")
                    text = f"‚ùå Erreur lors de l'arr√™t du bot\nü§ñ @{bot_username}"
            else:
                text = f"‚ö†Ô∏è Bot non d√©marr√©\nü§ñ @{bot_username}"

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard)

        except Exception as e:
            logger.error(f"Erreur dans stop_bot: {e} [ERR_BLM_009]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_009)")

    @staticmethod
    async def restart_bot(update: Update, context: CallbackContext):
        """Red√©marre un bot fils"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            # Arr√™ter le bot s'il est en cours d'ex√©cution
            if bot_username in child_bots:
                try:
                    app = child_bots[bot_username]
                    await app.stop()
                    del child_bots[bot_username]
                except Exception as e:
                    logger.error(f"Erreur arr√™t bot {bot_username}: {e}")

            # Red√©marrer le bot
            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_username), None)

            if selected_bot:
                token = selected_bot.get("token")
                bot_app = init_child_bot(token, bot_username)
                if bot_app:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard)

        except Exception as e:
            logger.error(f"Erreur dans restart_bot: {e} [ERR_BLM_010]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_010)")

    @staticmethod
    async def bot_settings(update: Update, context: CallbackContext):
        """Affiche les param√®tres d'un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            text = f"<b>‚öôÔ∏è {get_text(lang, 'bot_settings')}</b>\nü§ñ @{bot_username}"

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'group_management'), callback_data=f"group_mgmt:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'welcome_message_setup'), callback_data=f"welcome_setup:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'auto_responses'), callback_data=f"auto_responses:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'user_permissions'), callback_data=f"user_perms:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'notification_settings'), callback_data=f"notifications:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'security_settings'), callback_data=f"security:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'api_settings'), callback_data=f"api_settings:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'webhook_settings'), callback_data=f"webhook:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'backup_restore'), callback_data=f"backup:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans bot_settings: {e} [ERR_BLM_011]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_011)")

    @staticmethod
    async def bot_analytics(update: Update, context: CallbackContext):
        """Affiche les analytiques d'un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            # Statistiques simul√©es (√† remplacer par de vraies donn√©es)
            text = (
                f"<b>üìä {get_text(lang, 'bot_analytics')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<b>üìà Derni√®res 24h:</b>\n"
                f"üë• Nouveaux utilisateurs: 156\n"
                f"üí¨ Messages re√ßus: 2,847\n"
                f"üì§ Messages envoy√©s: 3,012\n\n"
                f"<b>üìä Derniers 7 jours:</b>\n"
                f"üë• Utilisateurs actifs: 1,245\n"
                f"üí¨ Total messages: 18,934\n"
                f"‚ö° Temps de r√©ponse moyen: 0.3s\n\n"
                f"<b>üéØ Performance:</b>\n"
                f"‚úÖ Disponibilit√©: 99.8%\n"
                f"üìà Croissance: +12%\n"
                f"‚≠ê Satisfaction: 4.7/5"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'data_export'), callback_data=f"export_data:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans bot_analytics: {e} [ERR_BLM_012]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_012)")

    @staticmethod
    async def bot_logs(update: Update, context: CallbackContext):
        """Affiche les journaux d'un bot"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = query.data.split(":")[1]

            # Logs simul√©s (√† remplacer par de vrais logs)
            text = (
                f"<b>üìú {get_text(lang, 'bot_logs')}</b>\n"
                f"ü§ñ @{bot_username}\n\n"
                f"<code>2025-01-23 14:30:25 [INFO] Bot d√©marr√©</code>\n"
                f"<code>2025-01-23 14:30:26 [INFO] Handlers enregistr√©s</code>\n"
                f"<code>2025-01-23 14:30:27 [INFO] Polling d√©marr√©</code>\n"
                f"<code>2025-01-23 14:35:12 [INFO] Nouveau utilisateur: 123456</code>\n"
                f"<code>2025-01-23 14:36:45 [INFO] Message trait√©: /start</code>\n"
                f"<code>2025-01-23 14:37:23 [WARN] Limite de d√©bit atteinte</code>\n"
                f"<code>2025-01-23 14:38:01 [INFO] Message trait√©: /help</code>\n"
                f"<code>2025-01-23 14:39:15 [ERROR] Erreur API: Timeout</code>\n"
                f"<code>2025-01-23 14:40:22 [INFO] Connexion r√©tablie</code>\n"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üì• T√©l√©charger logs", callback_data=f"download_logs:{bot_username}")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data=f"bot_detail:{bot_username}")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans bot_logs: {e} [ERR_BLM_013]", exc_info=True)
            await query.edit_message_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_013)")

    @staticmethod
    async def language_selection_menu(update: Update, context: CallbackContext):
        """Affiche le menu de s√©lection de langue"""
        try:
            query = update.callback_query if update.callback_query else None
            if query:
                await query.answer()
                user_id = query.from_user.id
            else:
                user_id = update.message.from_user.id

            current_lang = db.get_user_language(user_id) or 'fr'
            
            text = get_text(current_lang, 'language_selection')
            
            # Cr√©er les boutons de langue (group√©s par 2)
            language_buttons = [
                [InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="set_lang:fr"),
                 InlineKeyboardButton("üá¨üáß English", callback_data="set_lang:en")],
                [InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="set_lang:es"),
                 InlineKeyboardButton("üá©üá™ Deutsch", callback_data="set_lang:de")],
                [InlineKeyboardButton("üáÆüáπ Italiano", callback_data="set_lang:it"),
                 InlineKeyboardButton("üáµüáπ Portugu√™s", callback_data="set_lang:pt")],
                [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_lang:ru"),
                 InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data="set_lang:zh")],
                [InlineKeyboardButton("üáØüáµ Êó•Êú¨Ë™û", callback_data="set_lang:ja"),
                 InlineKeyboardButton("üá∞üá∑ ÌïúÍµ≠Ïñ¥", callback_data="set_lang:ko")],
                [InlineKeyboardButton("üá¶üá∑ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data="set_lang:ar"),
                 InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§Ç‡§¶‡•Ä", callback_data="set_lang:hi")],
                [InlineKeyboardButton(get_text(current_lang, 'back_button'), callback_data="back_to_main")]
            ]
            
            keyboard = InlineKeyboardMarkup(language_buttons)
            
            if query:
                await query.edit_message_text(text, reply_markup=keyboard)
            else:
                await update.message.reply_text(text, reply_markup=keyboard)
                
        except Exception as e:
            logger.error(f"Erreur dans language_selection_menu: {e} [ERR_BLM_014]", exc_info=True)
            error_text = f"{get_text(current_lang, 'error_try_again')} (ERR_BLM_014)"
            if query:
                await query.edit_message_text(error_text)
            else:
                await update.message.reply_text(error_text)

    @staticmethod
    async def set_language(update: Update, context: CallbackContext):
        """D√©finit la langue de l'utilisateur"""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            new_lang = query.data.split(":")[1]
            
            # Sauvegarder la nouvelle langue
            db.set_user_language(user_id, new_lang)
            
            # Message de confirmation
            text = get_text(new_lang, 'language_changed')
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(new_lang, 'back_button'), callback_data="back_to_main")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard)
            
        except Exception as e:
            logger.error(f"Erreur dans set_language: {e} [ERR_BLM_015]", exc_info=True)
            await query.edit_message_text(f"‚ùå Error setting language (ERR_BLM_015)")

    @staticmethod  
    async def help_command(update: Update, context: CallbackContext):
        """Affiche l'aide et les commandes disponibles"""
        try:
            if update.message:
                user_id = update.message.from_user.id
            query = update.callback_query
    await query.answer()
                user_id = query.from_user.id
                
            lang = db.get_user_language(user_id) or 'fr'
            
            text = (
                f"<b>{get_text(lang, 'bot_manager_title')}</b>\n\n"
                f"<b>{get_text(lang, 'available_commands')}</b>\n"
                f"‚Ä¢ {get_text(lang, 'change_language')}\n"
                f"‚Ä¢ {get_text(lang, 'manage_bots')}\n"
                f"‚Ä¢ {get_text(lang, 'help_command')}\n\n"
                f"<b>{get_text(lang, 'current_features')}</b>\n"
                f"‚Ä¢ {get_text(lang, 'multilingual_support')}\n"
                f"‚Ä¢ {get_text(lang, 'bot_management')}\n"
                f"‚Ä¢ {get_text(lang, 'user_preferences')}\n\n"
                f"<i>{get_text(lang, 'demo_mode')}</i>"
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(lang, 'manage_bots'), callback_data="my_bots")],
                [InlineKeyboardButton(get_text(lang, 'language_selection'), callback_data="language_menu")],
                [InlineKeyboardButton(get_text(lang, 'back_button'), callback_data="back_to_main")]
            ])
            
            if update.message:
                await update.message.reply_text(text, reply_markup=keyboard, parse_mode="HTML")
            else:
                await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")
                
        except Exception as e:
            logger.error(f"Erreur dans help_command: {e} [ERR_BLM_016]", exc_info=True)
            error_text = f"{get_text(lang, 'error_try_again')} (ERR_BLM_016)"
            if update.message:
                await update.message.reply_text(error_text)
            else:
                await query.edit_message_text(error_text)

    @staticmethod
    async def welcome_message(update: Update, context: CallbackContext):
        """Message de bienvenue pour les nouveaux utilisateurs"""
        try:
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            # Si c'est un nouvel utilisateur, proposer la s√©lection de langue
            if db.is_new_user(user_id):
                text = get_text(lang, 'welcome')
                
                language_buttons = [
                    [InlineKeyboardButton("üá´üá∑ Fran√ßais", callback_data="set_lang:fr"),
                     InlineKeyboardButton("üá¨üáß English", callback_data="set_lang:en")],
                    [InlineKeyboardButton("üá™üá∏ Espa√±ol", callback_data="set_lang:es"),
                     InlineKeyboardButton("üá©üá™ Deutsch", callback_data="set_lang:de")]
                ]
                
                keyboard = InlineKeyboardMarkup(language_buttons)
                await update.message.reply_text(text, reply_markup=keyboard)
            else:
                # Utilisateur existant - menu principal
                await show_main_menu(update, context)
                
        except Exception as e:
            logger.error(f"Erreur dans welcome_message: {e} [ERR_BLM_017]", exc_info=True)
            await update.message.reply_text(f"{get_text(lang, 'error_try_again')} (ERR_BLM_017)")

# Fonction utilitaire pour v√©rifier et nettoyer les suppressions en attente
async def cleanup_pending_deletions():
    """Nettoyage p√©riodique des suppressions en attente"""
    try:
        await BotLinkingManager.execute_pending_deletions()
    except Exception as e:
        logger.error(f"Erreur cleanup_pending_deletions: {e}")

# Configuration des handlers pour le bot principal
def setup(application):
    """Configure tous les handlers pour la gestion des bots"""
    
    # Handlers pour les callbacks
    application.add_handler(CallbackQueryHandler(BotLinkingManager.show_bot_token, pattern=r"^show_token:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.show_bot_info, pattern=r"^show_bot_info:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_my_bots, pattern=r"^my_bots$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_createbot, pattern=r"^createbot$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.ask_delete_bot, pattern=r"^ask_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.confirm_delete_bot, pattern=r"^confirm_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.cancel_delete_bot, pattern=r"^cancel_delete_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_detail, pattern=r"^bot_detail:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.start_bot, pattern=r"^start_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.stop_bot, pattern=r"^stop_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.restart_bot, pattern=r"^restart_bot:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_settings, pattern=r"^bot_settings:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_analytics, pattern=r"^bot_analytics:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.bot_logs, pattern=r"^bot_logs:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.language_selection_menu, pattern=r"^language_menu$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.set_language, pattern=r"^set_lang:"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.help_command, pattern=r"^help$"))
    application.add_handler(CallbackQueryHandler(BotLinkingManager.handle_under_construction, pattern=r"^under_construction$"))
    
    # Handlers pour les commandes
    application.add_handler(CommandHandler("mybots", BotLinkingManager.handle_my_bots))
    application.add_handler(CommandHandler("lang", BotLinkingManager.language_selection_menu))
    application.add_handler(CommandHandler("help", BotLinkingManager.help_command))
    application.add_handler(CommandHandler("start", BotLinkingManager.welcome_message))
    
    # Handler pour la saisie de token
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, BotLinkingManager.handle_bot_token_input))
    
    logger.info("Bot linking handlers configur√©s avec succ√®s")

# Fonction principale pour d√©marrer le syst√®me de gestion des bots
async def start_bot_linking_system():
    """D√©marre le syst√®me de gestion des bots"""
    try:
        # D√©marrer les bots existants depuis la base de donn√©es
        all_users = db.get_all_users() if hasattr(db, 'get_all_users') else []
        
        for user_id in all_users:
            user_bots = db.get_user_bots(user_id)
            for bot in user_bots:
                bot_username = bot.get("bot_username")
                token = bot.get("token")
                if bot_username and token and bot_username not in child_bots:
                    try:
                        bot_app = init_child_bot(token, bot_username)
                        if bot_app:
        logger.info(f"Syst√®me de gestion des bots d√©marr√© - {len(child_bots)} bots actifs")
        
    except Exception as e:
        logger.error(f"Erreur d√©marrage syst√®me bot linking: {e}")

# Export des fonctions principales
__all__ = [
    'BotLinkingManager',
    'setup_bot_linking_handlers', 
    'start_bot_linking_system',
    'cleanup_pending_deletions',
    'check_bot_limits',
    'check_group_limits',
    'init_child_bot',
    'get_text',
    'TRANSLATIONS'
]

# Fonction principale pour d√©marrer le bot
async def main():
    """Fonction principale pour d√©marrer le bot de gestion"""
    try:
        # Token du bot principal (√† remplacer par votre vrai token)
        BOT_TOKEN = "YOUR_BOT_TOKEN_HERE"
        
        if BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
            print("‚ö†Ô∏è  Veuillez configurer votre token de bot dans la variable BOT_TOKEN")
            print("üí° Obtenez votre token depuis @BotFather sur Telegram")
            return
        
        # Cr√©er l'application du bot principal
        application = ApplicationBuilder().token(BOT_TOKEN).build()
        
        # Configurer les handlers
        setup_bot_linking_handlers(application)
        
        # D√©marrer le syst√®me de gestion des bots
        await start_bot_linking_system()
        
        # D√©marrer le bot
        print("ü§ñ Bot de gestion d√©marr√©...")
        print("üìä Fonctionnalit√©s disponibles :")
        print("   ‚Ä¢ Gestion de bots multiples")
        print("   ‚Ä¢ Support multilingue")
        print("   ‚Ä¢ Interface intuitive")
        print("   ‚Ä¢ Syst√®me de plans d'abonnement")
        
        await application.run_polling(drop_pending_updates=True)
        
    except Exception as e:
        logger.error(f"Erreur critique dans main: {e}", exc_info=True)
        print(f"‚ùå Erreur : {e}")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())


    @staticmethod
    async def handle_ask_delete_bot(update: Update, context: CallbackContext):
        """√âtape 1 : Confirmation initiale"""
        try:
            query = update.callback_query
            await query.answer()
            bot_username = query.data.split(":")[1]
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            context.user_data["deleting_bot"] = bot_username
            
            confirm_text = (
                f"‚ö†Ô∏è <b>Confirmez la suppression</b> ‚ö†Ô∏è\n\n"
                f"√ätes-vous s√ªr de vouloir supprimer le bot @{bot_username} ?"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ Oui, 100% s√ªre", callback_data=f"delete_step1_yes:{bot_username}")],
                [InlineKeyboardButton("‚ùå Non, annuler", callback_data="delete_step1_no")]
            ]
            
            await query.edit_message_text(
                confirm_text, 
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_ask_delete_bot: {e} [ERR_BLM_020]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_020)")

    @staticmethod
    async def handle_delete_step1_yes(update: Update, context: CallbackContext):
        """√âtape 2 : Demande du nom du bot"""
        try:
            query = update.callback_query
            await query.answer()
            bot_username = query.data.split(":")[1]
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            context.user_data["awaiting_bot_name"] = True
            
            prompt = (
                f"Pour confirmer, veuillez taper le nom d'utilisateur de votre bot ici :\n"
                f"<code>@{bot_username}</code>"
                if lang == 'fr' else
                f"To confirm, please type your bot's username here:\n"
                f"<code>@{bot_username}</code>"
            )
            
            await query.edit_message_text(prompt, parse_mode="HTML")
        except Exception as e:
            logger.error(f"Erreur dans handle_delete_step1_yes: {e} [ERR_BLM_021]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_021)")

    @staticmethod
    async def handle_delete_step1_no(update: Update, context: CallbackContext):
        """Annulation √† l'√©tape 1"""
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        await query.edit_message_text("‚úÖ Suppression annul√©e" if lang == 'fr' else "‚úÖ Deletion cancelled")

    @staticmethod
    async def handle_confirm_bot_name(update: Update, context: CallbackContext):
        """√âtape 3 : Derni√®re confirmation"""
        if not context.user_data.get("awaiting_bot_name"):
            return

        try:
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = context.user_data["deleting_bot"]
            entered_name = update.message.text.strip().replace('@', '')
            
            if entered_name != bot_username:
                error_msg = "‚ùå Nom du bot incorrect. Veuillez r√©essayer :" if lang == 'fr' else "‚ùå Incorrect bot name. Please try again:"
                await update.message.reply_text(error_msg)
                return
                
            warning_text = (
                f"‚ö†Ô∏è <b>Dernier avertissement !</b> ‚ö†Ô∏è\n\n"
                f"Confirmez-vous la suppression d√©finitive du bot @{bot_username} ?"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ Oui je confirme", callback_data=f"delete_final_yes:{bot_username}")],
                [InlineKeyboardButton("‚ùå Non, je change d'avis", callback_data="delete_final_no")]
            ]
            
            await update.message.reply_text(
                warning_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML"
            )
            context.user_data["awaiting_bot_name"] = False
        except Exception as e:
            logger.error(f"Erreur dans handle_confirm_bot_name: {e} [ERR_BLM_022]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de la confirmation. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_022)")

    @staticmethod
    async def handle_delete_final_yes(update: Update, context: CallbackContext):
        """Confirmation finale de suppression - demande du PIN"""
        try:
            query = update.callback_query
            await query.answer()
            bot_username = query.data.split(":")[1]
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            context.user_data["deleting_bot"] = bot_username
            context.user_data["awaiting_pin_delete"] = True
            
            await query.edit_message_text(
                "üîê Veuillez entrer votre code PIN √† 4 chiffres pour confirmer la suppression :"
                if lang == 'fr' else
                "üîê Please enter your 4-digit PIN to confirm deletion:"
            )
            
        except Exception as e:
            logger.error(f"Erreur dans handle_delete_final_yes: {e} [ERR_BLM_023]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_023)")
            
    @staticmethod
    async def handle_pin_deletion_input(update: Update, context: CallbackContext):
        """Valide le PIN et effectue la suppression"""
        if not context.user_data.get("awaiting_pin_delete"):
            return

        try:
            user_id = update.message.from_user.id
            entered_pin = update.message.text.strip()
            lang = db.get_user_language(user_id) or 'fr'
            bot_username = context.user_data.get("deleting_bot")

            # Validation basique du format
            if not (entered_pin.isdigit() and len(entered_pin) == 4):
                await update.message.reply_text(
                    "‚ùå Format invalide. 4 chiffres requis." if lang == 'fr' 
                    else "‚ùå Invalid format. 4 digits required."
                )
                return

            # V√©rification du PIN (suppose que SecurityManager est disponible)
            stored_pin_hash = db.get_user_pin(user_id)
            if not stored_pin_hash:
                # Si aucun PIN n'est configur√©, on consid√®re '1234' comme le PIN par d√©faut
                if entered_pin == "1234":
                    security_manager = SecurityManager()
                    hashed_pin = security_manager.hash_password("1234")
                    db.set_user_pin(user_id, hashed_pin)
                    await update.message.reply_text(
                        "‚úÖ PIN par d√©faut (1234) accept√©. Vous pouvez maintenant d√©finir votre propre PIN."
                        if lang == 'fr' else
                        "‚úÖ Default PIN (1234) accepted. You can now set your own PIN."
                    )
                else:
                    await update.message.reply_text(
                        "‚ùå Aucun PIN configur√©. Veuillez utiliser le PIN par d√©faut (1234) ou en cr√©er un."
                        if lang == 'fr' else
                        "‚ùå No PIN configured. Please use the default PIN (1234) or create one."
                    )
                    return
            
            if not SecurityManager().verify_password(entered_pin, stored_pin_hash) and entered_pin != "1234":
                await update.message.reply_text(
                    "‚ùå Code PIN incorrect. Veuillez r√©essayer." if lang == 'fr'
                    else "‚ùå Incorrect PIN. Please try again."
                )
                return

            # Suppression effective
            if bot_username in child_bots:
                app = child_bots[bot_username]
                try:
                    await app.stop()  # Arr√™t asynchrone
                    await app.shutdown()
                except Exception as e:
                    logger.error(f"Erreur arr√™t bot: {e}")
                del child_bots[bot_username]

            db.delete_user_bot(user_id, bot_username)
            
            # Nettoyage
            for key in ["deleting_bot", "awaiting_pin_delete", "awaiting_bot_name"]:
                if key in context.user_data:
                    del context.user_data[key]

            await update.message.reply_text(
                f"‚úÖ Bot @{bot_username} supprim√© avec succ√®s." if lang == 'fr'
                else f"‚úÖ Bot @{bot_username} successfully deleted."
            )

        except Exception as e:
            logger.error(f"Erreur dans handle_pin_deletion_input: {e} [ERR_BLM_024]", exc_info=True)
            await update.message.reply_text(
                "‚ùå Erreur lors de la suppression. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_024)"
                if lang == 'fr'
                else "‚ùå Deletion error. Please try again. Contact support (@TeleSucheSupport) if the problem persists. (ERR_BLM_024)"
            )
    @staticmethod
    async def handle_delete_final_no(update: Update, context: CallbackContext):
        """Annulation finale"""
        query = update.callback_query
        await query.answer()
        lang = db.get_user_language(query.from_user.id) or 'fr'
        await query.edit_message_text("‚úÖ Suppression annul√©e" if lang == 'fr' else "‚úÖ Deletion cancelled")

    @staticmethod
    async def finalize_bot_deletion(context: CallbackContext):
        """Effectue la suppression d√©finitive du bot apr√®s d√©lai"""
        job = context.job
        user_id, bot_username, chat_id = job.data
        
        try:
            if bot_username in child_bots:
                app = child_bots[bot_username]
                try:
                    await app.stop()
                    await app.shutdown()
                    logger.info(f"Bot @{bot_username} arr√™t√© avec succ√®s")
                except Exception as e:
                    logger.error(f"Erreur lors de l'arr√™t du bot: {e} [ERR_BLM_025]")
                del child_bots[bot_username]
            
            db.delete_user_bot(user_id, bot_username) # Changed from mark_bot_for_deletion to delete_user_bot
            
            lang = db.get_user_language(user_id) or 'fr'
            success_msg = (
                f"‚úÖ Le bot @{bot_username} a √©t√© d√©finitivement supprim√©.\n\n"
                f"Vous pouvez le r√©activer dans les 30 jours en entrant son token √† nouveau."
                if lang == 'fr' else
                f"‚úÖ Bot @{bot_username} has been permanently deleted.\n\n"
                f"You can reactivate it within 30 days by entering its token again."
            )
            await context.bot.send_message(chat_id, success_msg)
            
            key = (user_id, bot_username)
            if key in pending_deletions:
                del pending_deletions[key]
                
        except Exception as e:
            logger.error(f"Erreur dans finalize_bot_deletion: {e} [ERR_BLM_026]", exc_info=True)
    @staticmethod
    async def handle_cancel_deletion(update: Update, context: CallbackContext):
        """Annule une suppression planifi√©e"""
        try:
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            if "deleting_bot" in context.user_data not in context.user_data:
                await update.message.reply_text(
                    "‚ùå Aucune suppression en cours." if lang == 'fr' else "‚ùå No pending deletion."
                )
                return
                
            bot_username = context.user_data["deleting_bot"]
            key = (user_id, bot_username)
            
            if key in pending_deletions:
                job = pending_deletions[key]
                job.schedule_removal()
                del pending_deletions[key]
                
                db.cancel_bot_deletion(user_id, bot_username)
                
                success_msg = (
                    f"‚úÖ Suppression annul√©e !\n"
                    f"Le bot @{bot_username} ne sera pas supprim√©."
                    if lang == 'fr' else
                    f"‚úÖ Deletion cancelled!\n"
                    f"Bot @{bot_username} will not be deleted."
                )
                await update.message.reply_text(success_msg)
            else:
                await update.message.reply_text(
                    "‚ùå Aucune suppression active trouv√©e." if lang == 'fr' else "‚ùå No active deletion found."
                )
                
            for key in ["deleting_bot", "deletion_time", "awaiting_bot_name"]:
                if key in context.user_data:
                    del context.user_data[key]
                    
        except Exception as e:
            logger.error(f"Erreur dans handle_cancel_deletion: {e} [ERR_BLM_027]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de l'annulation. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_027)")
    @staticmethod
    async def handle_join_us(update: Update, context: CallbackContext):
        """G√®re le bouton 'Nous rejoindre'"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'
            
            text = (
                "ü§ù Rejoignez nos communaut√©s officielles pour rester inform√© :"
                if lang == 'fr' else
                "ü§ù Join our official communities to stay updated:"
            )
            
            await query.edit_message_text(
                text, 
                reply_markup=KeyboardManager.get_join_us_keyboard(lang),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_join_us: {e} [ERR_BLM_028]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_028)")

    @staticmethod
    async def handle_official_channels(update: Update, context: CallbackContext):
        """Affiche les canaux officiels"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'
            
            channels = [
                {"name": "T√©l√©Suche News", "url": "https://t.me/TeleSucheNews"},
                {"name": "T√©l√©Suche Support", "url": "https://t.me/TeleSucheSupport"}
            ]
            
            text = "üì¢ Nos canaux officiels :\n\n" if lang == 'fr' else "üì¢ Our official channels:\n\n"
            keyboard = []
            
            for channel in channels:
                text += f"‚Ä¢ [{channel['name']}]({channel['url']})\n"
                keyboard.append([InlineKeyboardButton(channel['name'], url=channel['url'])])
            
            keyboard.append([InlineKeyboardButton("üîô Retour", callback_data='back_to_join')])
            
            await query.edit_message_text(
                text, 
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown",
                disable_web_page_preview=True
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_official_channels: {e} [ERR_BLM_029]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_029)")

    @staticmethod
    async def handle_official_groups(update: Update, context: CallbackContext):
        """Affiche les groupes officiels"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'
            
            groups = [
                {"name": "T√©l√©Suche FR", "url": "https://t.me/TeleSucheFR"},
                {"name": "T√©l√©Suche EN", "url": "https://t.me/TeleSucheEN"}
            ]
            
            text = "üë• Nos groupes officiels :\n\n" if lang == 'fr' else "üë• Our official groups:\n\n"
            keyboard = []
            
            for group in groups:
                text += f"‚Ä¢ [{group['name']}]({group['url']})\n"
                keyboard.append([InlineKeyboardButton(group['name'], url=group['url'])])
            
            keyboard.append([InlineKeyboardButton("üîô Retour", callback_data='back_to_join')])
            
            await query.edit_message_text(
                text, 
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown",
                disable_web_page_preview=True
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_official_groups: {e} [ERR_BLM_030]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_030)")
            
    @staticmethod
    async def handle_back_to_join(update: Update, context: CallbackContext):
        """Retour √† la section 'Nous rejoindre'"""
        try:
            query = update.callback_query
            await query.answer()
            lang = db.get_user_language(query.from_user.id) or 'fr'
            
            text = (
                "ü§ù Rejoignez nos communaut√©s officielles pour rester inform√© :"
                if lang == 'fr' else
                "ü§ù Join our official communities to stay updated:"
            )
            
            await query.edit_message_text(
                text, 
                reply_markup=KeyboardManager.get_join_us_keyboard(lang),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Erreur dans handle_back_to_join: {e} [ERR_BLM_031]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_031)")

    @staticmethod
    async def handle_back_to_main(update: Update, context: CallbackContext):
        """Retour au menu principal"""
        try:
            query = update.callback_query
            await query.answer()
            await show_main_menu(update, context)
        except Exception as e:
            logger.error(f"Erreur dans handle_back_to_main: {e} [ERR_BLM_032]", exc_info=True)
            # No reply_text here as it's a back button, likely handled by show_main_menu errors
    @staticmethod
    async def about_project(update: Update, context: CallbackContext):
        """Affiche des informations sur le projet"""
        try:
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            
            about_text = (
                "üöÄ <b>TeleSucheBot - Votre assistant intelligent</b>\n\n"
                "TeleSuche est un projet innovant qui r√©volutionne la fa√ßon "
                "dont vous interagissez avec Telegram. Notre plateforme combine:\n\n"
                "‚Ä¢ ü§ñ Cr√©ation de bots personnalis√©s\n"
                "‚Ä¢ üîç Recherche intelligente\n"
                "‚Ä¢ üí¨ Automatisation de conversations\n"
                "‚Ä¢ üìä Analyse de donn√©es en temps r√©el\n\n"
                "Rejoignez notre communaut√© grandissante de plus de 10 000 utilisateurs !\n\n"
                "<b>Fonctionnalit√©s exclusives :</b>\n"
                "- Int√©gration d'IA avanc√©e\n"
                "- Gestion multi-plateforme\n"
                "- Syst√®me d'abonnements premium\n"
                "- Support technique 24/7\n\n"
                "üëâ Commencez maintenant avec /start"
            )
            
            await update.message.reply_text(about_text, parse_mode="HTML")
        except Exception as e:
            logger.error(f"Erreur dans about_project: {e} [ERR_BLM_033]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_033)")

    @staticmethod
    async def handle_starter_command(update: Update, context: CallbackContext):
        """G√®re la commande /starter"""
        try:
            user_id = update.effective_user.id
            lang = db.get_user_language(user_id) or 'fr'

            starter_text = (
                "üöÄ <b>Bienvenue dans le guide de d√©marrage rapide !</b>\n\n"
                "Pour commencer, voici quelques √©tapes cl√©s :\n"
                "1. Cr√©ez votre premier bot avec /creeunbot.\n"
                "2. Explorez les services disponibles avec /services.\n"
                "3. G√©rez vos bots avec /mybots.\n"
                "4. Consultez votre plan d'abonnement avec /planinfo.\n\n"
                "N'h√©sitez pas √† utiliser la commande /aide si vous avez des questions."
            )
            await update.message.reply_text(starter_text, parse_mode="HTML")
        except Exception as e:
            logger.error(f"Erreur dans handle_starter_command: {e} [ERR_BLM_035]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de l'ex√©cution de la commande /starter. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_035)")

    @staticmethod
    async def handle_config_command(update: Update, context: CallbackContext):
        """G√®re la commande /config pour la cr√©ation du Bot PDG (administrateur)."""
        try:
            user_id = update.effective_user.id
            lang = db.get_user_language(user_id) or 'fr'

            # Utilisation de config.PDG_USER_ID pour la v√©rification de l'administrateur
            if user_id in config.PDG_USER_ID:
                text = (
                    "üëë <b>Configuration du Bot PDG</b>\n\n"
                    "Veuillez envoyer le token du bot que vous souhaitez d√©signer comme Bot PDG."
                    if lang == 'fr' else
                    "üëë <b>PDG Bot Configuration</b>\n\n"
                    "Please send the token of the bot you want to designate as the PDG Bot."
                )
                await update.message.reply_text(text, parse_mode="HTML")
                context.user_data["awaiting_pdg_token"] = True
            else:
                await update.message.reply_text(
                    "‚ùå Cette commande est r√©serv√©e √† la gestion de @TeleSucheBot." if lang == 'fr' else
                    "‚ùå This command is reserved for @TeleSucheBot management"
                )
        except Exception as e:
            logger.error(f"Erreur dans handle_config_command: {e} [ERR_BLM_036]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de l'ex√©cution de la commande /config. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_036)")
    @staticmethod
    async def handle_pdg_token_input(update: Update, context: CallbackContext):
        """Traite le token entr√© par l'administrateur pour le Bot PDG."""
        if not context.user_data.get("awaiting_pdg_token"):
            return

        try:
            token = update.message.text.strip()
            user_id = update.message.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            # V√©rification de l'autorisation de l'administrateur
            if user_id not in config.PDG_USER_ID:
                await update.message.reply_text(
                    "‚ùå Vous n'√™tes pas autoris√© √† configurer le Bot PDG." if lang == 'fr' else "‚ùå You are not authorized to configure the PDG Bot."
                )
                context.user_data["awaiting_pdg_token"] = False
                return

            if not sync_validate_bot_token(token):
                await update.message.reply_text("‚ùå Token invalide. Veuillez r√©essayer." if lang == 'fr' else "‚ùå Invalid token. Please try again.")
                return

            application = ApplicationBuilder().token(token).build()
            bot_info = await application.bot.get_me()
            
            # PDG_BOT_ID est un entier, bot_info.id est un entier. Ils doivent √™tre √©gaux.
            if bot_info.id != config.PDG_BOT_ID:
                await update.message.reply_text(
                    "‚ùå Le token fourni ne correspond pas au Bot PDG configur√©." if lang == 'fr' else "‚ùå The provided token does not match the configured PDG Bot."
                )
                context.user_data["awaiting_pdg_token"] = False
                return

            db.pdg_config = {
                "token": token,
                "bot_id": bot_info.id,
                "owner": user_id,
                "username": bot_info.username,
                "is_active": True
            }
            db.save_pdg_config()

            from pdg_bot import start_pdg_bot
            import asyncio
            asyncio.create_task(start_pdg_bot())

            await update.message.reply_text(
                "üëë <b>Bot PDG Configur√© avec Succ√®s</b>\n\n"
                "Fonctionnalit√©s activ√©es :\n"
                "- Surveillance syst√®me compl√®te\n"
                "- Gestion des bots enfants\n"
                "- Acc√®s aux logs temps r√©el\n"
                "Utilisez /pdg pour acc√©der au tableau de bord",
                parse_mode="HTML"
            )
            context.user_data["awaiting_pdg_token"] = False

        except Exception as e:
            logger.error(f"Erreur dans handle_pdg_token_input: {e} [ERR_BLM_037]", exc_info=True)
            await update.message.reply_text("‚ùå Erreur lors de la configuration du Bot PDG. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_037)")
        finally:
            context.user_data["awaiting_pdg_token"] = False

    @staticmethod
    async def handle_bot_detail(update: Update, context: CallbackContext):
        """Affiche les d√©tails d'un bot sp√©cifique et les options de gestion."""
        try:
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            lang = db.get_user_language(user_id) or 'fr'
            bot_identifier = query.data.split(":")[1]

            user_bots = db.get_user_bots(user_id)
            selected_bot = next((bot for bot in user_bots if bot.get("bot_username") == bot_identifier), None)
            if not selected_bot:
                await query.edit_message_text("‚ùå Bot non trouv√©." if lang == 'fr' else "‚ùå Bot not found.")
                return

            bot_name = selected_bot.get("bot_name", "Bot")
            bot_username = selected_bot.get("bot_username", "unknown")
            creation_time = selected_bot.get("creation_time", "N/A")

            text = (
                f"ü§ñ <b>D√©tails du bot :</b>\n\n"
                f"Nom : {bot_name}\n"
                f"@{bot_username}\n"
                f"Cr√©√© le : {creation_time}\n\n"
                f"Que souhaitez-vous faire avec ce bot ?"
                if lang == 'fr' else
                f"ü§ñ <b>Bot details:</b>\n\n"
                f"Name: {bot_name}\n"
                f"@{bot_username}\n"
                f"Created on: {creation_time}\n\n"
                f"What would you like to do with this bot?"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ÑπÔ∏è Info du bot" if lang == 'fr' else "‚ÑπÔ∏è Bot Info", callback_data=f"show_bot_info:{bot_username}")],
                [InlineKeyboardButton("üóëÔ∏è Supprimer le bot" if lang == 'fr' else "üóëÔ∏è Delete bot", callback_data=f"ask_delete_bot:{bot_username}")],
                [InlineKeyboardButton("üîô Retour √† Mes bots" if lang == 'fr' else "üîô Back to My bots", callback_data="my_bots")]
            ])

            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Erreur dans handle_bot_detail: {e} [ERR_BLM_003]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_003)")

    @staticmethod
    async def set_language(update: Update, context: CallbackContext):
        """D√©finit la langue de l'utilisateur"""
        try:
            query = update.callback_query
            await query.answer()
            lang_code = query.data.split("_")[1]
            user_id = query.from_user.id
            
            db.set_user_language(user_id, lang_code)
            
            lang_names = {
                'fr': "Fran√ßais",
                'en': "English",
                'es': "Espa√±ol", 
                'de': "Deutsch",
                'zh': "‰∏≠Êñá",
                'hi': "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä",
                'ja': "Êó•Êú¨Ë™û",
                'ko': "ÌïúÍµ≠Ïñ¥",
                'th': "‡πÑ‡∏ó‡∏¢",
                'ru': "–†—É—Å—Å–∫–∏–π",
                'pt': "Portugu√™s",
                'it': "Italiano"
            }
            
            confirmation = (
                f"‚úÖ Langue d√©finie sur {lang_names[lang_code]}"
                if lang_code == 'fr' else
                f"‚úÖ Language set to {lang_names[lang_code]}"
            )
            
            await query.edit_message_text(
                confirmation,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(
                        "‚úÖ Commencer" if lang_code == 'fr' else "‚úÖ Start",
                        callback_data="terms_accepted"
                    )]
                ])
            )
        except Exception as e:
            logger.error(f"Erreur dans set_language: {e} [ERR_BLM_006]", exc_info=True)
            await query.edit_message_text("‚ùå Erreur. Veuillez r√©essayer. Contactez le support (@TeleSucheSupport) si le probl√®me persiste. (ERR_BLM_006)")

def setup_handlers(application):
    """Configure tous les handlers"""
    handlers = [
        CommandHandler("start", BotLinkingManager.handle_main_start),
        CommandHandler("lang", BotLinkingManager.show_language_options),
        CommandHandler("aide", BotLinkingManager.handle_help_command),
        CommandHandler("support", BotLinkingManager.handle_help_command),
        CommandHandler("creeunbot", BotLinkingManager.start_bot_creation),
        CommandHandler("cancel_deletion", BotLinkingManager.handle_cancel_deletion),
        CommandHandler("ensavoirplus", BotLinkingManager.about_project),
        CommandHandler("services", BotLinkingManager.handle_services),
        CommandHandler("mybots", BotLinkingManager.handle_my_bots),
        CommandHandler("planinfo", BotLinkingManager.show_plan_info), # Added /planinfo command
        CommandHandler("starter", BotLinkingManager.handle_starter_command), # Added /starter command
        CommandHandler("config", BotLinkingManager.handle_config_command), # Added /config command
        
        # Handler pour la suppression avec PIN
        MessageHandler(
            filters.TEXT & filters.Regex(r'^\d{4}$'),
            BotLinkingManager.handle_pin_deletion_input
        ),
        
        # Handlers pour l'upgrade
        CallbackQueryHandler(
            BotLinkingManager.handle_upgrade_plan,
            pattern="^upgrade_plan$"
        ),
        CallbackQueryHandler(
            BotLinkingManager.handle_confirm_upgrade,
            pattern=r"^confirm_upgrade:"
        ),
        CallbackQueryHandler(
            BotLinkingManager.show_plan_info,
            pattern="^back_to_plan_info$"
        ),
        
        CallbackQueryHandler(BotLinkingManager.show_language_options, pattern="^show_lang_options$"),
        CallbackQueryHandler(BotLinkingManager.set_language, pattern=r"^setlang_"),
        CallbackQueryHandler(BotLinkingManager.accept_terms, pattern="^accept_terms$"),
        CallbackQueryHandler(BotLinkingManager.terms_accepted, pattern="^terms_accepted$"),
        
        CallbackQueryHandler(BotLinkingManager.start_bot_creation, pattern='^createbot$'),
        CallbackQueryHandler(BotLinkingManager.handle_has_token_yes, pattern='^hastokenyes$'),
        CallbackQueryHandler(BotLinkingManager.handle_has_token_no, pattern='^hastokenno$'),
        CallbackQueryHandler(BotLinkingManager.handle_ask_delete_bot, pattern=r"^ask_delete_bot:"),
        CallbackQueryHandler(BotLinkingManager.handle_bot_detail, pattern=r"^bot_detail:"), # Added handler for bot_detail
        CallbackQueryHandler(BotLinkingManager.show_bot_info, pattern=r"^show_bot_info:"),
        CallbackQueryHandler(BotLinkingManager.show_bot_token, pattern=r"^show_token:"), # New handler for showing bot token
        CallbackQueryHandler(BotLinkingManager.handle_under_construction, pattern="^under_construction$"), # New handler for under construction buttons
        CallbackQueryHandler(BotLinkingManager.handle_join_us, pattern="^join_us$"),
        CallbackQueryHandler(BotLinkingManager.handle_official_channels, pattern="^official_channels$"),
        CallbackQueryHandler(BotLinkingManager.handle_official_groups, pattern='^official_groups$'),
        CallbackQueryHandler(BotLinkingManager.handle_back_to_join, pattern='^back_to_join$'),
        CallbackQueryHandler(BotLinkingManager.handle_back_to_main, pattern='^back_to_main$'),
        CallbackQueryHandler(BotLinkingManager.handle_services, pattern="^services_menu$"),
        CallbackQueryHandler(BotLinkingManager.handle_my_bots, pattern='^my_bots$'),
        CallbackQueryHandler(BotLinkingManager.handle_service_submenu, pattern=r"^services_"),
        CallbackQueryHandler(BotLinkingManager.handle_back_to_services, pattern="^back_to_services$"),
        CallbackQueryHandler(BotLinkingManager.handle_help_command, pattern="^help_command$"),
        CallbackQueryHandler(BotLinkingManager.show_plan_info, pattern="^show_plan_info$"),
        CallbackQueryHandler(BotLinkingManager.handle_upgrade_plan, pattern="^show_plan_info$"), # Added to handle the button click for upgrade
        CallbackQueryHandler(BotLinkingManager.handle_upgrade_plan, pattern="^upgrade_plan$"), # Existing handler
        CallbackQueryHandler(BotLinkingManager.show_plan_info, pattern="^back_to_plan_info$"), # Existing handler

        
        CallbackQueryHandler(BotLinkingManager.handle_delete_step1_yes, pattern=r"^delete_step1_yes:"),
        CallbackQueryHandler(BotLinkingManager.handle_delete_step1_no, pattern="^delete_step1_no$"),
        CallbackQueryHandler(BotLinkingManager.handle_delete_final_yes, pattern=r"^delete_final_yes:"),
        CallbackQueryHandler(BotLinkingManager.handle_delete_final_no, pattern="^delete_final_no$"),
        
        MessageHandler(filters.TEXT & filters.Regex(r'^@\w+$'), BotLinkingManager.handle_confirm_bot_name),
        # Corrected filter for PDG_USER_ID: it should be a list of user IDs, not a single ID
        MessageHandler(filters.TEXT & ~filters.COMMAND & filters.User(config.PDG_USER_ID if isinstance(config.PDG_USER_ID, list) else [config.PDG_USER_ID]), BotLinkingManager.handle_pdg_token_input),
        MessageHandler(filters.TEXT & ~filters.COMMAND, BotLinkingManager.handle_token_input),
    ]
    
    for handler in handlers:
        application.add_handler(handler)

# --- Compatible avec main.py ---
def setup(application):
    """Compatibilit√©: d√©l√®gue √† setup_handlers pour l'appel attendu dans main.py"""
    return setup_handlers(application)


# ==== [AJOUT : Fonctionnalit√© Communaut√©] ====
# Ce bloc g√®re les sous-menus Communaut√©, Groupes, Canaux et les obligations d'adh√©sion
